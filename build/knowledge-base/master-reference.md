# Kiro Master Reference

## Table of Contents

- [Specs](#specs)
  - [Best practices - IDE - Docs - Kiro](#best-practices-ide-docs-kiro)
  - [Concepts - IDE - Docs - Kiro](#concepts-ide-docs-kiro)
  - [Correctness with Property-based tests - IDE - Docs - Kiro](#correctness-with-property-based-tests-ide-docs-kiro)
  - [Specs - IDE - Docs - Kiro](#specs-ide-docs-kiro)
- [Hooks](#hooks)
  - [Hook actions - IDE - Docs - Kiro](#hook-actions-ide-docs-kiro)
  - [Best practices - IDE - Docs - Kiro](#best-practices-ide-docs-kiro)
  - [Hook examples - IDE - Docs - Kiro](#hook-examples-ide-docs-kiro)
  - [Hooks - IDE - Docs - Kiro](#hooks-ide-docs-kiro)
  - [Hook management - IDE - Docs - Kiro](#hook-management-ide-docs-kiro)
  - [Troubleshooting Hooks - IDE - Docs - Kiro](#troubleshooting-hooks-ide-docs-kiro)
  - [Hook types - IDE - Docs - Kiro](#hook-types-ide-docs-kiro)
- [Steering Docs](#steering-docs)
  - [Steering - IDE - Docs - Kiro](#steering-ide-docs-kiro)
- [Skills](#skills)
  - [Agent Skills - IDE - Docs - Kiro](#agent-skills-ide-docs-kiro)
- [Powers](#powers)
  - [Create powers - IDE - Docs - Kiro](#create-powers-ide-docs-kiro)
  - [Install powers - IDE - Docs - Kiro](#install-powers-ide-docs-kiro)
  - [Powers - IDE - Docs - Kiro](#powers-ide-docs-kiro)
- [MCP Servers](#mcp-servers)
  - [Configuration - IDE - Docs - Kiro](#configuration-ide-docs-kiro)
  - [Model context protocol (MCP) - IDE - Docs - Kiro](#model-context-protocol-mcp-ide-docs-kiro)
  - [Best practices - IDE - Docs - Kiro](#best-practices-ide-docs-kiro)
  - [Server directory - IDE - Docs - Kiro](#server-directory-ide-docs-kiro)
  - [Tools - IDE - Docs - Kiro](#tools-ide-docs-kiro)
- [Custom Agents (CLI)](#custom-agents-cli)
  - [Agent Client Protocol (ACP) - CLI - Docs - Kiro](#agent-client-protocol-acp-cli-docs-kiro)
  - [Authentication methods - CLI - Docs - Kiro](#authentication-methods-cli-docs-kiro)
  - [Completions & autocomplete - CLI - Docs - Kiro](#completions-autocomplete-cli-docs-kiro)
  - [Enterprise billing - CLI - Docs - Kiro](#enterprise-billing-cli-docs-kiro)
  - [Built-in tools - CLI - Docs - Kiro](#built-in-tools-cli-docs-kiro)
  - [Chat - CLI - Docs - Kiro](#chat-cli-docs-kiro)
  - [Checkpointing - CLI - Docs - Kiro](#checkpointing-cli-docs-kiro)
  - [Get started - CLI - Docs - Kiro](#get-started-cli-docs-kiro)
  - [CLI commands - CLI - Docs - Kiro](#cli-commands-cli-docs-kiro)
  - [Code Intelligence - CLI - Docs - Kiro](#code-intelligence-cli-docs-kiro)
  - [Compliance validation for Kiro - CLI - Docs - Kiro](#compliance-validation-for-kiro-cli-docs-kiro)
  - [Concepts - CLI - Docs - Kiro](#concepts-cli-docs-kiro)
  - [Configuration - CLI - Docs - Kiro](#configuration-cli-docs-kiro)
  - [Agent configuration reference - CLI - Docs - Kiro](#agent-configuration-reference-cli-docs-kiro)
  - [Contacting billing support - CLI - Docs - Kiro](#contacting-billing-support-cli-docs-kiro)
  - [Context management - CLI - Docs - Kiro](#context-management-cli-docs-kiro)
  - [Creating custom agents - CLI - Docs - Kiro](#creating-custom-agents-cli-docs-kiro)
  - [Custom agents - CLI - Docs - Kiro](#custom-agents-cli-docs-kiro)
  - [Viewing Kiro usage on the dashboard - CLI - Docs - Kiro](#viewing-kiro-usage-on-the-dashboard-cli-docs-kiro)
  - [Data protection - CLI - Docs - Kiro](#data-protection-cli-docs-kiro)
  - [Delegate - CLI - Docs - Kiro](#delegate-cli-docs-kiro)
  - [Custom Diff Tools - CLI - Docs - Kiro](#custom-diff-tools-cli-docs-kiro)
  - [Examples - CLI - Docs - Kiro](#examples-cli-docs-kiro)
  - [Exit codes - CLI - Docs - Kiro](#exit-codes-cli-docs-kiro)
  - [Experimental features - CLI - Docs - Kiro](#experimental-features-cli-docs-kiro)
  - [Configuring a firewall, proxy server, or data perimeter for Kiro - CLI - Docs - Kiro](#configuring-a-firewall-proxy-server-or-data-perimeter-for-kiro-cli-docs-kiro)
  - [Onboarding quickstart - CLI - Docs - Kiro](#onboarding-quickstart-cli-docs-kiro)
  - [Working with Git - CLI - Docs - Kiro](#working-with-git-cli-docs-kiro)
  - [Governance - CLI - Docs - Kiro](#governance-cli-docs-kiro)
  - [Help Agent - CLI - Docs - Kiro](#help-agent-cli-docs-kiro)
  - [Hooks - CLI - Docs - Kiro](#hooks-cli-docs-kiro)
  - [How Kiro works with identity and access management (IAM) - CLI - Docs - Kiro](#how-kiro-works-with-identity-and-access-management-iam-cli-docs-kiro)
  - [Working with images - CLI - Docs - Kiro](#working-with-images-cli-docs-kiro)
  - [Infrastructure security in Kiro - CLI - Docs - Kiro](#infrastructure-security-in-kiro-cli-docs-kiro)
  - [Installation - CLI - Docs - Kiro](#installation-cli-docs-kiro)
  - [Knowledge management - CLI - Docs - Kiro](#knowledge-management-cli-docs-kiro)
  - [Manage prompts - CLI - Docs - Kiro](#manage-prompts-cli-docs-kiro)
  - [Managing your taxes - CLI - Docs - Kiro](#managing-your-taxes-cli-docs-kiro)
  - [Model Context Protocol (MCP) - CLI - Docs - Kiro](#model-context-protocol-mcp-cli-docs-kiro)
  - [Upgrading from Amazon Q Developer CLI - CLI - Docs - Kiro](#upgrading-from-amazon-q-developer-cli-cli-docs-kiro)
  - [Model selection - CLI - Docs - Kiro](#model-selection-cli-docs-kiro)
  - [Monitoring and tracking - CLI - Docs - Kiro](#monitoring-and-tracking-cli-docs-kiro)
  - [Managing tool permissions - CLI - Docs - Kiro](#managing-tool-permissions-cli-docs-kiro)
  - [Plan agent - CLI - Docs - Kiro](#plan-agent-cli-docs-kiro)
  - [Privacy and security - CLI - Docs - Kiro](#privacy-and-security-cli-docs-kiro)
  - [Logging user prompts - CLI - Docs - Kiro](#logging-user-prompts-cli-docs-kiro)
  - [MCP Registry - CLI - Docs - Kiro](#mcp-registry-cli-docs-kiro)
  - [Related questions - CLI - Docs - Kiro](#related-questions-cli-docs-kiro)
  - [Responding to messages - CLI - Docs - Kiro](#responding-to-messages-cli-docs-kiro)
  - [Security - CLI - Docs - Kiro](#security-cli-docs-kiro)
  - [Session Management - CLI - Docs - Kiro](#session-management-cli-docs-kiro)
  - [Settings - CLI - Docs - Kiro](#settings-cli-docs-kiro)
  - [Slash commands - CLI - Docs - Kiro](#slash-commands-cli-docs-kiro)
  - [Steering - CLI - Docs - Kiro](#steering-cli-docs-kiro)
  - [Subagents - CLI - Docs - Kiro](#subagents-cli-docs-kiro)
  - [Subscribing your team to Kiro - CLI - Docs - Kiro](#subscribing-your-team-to-kiro-cli-docs-kiro)
  - [Managing Kiro subscriptions - CLI - Docs - Kiro](#managing-kiro-subscriptions-cli-docs-kiro)
  - [Managing Your Kiro Subscription - CLI - Docs - Kiro](#managing-your-kiro-subscription-cli-docs-kiro)
  - [Supported regions - CLI - Docs - Kiro](#supported-regions-cli-docs-kiro)
  - [Tangent mode - CLI - Docs - Kiro](#tangent-mode-cli-docs-kiro)
  - [Thinking tool - CLI - Docs - Kiro](#thinking-tool-cli-docs-kiro)
  - [TODO lists - CLI - Docs - Kiro](#todo-lists-cli-docs-kiro)
  - [Troubleshooting custom agents - CLI - Docs - Kiro](#troubleshooting-custom-agents-cli-docs-kiro)
  - [Viewing per-user activity - CLI - Docs - Kiro](#viewing-per-user-activity-cli-docs-kiro)
  - [Kiro and interface endpoints (AWS PrivateLink) - CLI - Docs - Kiro](#kiro-and-interface-endpoints-aws-privatelink-cli-docs-kiro)
- [Autonomous Agent](#autonomous-agent)
  - [Kiro autonomous agent - Autonomous Agent - Docs - Kiro](#kiro-autonomous-agent-autonomous-agent-docs-kiro)
  - [Chatting with the agent - Autonomous Agent - Docs - Kiro](#chatting-with-the-agent-autonomous-agent-docs-kiro)
  - [Creating tasks - Autonomous Agent - Docs - Kiro](#creating-tasks-autonomous-agent-docs-kiro)
  - [Data protection - Autonomous Agent - Docs - Kiro](#data-protection-autonomous-agent-docs-kiro)
  - [Environment Configuration - Autonomous Agent - Docs - Kiro](#environment-configuration-autonomous-agent-docs-kiro)
  - [Environment Variables - Autonomous Agent - Docs - Kiro](#environment-variables-autonomous-agent-docs-kiro)
  - [GitHub - Autonomous Agent - Docs - Kiro](#github-autonomous-agent-docs-kiro)
  - [Internet Access - Autonomous Agent - Docs - Kiro](#internet-access-autonomous-agent-docs-kiro)
  - [MCP - Autonomous Agent - Docs - Kiro](#mcp-autonomous-agent-docs-kiro)
  - [Agent Sandbox - Autonomous Agent - Docs - Kiro](#agent-sandbox-autonomous-agent-docs-kiro)
  - [Setup - Autonomous Agent - Docs - Kiro](#setup-autonomous-agent-docs-kiro)
  - [Using the agent - Autonomous Agent - Docs - Kiro](#using-the-agent-autonomous-agent-docs-kiro)
- [Subagents](#subagents)
- [Context Providers](#context-providers)
- [General Reference](#general-reference)
  - [Overview - Agent Skills](#overview-agent-skills)
  - [Integrate skills into your agent - Agent Skills](#integrate-skills-into-your-agent-agent-skills)
  - [Specification - Agent Skills](#specification-agent-skills)
  - [What are skills? - Agent Skills](#what-are-skills-agent-skills)
  - [Automate your development workflow with Kiro’s AI agent hooks](#automate-your-development-workflow-with-kiros-ai-agent-hooks)
  - [Blog](#blog)
  - [Announcing the Code with Kiro Hackathon](#announcing-the-code-with-kiro-hackathon)
  - [Kiro 0.9: Custom subagents in the IDE, new enterprise controls, and granular code review](#kiro-09-custom-subagents-in-the-ide-new-enterprise-controls-and-granular-code-review)
  - [Empowering Kiro with IDE diagnostics](#empowering-kiro-with-ide-diagnostics)
  - [Use Kiro for free until September 15](#use-kiro-for-free-until-september-15)
  - [From chat to specs: a deep dive into AI-assisted development with Kiro](#from-chat-to-specs-a-deep-dive-into-ai-assisted-development-with-kiro)
  - [Kiro is generally available: Build with your team in the IDE and terminal](#kiro-is-generally-available-build-with-your-team-in-the-ide-and-terminal)
  - [How I stopped worrying about ReadMe files](#how-i-stopped-worrying-about-readme-files)
  - [How Kiro helped me code a game](#how-kiro-helped-me-code-a-game)
  - [Important Kiro pricing updates](#important-kiro-pricing-updates)
  - [Never lose your way: Introducing checkpointing in Kiro](#never-lose-your-way-introducing-checkpointing-in-kiro)
  - [Introducing Kiro](#introducing-kiro)
  - [Introducing Kiro autonomous agent](#introducing-kiro-autonomous-agent)
  - [Bring Kiro agents to your terminal with Kiro CLI](#bring-kiro-agents-to-your-terminal-with-kiro-cli)
  - [Introducing Opus 4.5 in Kiro](#introducing-opus-45-in-kiro)
  - [Introducing Kiro powers](#introducing-kiro-powers)
  - [Introducing remote MCP servers](#introducing-remote-mcp-servers)
  - [Specialized IDEs deserve AI too: Kiro adopts ACP](#specialized-ides-deserve-ai-too-kiro-adopts-acp)
  - [Kiro and the future of AI spec-driven software development](#kiro-and-the-future-of-ai-spec-driven-software-development)
  - [This is Kiroween](#this-is-kiroween)
  - [Making your Kiro credits go further](#making-your-kiro-credits-go-further)
  - [Multi-root Workspaces in Kiro: Work Across Projects, Not Just Inside One](#multi-root-workspaces-in-kiro-work-across-projects-not-just-inside-one)
  - [Multimodal development with Kiro: from design to done](#multimodal-development-with-kiro-from-design-to-done)
  - [Announcing new pricing plans and Auto, our new agent](#announcing-new-pricing-plans-and-auto-our-new-agent)
  - [Introducing the Kiro startup credits program](#introducing-the-kiro-startup-credits-program)
  - [Opus 4.6 is now available in Kiro](#opus-46-is-now-available-in-kiro)
  - [Kiro pricing plans are now live](#kiro-pricing-plans-are-now-live)
  - [Kiro pricing update + waitlist invites coming soon](#kiro-pricing-update-waitlist-invites-coming-soon)
  - [Does your code match your spec?](#does-your-code-match-your-spec)
  - [Property-Based Testing Caught a Security Bug I Never Would Have Found](#property-based-testing-caught-a-security-bug-i-never-would-have-found)
  - [Refactoring made right: how program analysis makes AI agents safe and reliable](#refactoring-made-right-how-program-analysis-makes-ai-agents-safe-and-reliable)
  - [Run all tasks: the feature we refused to ship (until now)](#run-all-tasks-the-feature-we-refused-to-ship-until-now)
  - [Stop repeating yourself: why global steering is the AI context layer you’ve been missing](#stop-repeating-yourself-why-global-steering-is-the-ai-context-layer-youve-been-missing)
  - [Teaching Kiro new tricks with agent steering and MCP](#teaching-kiro-new-tricks-with-agent-steering-and-mcp)
  - [This is fine... (really)](#this-is-fine-really)
  - [Understanding Kiro's pricing: specs, vibes, and usage tracking](#understanding-kiros-pricing-specs-vibes-and-usage-tracking)
  - [Unlock your development productivity with Kiro and Model Context Protocol (MCP)](#unlock-your-development-productivity-with-kiro-and-model-context-protocol-mcp)
  - [The wait(list) is over, get started with Kiro today](#the-waitlist-is-over-get-started-with-kiro-today)
  - [Changelog](#changelog)
  - [Claude Opus 4.5 support - Models](#claude-opus-45-support-models)
  - [Autopilot - IDE - Docs - Kiro](#autopilot-ide-docs-kiro)
  - [Chat - IDE - Docs - Kiro](#chat-ide-docs-kiro)
  - [Checkpoints - IDE - Docs - Kiro](#checkpoints-ide-docs-kiro)
  - [Dev servers - IDE - Docs - Kiro](#dev-servers-ide-docs-kiro)
  - [Diagnostics tool - IDE - Docs - Kiro](#diagnostics-tool-ide-docs-kiro)
  - [Model selection - IDE - Docs - Kiro](#model-selection-ide-docs-kiro)
  - [Agent Notifications - IDE - Docs - Kiro](#agent-notifications-ide-docs-kiro)
  - [Slash commands - IDE - Docs - Kiro](#slash-commands-ide-docs-kiro)
  - [Subagents - IDE - Docs - Kiro](#subagents-ide-docs-kiro)
  - [Summarization - IDE - Docs - Kiro](#summarization-ide-docs-kiro)
  - [Terminal integration - IDE - Docs - Kiro](#terminal-integration-ide-docs-kiro)
  - [Vibe vs Spec sessions - IDE - Docs - Kiro](#vibe-vs-spec-sessions-ide-docs-kiro)
  - [Web tools - IDE - Docs - Kiro](#web-tools-ide-docs-kiro)
  - [Codebase indexing - IDE - Docs - Kiro](#codebase-indexing-ide-docs-kiro)
  - [Custom extension registry - IDE - Docs - Kiro](#custom-extension-registry-ide-docs-kiro)
  - [Kiro Interface - IDE - Docs - Kiro](#kiro-interface-ide-docs-kiro)
  - [Keyboard Shortcuts - IDE - Docs - Kiro](#keyboard-shortcuts-ide-docs-kiro)
  - [Kiroignore - IDE - Docs - Kiro](#kiroignore-ide-docs-kiro)
  - [Multi-root Workspaces - IDE - Docs - Kiro](#multi-root-workspaces-ide-docs-kiro)
  - [Source Control - IDE - Docs - Kiro](#source-control-ide-docs-kiro)
  - [Enterprise billing - IDE - Docs - Kiro](#enterprise-billing-ide-docs-kiro)
  - [Concepts - IDE - Docs - Kiro](#concepts-ide-docs-kiro)
  - [Viewing Kiro usage on the dashboard - IDE - Docs - Kiro](#viewing-kiro-usage-on-the-dashboard-ide-docs-kiro)
  - [Onboarding quickstart - IDE - Docs - Kiro](#onboarding-quickstart-ide-docs-kiro)
  - [How Kiro works with identity and access management (IAM) - IDE - Docs - Kiro](#how-kiro-works-with-identity-and-access-management-iam-ide-docs-kiro)
  - [Monitoring and tracking - IDE - Docs - Kiro](#monitoring-and-tracking-ide-docs-kiro)
  - [Logging user prompts - IDE - Docs - Kiro](#logging-user-prompts-ide-docs-kiro)
  - [Settings - IDE - Docs - Kiro](#settings-ide-docs-kiro)
  - [Subscribing your team to Kiro - IDE - Docs - Kiro](#subscribing-your-team-to-kiro-ide-docs-kiro)
  - [Managing Kiro subscriptions - IDE - Docs - Kiro](#managing-kiro-subscriptions-ide-docs-kiro)
  - [Supported regions - IDE - Docs - Kiro](#supported-regions-ide-docs-kiro)
  - [Viewing per-user activity - IDE - Docs - Kiro](#viewing-per-user-activity-ide-docs-kiro)
  - [Authentication methods - IDE - Docs - Kiro](#authentication-methods-ide-docs-kiro)
  - [Your first project - IDE - Docs - Kiro](#your-first-project-ide-docs-kiro)
  - [Installation - IDE - Docs - Kiro](#installation-ide-docs-kiro)
  - [Setting up for development on spirit of Kiro - IDE - Docs - Kiro](#setting-up-for-development-on-spirit-of-kiro-ide-docs-kiro)
  - [Steering Kiro, and improving the game homepage - IDE - Docs - Kiro](#steering-kiro-and-improving-the-game-homepage-ide-docs-kiro)
  - [Investigating and fixing a subtle bug with physics - IDE - Docs - Kiro](#investigating-and-fixing-a-subtle-bug-with-physics-ide-docs-kiro)
  - [Fixing a complex issue across multiple files - IDE - Docs - Kiro](#fixing-a-complex-issue-across-multiple-files-ide-docs-kiro)
  - [Vibe refactoring is 50% of vibe coding - IDE - Docs - Kiro](#vibe-refactoring-is-50-of-vibe-coding-ide-docs-kiro)
  - [Using specifications for complex work - IDE - Docs - Kiro](#using-specifications-for-complex-work-ide-docs-kiro)
  - [Managing assets with hooks - IDE - Docs - Kiro](#managing-assets-with-hooks-ide-docs-kiro)
  - [Extending Kiro with MCP - IDE - Docs - Kiro](#extending-kiro-with-mcp-ide-docs-kiro)
  - [Conclusion - IDE - Docs - Kiro](#conclusion-ide-docs-kiro)
  - [Guides - IDE - Docs - Kiro](#guides-ide-docs-kiro)
  - [Java - IDE - Docs - Kiro](#java-ide-docs-kiro)
  - [Language support - IDE - Docs - Kiro](#language-support-ide-docs-kiro)
  - [Learn by playing - IDE - Docs - Kiro](#learn-by-playing-ide-docs-kiro)
  - [Migrating from VSCode - IDE - Docs - Kiro](#migrating-from-vscode-ide-docs-kiro)
  - [Python - IDE - Docs - Kiro](#python-ide-docs-kiro)
  - [TypeScript and JavaScript - IDE - Docs - Kiro](#typescript-and-javascript-ide-docs-kiro)
  - [Code references - IDE - Docs - Kiro](#code-references-ide-docs-kiro)
  - [Compliance validation for Kiro - IDE - Docs - Kiro](#compliance-validation-for-kiro-ide-docs-kiro)
  - [Data protection - IDE - Docs - Kiro](#data-protection-ide-docs-kiro)
  - [Configuring a firewall, proxy server, or data perimeter for Kiro - IDE - Docs - Kiro](#configuring-a-firewall-proxy-server-or-data-perimeter-for-kiro-ide-docs-kiro)
  - [Infrastructure security in Kiro - IDE - Docs - Kiro](#infrastructure-security-in-kiro-ide-docs-kiro)
  - [Privacy and security - IDE - Docs - Kiro](#privacy-and-security-ide-docs-kiro)
  - [Kiro and interface endpoints (AWS PrivateLink) - IDE - Docs - Kiro](#kiro-and-interface-endpoints-aws-privatelink-ide-docs-kiro)
  - [About Kiro](#about-kiro)
  - [Autonomous agent](#autonomous-agent)
  - [Billing for individuals - IDE - Docs - Kiro](#billing-for-individuals-ide-docs-kiro)
  - [Cancelling your subscription - IDE - Docs - Kiro](#cancelling-your-subscription-ide-docs-kiro)
  - [CLI](#cli)
  - [Contacting billing support - IDE - Docs - Kiro](#contacting-billing-support-ide-docs-kiro)
  - [Deleting your account - IDE - Docs - Kiro](#deleting-your-account-ide-docs-kiro)
  - [Get started - IDE - Docs - Kiro](#get-started-ide-docs-kiro)
  - [Downgrading your subscription - IDE - Docs - Kiro](#downgrading-your-subscription-ide-docs-kiro)
  - [Downloads](#downloads)
  - [Kiro for Enterprise](#kiro-for-enterprise)
  - [Frequently Asked Questions](#frequently-asked-questions)
  - [Kiro: Agentic AI development from prototype to production](#kiro-agentic-ai-development-from-prototype-to-production)
  - [License](#license)
  - [Managing your payments - IDE - Docs - Kiro](#managing-your-payments-ide-docs-kiro)
  - [Managing your taxes - IDE - Docs - Kiro](#managing-your-taxes-ide-docs-kiro)
  - [Enabling overages - IDE - Docs - Kiro](#enabling-overages-ide-docs-kiro)
  - [Powers](#powers)
  - [Pricing](#pricing)
  - [Managing proactive usage notifications - IDE - Docs - Kiro](#managing-proactive-usage-notifications-ide-docs-kiro)
  - [Related questions - IDE - Docs - Kiro](#related-questions-ide-docs-kiro)
  - [Kiro for Startups](#kiro-for-startups)
  - [Submit a power](#submit-a-power)
  - [Startup Program Terms & Conditions 2025](#startup-program-terms-conditions-2025)
  - [Troubleshooting - IDE - Docs - Kiro](#troubleshooting-ide-docs-kiro)
  - [Upgrading your subscription - IDE - Docs - Kiro](#upgrading-your-subscription-ide-docs-kiro)
- [Decision Matrix](#decision-matrix)
- [Quick Reference](#quick-reference)

## Specs

<!-- toolType: spec -->

### Best practices - IDE - Docs - Kiro

<!-- toolType: spec -->

# Best practices

---

## How do I import existing requirements?

If your requirements or designs already exist in another system (such as JIRA, Confluence, or Word documents), you have two options:

1. Using MCP integration: If your requirements tool has an MCP server, you can connect directly to import requirements into your spec session. Kiro supports both local and remote MCP servers.
2. Manual import: Simply copy your existing requirements (e.g. foo-prfaq.md) into a new file in your repo and open a spec chat session and say #foo-prfaq.md Generate a spec from it. Kiro will read your requirements, and generate requirement and design specs.

## How do I iterate on my specs?

Kiro's specifications are designed for continuous refinement, allowing you to update and enhance them as your project evolves. This iterative approach ensures that specifications remain synchronized with changing requirements and technical designs, providing a reliable foundation for development.

1. Update Requirements: Either modify the requirements.md file directly or initiate a spec session and instruct Kiro to add new requirements or design elements.
2. Update Design: Navigate to the design.md file for your spec and select Refine. This action will update both the design documentation and the associated task list to reflect your modified requirements.
3. Update tasks: Navigate to the tasks.md file and choose Update tasks. This will create new tasks that map to the new requirements.

## How do I share specs with my team?

Specs are designed to be version-controlled, making them easily shareable across your team. Store specs directly in your project repository alongside the code they describe. This keeps all project artifacts together and maintains the connection between requirements and implementation.

## Can I share specs across multiple teams?

Yes, you can share specs across multiple teams by leveraging Git submodules or package references. Here are some best practices for managing shared specs across teams:

1. Create a central specs repository - Establish a dedicated repository for shared specifications that multiple projects can reference.
2. Use Git submodules or package references - Link your central specs to individual projects using Git submodules, package references, or symbolic links depending on your development environment.
3. Implement cross-repository workflows - Develop processes for proposing, reviewing, and updating shared specs that affect multiple projects.

If you have specific needs for cross-project spec management, please share your requirements on our [GitHub issue tracker](https://github.com/kirodotdev) so we can prioritize features that support your workflow.

## Can I start a spec session from a vibe session?

Yes. You can have a vibe conversation and then say `Generate spec`. Kiro will then ask you if you want to start a spec session. If you say yes, it will proceed with generating requirements based on the context of your vibe session.

## Can I execute all the tasks in my spec in a single shot?

Yes, you can execute all the tasks in your `tasks.md` file by clicking the "Run all tasks" button. Note: this will only run incomplete tasks that are marked as required.

## What if some tasks are already implemented?

When working on an existing codebase, you might find that some tasks in your spec are already complete because a coworker or you ended up doing it in another session. Here are two ways to handle this:

**Option 1: Click on Update tasks in your tasks.md**

- Open your tasks.md file
- Click Update tasks
- Kiro will automatically mark completed tasks.

**Option 2: Let Kiro scan for you in a spec chat session**

- In a spec session, ask Kiro: "Check which tasks are already complete"
- Kiro will analyze your codebase and identify implemented functionality
- Kiro will automatically mark completed tasks

This keeps your task spec accurate.

## How do I reference a spec in chat?

You can reference any spec from your specs list in chat conversations using the `#spec` context provider. Type `#spec` and press Enter to see a list of available specs, then select the one you want to include. Kiro automatically includes all spec files (requirements.md, design.md, and tasks.md) in the conversation context to ensure responses align with your documented specifications.

## When should I use #spec in chat?

Using `#spec` is particularly helpful when you need context-aware assistance:

- Implementing tasks - Generate code that aligns with your design decisions and meets acceptance criteria
- Refining specs - Request changes to requirements, design, or tasks based on new insights
- Validating work - Check if your implementation matches the spec's requirements
- Asking questions - Get answers about your feature's architecture or design

**Examples:**

```
#spec:user-authentication implement task 2.3
#spec:user-authentication update the design file to include password reset flow
#spec:user-authentication does my current implementation meet the acceptance criteria for task 7.1?
#spec:user-authentication why did we choose JWT over session-based authentication?

```

## How many specs can I have in a single repo?

You can have as many specs as you want in a single repo. We recommend creating multiple specs for different features for your project rather than attempting to just have a single one for your entire codebase.

For example, in an e-commerce application, you might organize your specs like this:

```
.kiro/specs/
├── user-authentication/       # Login, signup, password reset
├── product-catalog/           # Product listing, search, filtering
├── shopping-cart/             # Add to cart, quantity updates, checkout
├── payment-processing/        # Payment gateway integration, order confirmation
└── admin-dashboard/           # Product management, user analytics

```

This approach allows you to:

- Work on features independently without conflicts
- Maintain focused, manageable spec documents
- Iterate on specific functionality without affecting other areas
- Collaborate with team members on different features simultaneously

### Concepts - IDE - Docs - Kiro

<!-- toolType: spec -->

# Concepts

---

Specs bridge the gap between conceptual product requirements and technical implementation details, ensuring alignment and reducing development iterations. Kiro generates three key files that form the foundation of each specification:

- requirements.md - Captures user stories and acceptance criteria in structured EARS notation
- design.md - Documents technical architecture, sequence diagrams, and implementation considerations
- tasks.md - Provides a detailed implementation plan with discrete, trackable tasks

## Workflow

The workflow follows a logical progression with decision points between phases, ensuring each step is properly completed before moving to the next.

- Requirements Phase (leftmost section): Define user stories and acceptance criteria in structured EARS notation
- Design Phase (second section): Document the technical architecture, sequence diagrams, and implementation considerations
- Implementation Planning (third section): Break down the work into discrete, trackable tasks with clear descriptions and outcomes
- Execution Phase (rightmost section): Track progress as tasks are completed, with the ability to update and refine the spec as needed

## Requirements

The `requirements.md` file is written in the form of user stories with acceptance criteria in EARS notation. The way you wish your PM would give you requirements!

EARS (Easy Approach to Requirements Syntax) notation provides a structured format for writing clear, testable requirements. In a spec's requirements.md file, each requirement follows this pattern:

```
WHEN [condition/event]
THE SYSTEM SHALL [expected behavior]

```

For example:

```
WHEN a user submits a form with invalid data
THE SYSTEM SHALL display validation errors next to the relevant fields

```

This structured approach offers several benefits:

- Clarity: Requirements are unambiguous and easy to understand
- Testability: Each requirement can be directly translated into test cases
- Traceability: Individual requirements can be tracked through implementation
- Completeness: The format encourages thinking through all conditions and behaviors

Kiro helps you transform vague feature requests into these well-structured requirements, making the development process more efficient and reducing misunderstandings between product and engineering teams.

## Design

Loading image...

The `design.md` file is where you document technical architecture, sequence diagrams, and implementation considerations. It's a great place to capture the big picture of how the system will work, including the components and their interactions.

Kiro's specs offer a structured approach to design documentation, making it easier to understand and collaborate on complex systems. The design.md file is a great place to capture the big picture of how the system will work, including the components and their interactions.

## Implementation plan

The `tasks.md` file is where you provide a detailed implementation plan with discrete, trackable tasks and sub-tasks. Each task is clearly defined, with a clear description, expected outcome, and any necessary resources or dependencies. Kiro's specs offer a structured approach to implementation plans, making it easier to understand and collaborate on complex systems.

Kiro provides a task execution interface for `tasks.md` files that displays real-time status updates. Tasks are updated as in-progress or completed, allowing you to efficiently track implementation progress and maintain an up-to-date view of your development status.

Loading image...

### Correctness with Property-based tests - IDE - Docs - Kiro

<!-- toolType: spec -->

# Correctness with Property-based tests

---

"Spec correctness" helps answer a fundamental question: does your implementation actually do what you specified? When AI generates code, how do you know it matches your intent?

## Concepts

Property-Based Testing is a step towards a fundamental shift in how we think about correctness with AI, moving from checking individual examples to validating universal properties across entire input spaces. Traditional unit tests only check specific examples, and whoever writes them—human or AI—is limited by their own biases. By automatically translating natural language specifications into executable properties and generating comprehensive test cases, Kiro creates a powerful feedback loop that helps both AI agents and human developers build more reliable software. This approach not only finds bugs that traditional testing misses, but also maintains a clear, traceable link between your requirements and the tests that validate them.

While PBT cannot guarantee the absence of all bugs, it provides significantly stronger evidence of correctness than example-based testing alone, making it an essential tool for specification-driven development.

### What is a property?

A property is a universal statement about how your system should behave. Properties express the invariants and contracts that should always be true in your system, regardless of the specific data involved.

> For any set of inputs where certain preconditions hold, some expected behavior is true.

In the Kiro specification world, this maps really well to our EARS requirements:

> "For any authenticated user and any active listing, the user can view that listing." This captures a general rule about system behavior that must hold across all valid scenarios.

### How property-based testing works

Consider a car sales app:

- Traditional test: User adds Car #5 to favorites, Car #5 appears in their list
- Property-based test: For any user and any car, WHEN the user adds the car to favorites, THE System SHALL display it in their list

PBT automatically tests this with User A adding Car #1, User B adding Car #500, users with special characters in names, cars with various statuses, and hundreds more combinations—catching edge cases and verifying implementation matches intent.

Throughout this process, PBT probes to find counter-examples through "shrinking"—almost like a red team trying to break your code. When it finds violations, Kiro can automatically update your implementation or surface options to fix the spec, implementation, or test itself.

While not formal verification, PBT provides evidence for correctness across scenarios you'd never write manually—showing whether your implementation actually behaves according to what you defined.

## Property-based testing w. Specs

Kiro integrates property-based testing throughout the spec workflow, from requirements to implementation validation.

### Workflow

Kiro extracts properties from your EARS-formatted requirements (e.g. "THE System SHALL allow authenticated users to view active car listings"), determines which can be logically tested, then generates hundreds or thousands of random test cases when you choose to run them.

### Design phase

In the design phase, Kiro extracts properties from your requirements and generates test cases. This is the first step in the workflow, where Kiro analyzes your requirements and identifies the properties that can be tested.

Loading image...

Hovering over a property reveals its connection to the original requirement and linked task.

Loading image...

### Executing tasks

In the execution phase, Kiro runs the generated PBT cases against your implementation. Note: PBTs are optional by default so you can focus on your core implementation first. Once a property test runs you can see the reference to the generated code.

Loading image...

When a property test fails, Kiro identifies the specific failure scenario and surfaces it for review.

Loading image...

You can then chat with Kiro to understand the failure and determine the appropriate fix—whether that's updating the implementation, adjusting the test, or refining the requirement itself.

Loading image...

### Specs - IDE - Docs - Kiro

<!-- toolType: spec -->

# Specs

---

## What are specs?

Specs or specifications are structured artifacts that formalize the development process for complex features in your application. They provide a systematic approach to transform high-level ideas into detailed implementation plans with clear tracking and accountability.

With Kiro's specs, you can:

- Break down requirements into user stories with acceptance criteria
- Build design docs with sequence diagrams and architecture plans
- Track implementation progress across discrete tasks
- Collaborate effectively between product and engineering teams

## Quickstart

Ready to create your first specification? Here's how to get started:

1. From the Kiro pane, click the + button under Specs. Alternatively, choose Spec from the chat pane.
2. Describe your project idea.
3. Follow the three phase workflow through Requirements → Design → Implementation.

## Learn more

Dive deeper into Kiro's specification system with these guides:

## Hooks

<!-- toolType: hook -->

### Hook actions - IDE - Docs - Kiro

<!-- toolType: hook -->

# Hook actions

---

Agent Hooks support both an "agent prompt" ("Ask Kiro") and a "shell command" action. Once you have selected the specific event that [triggers](/docs/hooks/types) a hook, you can decide what action will be taken by Kiro when that hook is triggered.

## Agent Prompt action

With this action, you can define a prompt that is sent to the agent each time the hook is triggered. The agent will respond and act on this prompt just like it does with a prompt provided in the chat panel.

In the case of the [PromptSubmit](/docs/hooks/types/#prompt-submit) trigger, this action is called "Add to prompt". The prompt specified in the hook is *appended* to the user prompt, and the combined prompt is sent to the agent.

## Shell Command action

With this action, you can define a shell command that is executed each time the hook is triggered.

If the command returns an exit code of "0" indicating success, the *stdout* output of the command is added to the agent's context.

If the command returns any other exit code, the *stderr* output of the command is sent to the agent, and the agent is notified that the hook returned an error. Additionally, in the case of the **Pre Tool Use** hook, the tool invocation is blocked, and for the **Prompt Submit** hook, the user prompt submission is blocked.

An execution timeout can be specified. The default timeout is 60 seconds. Set to 0 to disable the timeout.

This action is not currently available for the file and manual triggers.

## Selecting an action type

You should use the Agent Prompt action when, in response to a trigger event, you want to use natural language to instruct the agent to perform some action based on context.

You should use the Shell Command action when you want to run a specific command(s) or perform a deterministic set of actions that do not depend on the agent's current context.

Note that Agent Prompt actions consume credits as these actions trigger a new agent loop, whereas Shell Command actions do not. Shell Command actions are also generally faster than Agent Prompt actions as they are executed locally on your PC, and do not use an LLM.

### Best practices - IDE - Docs - Kiro

<!-- toolType: hook -->

# Best practices

---

Following these best practices will help you create reliable, efficient, and maintainable hooks that enhance your development workflow.

## Hook design

### Be specific and clear

- When using an agent prompt action, write detailed, unambiguous instructions for the agent
- Focus on one specific task per hook
- Use numbered steps for complex operations

### Test thoroughly

- Test hooks with some sample scenarios before deploying
- Verify hooks work with edge cases
- For file-related hooks, start with limited file patterns before expanding

### Monitor performance

- Ensure hooks don't slow down your workflow
- Consider the frequency of trigger events
- Optimize prompts for efficiency

## Security considerations

### Validate inputs

- Ensure hooks handle unexpected content gracefully
- Consider potential edge cases
- Test with malformed or unexpected input

### Limit scope

- For file-related hooks, target specific file types or directories when possible
- Use precise file patterns to avoid unnecessary executions
- Consider the impact of hooks on your entire codebase

### Review regularly

- Update hook logic as your project evolves
- Remove hooks that are no longer needed
- Refine prompts based on actual results

## Team collaboration

### Document hooks

- Maintain clear documentation of hook purposes
- Include examples of expected behavior
- Document any limitations or edge cases

### Share configurations

- Use consistent hooks across team members
- Store hook configurations in version control
- Create standard hooks for common team workflows

### Version control integration

- Consider hooks that integrate with your version control system
- Create hooks for code review workflows
- Use hooks to enforce team standards

### Hook examples - IDE - Docs - Kiro

<!-- toolType: hook -->

# Hook examples

---

These examples demonstrate real-world hook implementations that you can adapt for your own projects. Each example includes the trigger type, target patterns, and complete hook instructions.

## Security pre-commit scanner

This hook helps prevent security leaks by scanning files before they're committed.

**Trigger Type:** Agent Stop

**Agent Prompt:**

```
Review changed files for potential security issues:
1. Look for API keys, tokens, or credentials in source code
2. Check for private keys or sensitive credentials
3. Scan for encryption keys or certificates
4. Identify authentication tokens or session IDs
5. Flag passwords or secrets in configuration files
6. Detect IP addresses containing sensitive data
7. Find hardcoded internal URLs
8. Spot database connection credentials

For each issue found:
1. Highlight the specific security risk
2. Suggest a secure alternative approach
3. Recommend security best practices

```

## Centralized user prompt logging

This hook logs all user prompts to a centralized logging system for analysis and/or auditing.

**Trigger Type:** Prompt Submit

**Shell Command:**

```
# Log user prompt to Grafana Loki
curl -H "Content-Type: application/json" -XPOST \
     "http://loghost/loki/api/v1/push" --data-raw \
     "{'streams': [{
        'stream': { 'app': 'kiro', 'user': \"${USER}\"  },
        'values': [ [\"$(date +%s%N)\", \"${USER_PROMPT}\"] ]
      }]}"

```

## Internationalization helper

This hook ensures that when you update text in your primary language file, translations are kept in sync.

**Trigger Type:** File Save

**Target:** `src/locales/en/*.json`

**Agent Prompt:**

```
When an English locale file is updated:
1. Identify which string keys were added or modified
2. Check all other language files for these keys
3. For missing keys, add them with a "NEEDS_TRANSLATION" marker
4. For modified keys, mark them as "NEEDS_REVIEW"
5. Generate a summary of changes needed across all languages

```

## Test coverage maintainer

This hook ensures test coverage remains high as code evolves.

**Trigger Type:** File Save

**Target:** `src/**/*.{js,ts,jsx,tsx}`

**Agent Prompt:**

```
When a source file is modified:
1. Identify new or modified functions and methods
2. Check if corresponding tests exist and cover the changes
3. If coverage is missing, generate test cases for the new code
4. Run the tests to verify they pass
5. Update coverage reports

```

## Documentation generator

This hook can be triggered on demand to update documentation to match code changes.

**Trigger Type:** Manual Trigger

**Agent Prompt:**

```
Generate comprehensive documentation for the current file:
1. Extract function and class signatures
2. Document parameters and return types
3. Provide usage examples based on existing code
4. Update the README.md with any new exports
5. Ensure documentation follows project standards

```

## Integration with MCP

Agent Hooks can be enhanced with Model Context Protocol (MCP) capabilities to extend their functionality:

1. Access to External Tools: Hooks can leverage MCP servers to access specialized tools and APIs
2. Enhanced Context: MCP provides additional context for more intelligent hook actions
3. Domain-Specific Knowledge: Specialized MCP servers can provide domain expertise

To use MCP with hooks:

1. Configure MCP servers
2. Reference MCP tools in your hook instructions
3. Set appropriate auto-approval settings for frequently used tools

**Use Cases:**

- Make sure that your Figma design system is respected
- Update ticket status after a task is done
- Sync a database from sample files within the project folder

### Example: validate Figma design

This hook monitors HTML and CSS files and validates that they follow a Figma design using the Figma MCP.

**Trigger Type:** File Save Hook

**Target:** `*.css` `*.html`

**Agent Prompt:**

```
Use the Figma MCP to analyze the updated html or css files and check that they follow
established design patterns in the figma design. Verify elements like hero sections,
feature highlights, navigation elements, colors, and button placements align.

```

### Hooks - IDE - Docs - Kiro

<!-- toolType: hook -->

# Hooks

---

Agent hooks are powerful automation tools that streamline your development workflow by automatically executing predefined agent actions when specific events occur in your IDE. With hooks, you eliminate the need to manually request routine tasks and ensure consistency across your codebase.

## What are agent hooks?

Agent hooks are automated triggers that execute predefined agent prompts or shell commands when specific events occur in your IDE. Rather than manually asking for routine tasks to be performed, hooks set up automated responses to events such as:

- Saving files
- Creating new files
- Deleting files
- User prompt submission
- Agent turn completion

Agent hooks transform your development workflow through intelligent automation. By setting up hooks for common tasks, you can:

- Maintain consistent code quality
- Prevent security vulnerabilities
- Reduce manual overhead
- Standardize team processes
- Create faster development cycles

Whether you're working on a small project or managing a large codebase, agent hooks help ensure that routine tasks are handled automatically and consistently, allowing you to focus on building great software.

## How agent hooks work

The agent hook system follows a simple two-step process:

1. Event Detection: The system monitors for specific events in your IDE
2. Automated Action: When an event occurs, an action — either a predefined agent prompt or a shell command — is executed

This automation flow eliminates repetitive tasks and ensures consistency across your codebase.

## Setting up agent hooks

Creating and managing hooks is straightforward:

### Using the explorer view

1. Navigate to the Agent Hooks section in the Kiro panel
2. Click the + button to create a new hook
3. Define the hook workflow using natural language in the input field
4. Press Enter or click Submit to proceed
5. Configure the hook settings and save

### Using the command palette

You can also use the Command Palette to navigate to the Hook UI:

1. Open the command palette with Cmd + Shift + P (Mac) or Ctrl + Shift + P (Windows/Linux)
2. Type Kiro: Open Kiro Hook UI
3. Follow the on-screen instructions to create your hook

## Next steps

Now that you have created a hook file, you can further learn about hooks here:

- Hook Types - Learn about different trigger types and their use cases
- Hook Actions - Learn about different hook actions and their use cases
- Management - Learn how to organize, edit, and maintain your hooks
- Best Practices - Follow patterns for effective hook design
- Examples - See examples and templates you can use

### Hook management - IDE - Docs - Kiro

<!-- toolType: hook -->

# Hook management

---

Effective hook management ensures your automation workflows remain organized, maintainable, and efficient as your project grows.

## Managing your hooks

Access all your hooks through the Agent Hooks section in the Kiro panel.

### Enable/disable hooks

Toggle hooks on/off without deleting them:

- Quick toggle: Click the eye icon next to any hook in the Agent Hooks panel
- From hook view: Select a hook and use the Hook Enabled switch in the top-right corner

### Edit existing hooks

Hooks evolve with your workflow. Update them anytime by selecting your hook in the Agent Hooks panel and modifying settings like triggers, file patterns, instructions, or descriptions. Updates apply immediately.

### Delete hooks

Select the hook in the Agent Hooks panel, click `Delete Hook` located at the bottom view, then click `delete`. This action cannot be undone.

### Run manual trigger hooks

You can execute a manual trigger hook using:

- Quick run: Click the play button (▷) next to the hook name in the Agent Hooks panel
- From hook view: Select the hook and click Start Hook in the top-right corner

### Troubleshooting Hooks - IDE - Docs - Kiro

<!-- toolType: hook -->

# Troubleshooting Hooks

---

### Common issues

**Hook Not Triggering**

- For file-related hooks, verify the file pattern matches your target files
- Check that the hook is enabled
- Ensure the event type is correct

**Unexpected Hook Behavior**

- Review the hook instructions for clarity
- Check for conflicting hooks
- Verify file patterns aren't too broad

**Performance Issues**

- For file-related hooks, limit hook scope with more specific file patterns
- For hooks with an agent prompt action, simplify any complex hook instructions
- For hooks with a shell command action, ensure that the command completes quickly
- Reduce the frequency of triggering events

For additional information, consult the [troubleshooting guide](/docs/troubleshooting)

### Hook types - IDE - Docs - Kiro

<!-- toolType: hook -->

# Hook types

---

Agent Hooks support various trigger types, each designed for specific automation scenarios. Understanding these types helps you choose the right approach for your workflow needs.

## Prompt Submit

Triggers when the user submits a prompt.

When using the shell command action, the user prompt can be accessed via the `USER_PROMPT` environment variable.

**Use Cases:**

- Provide additional context to the agent relevant to the prompt
- Block certain prompts based on their content
- Log all user prompts to a central location

## Agent Stop

Triggers when the agent has completed its turn, and finished responding to the user.

**Use Cases:**

- Compile code and report any failures to the agent
- Format or review any agent-generated code
- Review changes made by agent and provide additional instructions

## Pre Tool Use

Triggers when the agent is about to invoke a tool.

In the **Tool name** field, provide the names of the specific tools — built-in or MCP — for which this hook should execute. Wildcarding (e.g., "*") is supported. You can ask Kiro for the names of the available tools. The following special tool names are supported:

- read to refer to all built-in file read tools
- write to refer to all built-in file write tools
- shell to refer to all built-in shell command-related tools
- web to refer to all built-in web tools

**Use Cases:**

- Block certain tool invocations
- Provide additional instructions to the agent before it invokes a tool

## Post Tool Use

Triggers after the agent has invoked a tool.

For details on the **Tool name** field, refer to the [Pre Tool Use](#pre-tool-use) section above.

**Use Cases:**

- Log tool invocations for auditing purposes
- Format or review any updated files after a "write" tool call
- Provide additional instructions to the agent on top of the tool response

## File Create

Triggers when new files matching specific patterns are created in your workspace.

**Use Cases:**

- Generate boilerplate code for new components
- Add license headers to new files
- Set up test files when creating implementation files

## File Save

Trigger when files matching specific patterns are saved.

**Use Cases:**

- Run linting and formatting
- Update related files
- Generate documentation
- Run tests for changed files

## File Delete

Triggers when files matching specific patterns are deleted.

**Use Cases:**

- Clean up related files
- Update import references in other files
- Maintain project integrity

## Manual Trigger

Manually execute a hook.

**Use Cases:**

- On-demand code reviews
- Documentation generation
- Security scanning
- Performance optimization

## Steering Docs

<!-- toolType: steering-doc -->

### Steering - IDE - Docs - Kiro

<!-- toolType: steering-doc -->

# Steering

---

## What is steering?

Steering gives Kiro persistent knowledge about your workspace through markdown files. Instead of explaining your conventions in every chat, steering files ensure Kiro consistently follows your established patterns, libraries, and standards.

## Key benefits

**Consistent Code Generation** - Every component, API endpoint, or test follows your team's established patterns and conventions.

**Reduced Repetition** - No need to explain workspace standards in each conversation. Kiro remembers your preferences.

**Team Alignment** - All developers work with the same standards, whether they're new to the workspace or seasoned contributors.

**Scalable Project Knowledge** - Documentation that grows with your codebase, capturing decisions and patterns as your project evolves.

## Steering file scope

Steering files can be created with a workspace scope or a global scope.

### Workspace steering

Workspace steering files reside in your workspace root folder under `.kiro/steering/`, and apply only to that specific workspace. Workspace steering files can be used to inform Kiro of patterns, libraries, and standards that apply to an individual workspace.

### Global steering

Global steering files reside in your home directory under `~/.kiro/steering/`, and apply to all workspaces. Global steering files can be used to inform Kiro of conventions that apply to *all* your workspaces.

In case of conflicting instructions between global and workspace steering, Kiro will prioritize the workspace steering instructions. This allows you to specify global directives that generally apply to all your workspaces, while preserving the ability to override those directives for specific workspaces.

### Team steering

The global steering feature can be used to define centralized steering files that apply to entire teams. Team steering files can be pushed to user's PCs via MDM solutions or Group Policies, or downloaded by users to their PCs from a central repository, and placed into the `~/.kiro/steering` folder.

## Foundational steering files

Kiro provides foundational steering files to establish core project context. You can generate these files as follows:

1. Navigate to the Steering section in the Kiro panel
2. Click the Generate Steering Docs button, or click the + button and select the Foundation steering files option
3. Kiro will create three foundational files:

**Product Overview** (`product.md`) - Defines your product's purpose, target users, key features, and business objectives. This helps Kiro understand the "why" behind technical decisions and suggest solutions aligned with your product goals.

**Technology Stack** (`tech.md`) - Documents your chosen frameworks, libraries, development tools, and technical constraints. When Kiro suggests implementations, it will prefer your established stack over alternatives.

**Project Structure** (`structure.md`) - Outlines file organization, naming conventions, import patterns, and architectural decisions. This ensures generated code fits seamlessly into your existing codebase.

These foundation files are included in every interaction by default, forming the baseline of Kiro's project understanding.

## Creating custom steering files

1. Navigate to the Steering section in the Kiro panel
2. Click the + button
3. Select the scope of the steering file: workspace or global
4. Choose a descriptive filename (e.g., api-standards.md)
5. Write your guidance using standard markdown syntax
6. Use natural language to describe your requirements
7. Optionally, for workspace steering files, you can use the Refine button to have Kiro refine your requirements

Once created, steering files become immediately available across all Kiro interactions.

## Agents.md

Kiro supports providing steering directives via the [AGENTS.md](https://agents.md/) standard. AGENTS.md files are in markdown format, similar to Kiro steering files; however, AGENTS.md files do not support [inclusion modes](#inclusion-modes) and are always included.

You can add AGENTS.md files to the global steering file location (`~/.kiro/steering/`), or to the root folder of your workspace, and they will get picked up by Kiro automatically.

## Inclusion modes

Steering files can be configured to load at different times based on your needs. This flexibility helps optimize performance and ensures relevant context is available when needed.

Configure inclusion modes by adding front matter to the top of your steering files. The front matter uses YAML syntax and must be placed at the very beginning of the file, enclosed by triple dashes (`---`).

The inclusion configuration must be the first content in the file, no blank lines or content before it.

### Always included (default)

```yaml
---
inclusion: always
---

```

These files are loaded into every Kiro interaction automatically. Use this mode for core standards that should influence all code generation and suggestions. Examples include your technology stack, coding conventions, and fundamental architectural principles.

**Best for**: Workspace-wide standards, technology preferences, security policies, and coding conventions that apply universally.

### Conditional inclusion

```yaml
---
inclusion: fileMatch
fileMatchPattern: "components/**/*.tsx"
---

```

Files are automatically included only when working with files that match the specified pattern. This keeps context relevant and reduces noise by loading specialized guidance only when needed.

You can also specify multiple patterns using an array:

```yaml
---
inclusion: fileMatch
fileMatchPattern: ["**/*.ts", "**/*.tsx", "**/tsconfig.*.json"]
---

```

**Common patterns**:

- "*.tsx" - React components and JSX files
- "app/api/**/*" - API routes and backend logic
- "**/*.test.*" - Test files and testing utilities
- "src/components/**/*" - Component-specific guidelines
- "*.md" - Documentation files
- ["**/*.ts", "**/*.tsx"] - All TypeScript files
- ["*.js", "*.jsx", "*.ts", "*.tsx"] - All JavaScript and TypeScript files

**Best for**: Domain-specific standards like component patterns, API design rules, testing approaches, or deployment procedures that only apply to certain file types.

### Manual inclusion

```yaml
---
inclusion: manual
---

```

Files are available on-demand by referencing them with `#steering-file-name` in your chat messages. This gives you precise control over when specialized context is needed without cluttering every interaction.

**Usage**: Type `#troubleshooting-guide` or `#performance-optimization` in chat to include that steering file for the current conversation.

**Best for**: Specialized workflows, troubleshooting guides, migration procedures, or context-heavy documentation that's only needed occasionally.

### Auto inclusion

```yaml
---
inclusion: auto
name: api-design
description: REST API design patterns and conventions. Use when creating or modifying API endpoints.
---

```

Files are automatically included when your request matches the description. This works similarly to [skills](/docs/skills)—Kiro uses the description to decide when the steering file is relevant.

| Field | Required | Description |
| --- | --- | --- |
| name | Yes | Identifier for the steering file. Used for display and matching. |
| description | Yes | When to include this file. Kiro matches this against your requests. |

**Best for**: Context-heavy guidance that should only load when relevant—like specialized domain knowledge, complex workflows, or detailed reference material that would overwhelm always-on steering.

## File references

Link to live workspace files to keep steering current:

```markdown
#[[file:<relative_file_name>]]

```

Examples:

- API specs: #[[file:api/openapi.yaml]]
- Component patterns: #[[file:components/ui/button.tsx]]
- Config templates: #[[file:.env.example]]

## Best practices

**Keep Files Focused**
One domain per file - API design, testing, or deployment procedures.

**Use Clear Names**

- api-rest-conventions.md - REST API standards
- testing-unit-patterns.md - Unit testing approaches
- components-form-validation.md - Form component standards

**Include Context**
Explain why decisions were made, not just what the standards are.

**Provide Examples**
Use code snippets and before/after comparisons to demonstrate standards.

**Security First**
Never include API keys, passwords, or sensitive data. Steering files are part of your codebase.

**Maintain Regularly**

- Review during sprint planning and architecture changes
- Test file references after restructuring
- Treat steering changes like code changes - require reviews

## Common steering file strategies

**API Standards** (`api-standards.md`) - Define REST conventions, error response formats, authentication flows, and versioning strategies. Include endpoint naming patterns, HTTP status code usage, and request/response examples.

**Testing Approach** (`testing-standards.md`) - Establish unit test patterns, integration test strategies, mocking approaches, and coverage expectations. Document preferred testing libraries, assertion styles, and test file organization.

**Code Style** (`code-conventions.md`) - Specify naming patterns, file organization, import ordering, and architectural decisions. Include examples of preferred code structures, component patterns, and anti-patterns to avoid.

**Security Guidelines** (`security-policies.md`) - Document authentication requirements, data validation rules, input sanitization standards, and vulnerability prevention measures. Include secure coding practices specific to your application.

**Deployment Process** (`deployment-workflow.md`) - Outline build procedures, environment configurations, deployment steps, and rollback strategies. Include CI/CD pipeline details and environment-specific requirements.

## Related documentation

- Skills - On-demand modular instruction packages for specialized workflows
- Hooks - Automate agent actions based on events

## Skills

<!-- toolType: skill -->

### Agent Skills - IDE - Docs - Kiro

<!-- toolType: skill -->

# Agent Skills

---

## What are skills?

Skills are portable instruction packages that follow the open [Agent Skills](https://agentskills.io) standard. They bundle instructions, scripts, and templates into reusable packages that Kiro can activate when relevant to your task.

Kiro supports the Agent Skills standard, so you can import skills from the community or other compatible AI tools, and share your own skills across the ecosystem.

## How skills work

AI agents are increasingly capable, but they often lack the specific context needed for real work. Without knowledge of your team's deployment process, your company's code review standards, or your project's data analysis pipeline, agents guess and iterate — just like you would when learning something new.

Loading all this context upfront isn't practical either. Too much information overwhelms the agent, slowing responses and reducing quality.

Skills solve this with progressive disclosure:

1. Discovery - At startup, Kiro loads only the name and description of each skill
2. Activation - When your request matches a skill's description, Kiro loads the full instructions
3. Execution - Kiro follows the instructions, loading scripts or reference files only as needed

This keeps context focused while giving Kiro access to extensive specialized knowledge on demand.

## Using skills

Kiro automatically activates skills when your request matches a skill's description. View and manage skills in the **Agent Steering & Skills** section in the Kiro panel.

## Skill scope

Skills can be created with a workspace scope or a global scope.

### Workspace skills

Workspace skills reside in your project under `.kiro/skills/`, and apply only to that specific workspace. Use workspace skills for project-specific workflows like deployment procedures or team conventions.

### Global skills

Global skills reside in your home directory under `~/.kiro/skills/`, and are available across all workspaces. Use global skills for personal workflows you use regardless of project—like your code review process or documentation standards.

In case of conflicting names between global and workspace skills, Kiro will prioritize the workspace skill. This allows you to define global skills that generally apply to all your workspaces, while preserving the ability to override them for specific projects.

## Importing skills

1. Open Agent Steering & Skills section in the Kiro panel
2. Click + and select Import a skill
3. Choose your source:
  - GitHub - Import from a public repository URL
  - Local folder - Import from your filesystem

Imported skills are copied to your skills directory and work immediately.

## Creating a skill

A skill is a folder containing a `SKILL.md` file:

```
my-skill/
├── SKILL.md           # Required
├── scripts/           # Optional executable code
├── references/        # Optional documentation
└── assets/            # Optional templates

```

### SKILL.md format

```markdown
---
name: pr-review
description: Review pull requests for code quality, security issues, and test coverage. Use when reviewing PRs or preparing code for review.
---

## Review process

1. Check for security vulnerabilities
2. Verify error handling
3. Confirm test coverage
4. Review naming and structure

```

### Frontmatter fields

| Field | Required | Description |
| --- | --- | --- |
| name | Yes | Must match folder name. Lowercase, numbers, hyphens only (max 64 chars). |
| description | Yes | When to use this skill. Kiro matches this against your requests (max 1024 chars). |
| license | No | License name or reference to a bundled license file. |
| compatibility | No | Environment requirements (e.g., required tools, network access). |
| metadata | No | Additional key-value data like author or version. |

See the [full specification](https://agentskills.io/specification) for detailed field constraints.

## How skills differ from steering and powers

**Skills** are portable packages following an open standard. They load on-demand and can include scripts. Use for reusable workflows you want to share or import from others.

**Steering** is Kiro-specific context that shapes agent behavior. It supports `always`, `auto`, `fileMatch`, and `manual` modes. Use for project standards and conventions.

**Powers** bundle MCP tools with knowledge and workflows. They activate dynamically based on context. Use for integrations where you need both tools and guidance.

For MCP integrations, [powers](/docs/powers) are usually a better fit—they bundle tools with built-in guidance and activate automatically based on what you're working on.

## Best practices

**Write precise descriptions** - Kiro uses the description to decide when to activate. Include specific keywords: "Review pull requests for security and test coverage" beats "helps with code review."

**Keep SKILL.md focused** - Put detailed documentation in `references/` files. Kiro loads the full SKILL.md on activation.

**Use scripts for deterministic tasks** - Validation, file generation, and API calls work better as scripts than LLM-generated code.

**Choose the right scope** - Global for personal workflows (your review checklist), workspace for team procedures (project deployment).

## Related documentation

- Steering - Project-specific context and standards
- Powers - MCP integrations with bundled knowledge
- Agent Skills specification - Full format details

## Powers

<!-- toolType: power -->

### Create powers - IDE - Docs - Kiro

<!-- toolType: power -->

# Create powers

---

Developers can use our curated powers from launch partners like Datadog, Figma, Neon, Netlify, Postman, Supabase, and Stripe—or build and share their own powers for any tool or framework. Community members have also created powers for building SaaS applications, managing AWS CDK infrastructure, and developing with Amazon Aurora DSQL.

Powers package your tools, workflows, and best practices into a format that Kiro can activate on-demand. When you mention relevant keywords, Kiro loads the power's context and tools automatically.

View our curated powers at [github.com/kirodotdev/powers](https://github.com/kirodotdev/powers)

## What you need

Every power needs a `POWER.md` file. Optionally, you can add:

- mcp.json - MCP server configuration for tool integrations
- steering/ - Workflow-specific guidance files

## Creating POWER.md

Your POWER.md file has two parts: frontmatter and instructions for the agent. We recommend structuring the instructions as onboarding steps (e.g., install CLI, hooks) and steering instructions that contain workflows and best practices. If your power is complex enough, you can separate it into multiple steering files.

### Frontmatter: When to activate

The frontmatter tells Kiro when to load your power. Use keywords that match how developers talk about your tool.

```markdown
---
name: "supabase"
displayName: "Supabase with local CLI"
description: "Build fullstack applications with Supabase's Postgres database, authentication, storage, and real-time subscriptions"
keywords: ["database", "postgres", "auth", "storage", "realtime", "backend", "supabase", "rls"]
---

```

When someone says "Let's set up the database," Kiro sees "database" in the keywords and activates the Supabase power. The power's MCP tools and documentation load into context automatically.

### Onboarding instructions

The onboarding section runs when someone first uses your power. Use it to validate dependencies, explain setup steps, or create workspace hooks.

```markdown
# Onboarding

## Step 1: Validate tools work
Before using Supabase Local MCP, ensure the following are installed and running:
- **Docker Desktop**: Supabase CLI requires Docker to run the local development stack
  - Verify with: `docker --version`
  - **CRITICAL**: If Docker is not installed or not running, DO NOT proceed with Supabase setup.
- **Supabase CLI**: Install via npm, Homebrew, or other package managers
  - Verify with: `supabase --version`

## Step 2: Add hooks
Add a hook to `.kiro/hooks/review-advisors.kiro.hook`

\`\`\`json
{
  "enabled": true,
  "name": "Review Database Performance & Security",
  "description": "Verify database follows performance/security best practices",
  "version": "1",
  "when": {
    "type": "userTriggered"
  },
  "then": {
    "type": "askAgent",
    "prompt": "Execute `get_advisors` via MCP to check for performance and security concerns"
  }
}
\`\`\`

```

Kiro follows these instructions automatically: checks if Docker is running, validates the CLI installation, and creates the performance review hook in the workspace.

### Steering instructions

Steering files are optional. For simple powers, include all guidance directly in your POWER.md. For complex tools with many workflows, split guidance into separate steering files.

**Simple approach (no separate steering files):**

Include all your guidance directly in POWER.md after the onboarding section:

```markdown
# Best Practices

## Database Schema Design
- Use UUIDs for primary keys
- Always add timestamps (created_at, updated_at)
- Enable RLS on all tables with user data

## Example: Creating a table
\`\`\`sql
create table profiles (
  id uuid primary key default gen_random_uuid(),
  username text unique not null,
  created_at timestamptz default now()
);
\`\`\`

```

**Advanced approach (multiple steering files):**

For tools with many distinct workflows, map each workflow to a specific steering file:

```markdown
# When to Load Steering Files
- Setting up a database → `database-setup-workflow.md`
- Writing or formatting SQL code → `supabase-code-format-sql.md`
- Creating or modifying RLS policies → `supabase-database-rls-policies.md`
- Creating PostgreSQL functions → `supabase-database-functions.md`
- Working with declarative schema (`supabase/schemas/` directory) → `supabase-declarative-database-schema.md`
- Setting up or modifying Next.js authentication with Supabase SSR → `supabase-nextjs-supabase-auth.md`
- Implementing realtime features (broadcast, presence, channels, subscriptions) → `supabase-use-realtime.md`

```

When you're working on RLS policies, Kiro loads `supabase-database-rls-policies.md`. When you switch to authentication, it loads `supabase-nextjs-supabase-auth.md` instead. This prevents overwhelming context with every pattern upfront.

## Adding MCP servers

If your power uses MCP tools, create an `mcp.json` file. Server names in your POWER.md must match the `mcpServers` list in your `mcp.json` file.

```json
{
  "mcpServers": {
    "supabase-local": {
      "command": "npx",
      "args": ["-y", "@supabase/mcp-server-supabase"],
      "env": {
        "SUPABASE_URL": "${SUPABASE_URL}",
        "SUPABASE_ANON_KEY": "${SUPABASE_ANON_KEY}"
      }
    }
  }
}

```

Use environment variables for API keys and secrets. During installation, Kiro automatically namespaces server names to avoid conflicts (e.g., `supabase-local` becomes `power-supabase-supabase-local`).

## Directory structure

Here's what a complete power looks like:

```
power-supabase/
├── POWER.md                              # Metadata, onboarding, steering mappings
├── mcp.json                              # MCP server configuration
└── steering/                             # Workflow-specific guidance
    ├── database-setup-workflow.md
    ├── supabase-code-format-sql.md
    ├── supabase-database-rls-policies.md
    └── supabase-edge-functions.md

```

## Testing locally

1. Create your power directory with the files above
2. Open Kiro → Powers panel → Add power from Local Path
3. Select your power directory
4. Test activation by using keywords from your power in a conversation

## Sharing your power

Push your power to a public GitHub repository:

```bash
git init
git add POWER.md mcp.json steering/
git commit -m "Initial release"
git push origin main

```

**Important:** Make sure your repository is public if you want to share it broadly. Private repositories require users to have access permissions.

Others can install it via **Add power from GitHub** using your repository URL.

## Examples

**Simple power (no steering files):**

```
power-simple-tool/
├── POWER.md          # All guidance included here
└── mcp.json          # Optional MCP configuration

```

**Single-tool power with steering:**

```
power-prisma/
├── POWER.md
├── mcp.json
└── steering/
    └── schema-patterns.md

```

**Multi-tool power:**

```
power-full-stack/
├── POWER.md
├── mcp.json
└── steering/
    ├── database-setup.md
    ├── deployment.md
    └── api-integration.md

```

**Documentation-only power:**

```
power-react-patterns/
├── POWER.md          # No MCP servers needed
└── steering/
    ├── component-patterns.md
    └── hooks-patterns.md

```

### Install powers - IDE - Docs - Kiro

<!-- toolType: power -->

# Install powers

---

Powers are designed for easy discovery and installation, whether you're using curated partners, community-built powers, or your team's private tooling. Discovery, installation, and configuration happen through the IDE or the kiro.dev website.

⚠️ Note: Kiro powers are third-party tools that may be subject to separate terms. Only install servers from trusted sources and review their documentation and licensing. Kiro is not responsible for third-party powers.

## Install curated powers

Browse powers from launch partners including Datadog, Dynatrace, Figma, Neon, Netlify, Postman, Supabase, Stripe, Strands SDK, and AWS Aurora.

### From kiro.dev

1. Browse powers at kiro.dev/powers
2. Select a power and click Install
3. The Kiro IDE will open, allowing you to complete the installation with one click

### From the IDE

1. Open the powers panel → click on the Ghosty icon with the lightning bolt 👻⚡
2. Choose a power to view details
3. Choose Install → Confirm

You can now **Try the power** to run through the power onboarding. Any time you ask a question related to that power, the Kiro agent will automatically activate and use it.

### Powers with MCPs

When you install a power that includes Model Context Protocol (MCP) integrations, Kiro automatically registers the MCP server in your `~/.kiro/settings/mcp.json` configuration file under the Powers section.

## Install custom powers

Custom powers require at minimum:

1. POWER.md - Metadata and documentation
2. mcp.json - MCP server configuration (if using MCP tools)
3. steering/ - Workflow-specific guidance files (optional but recommended)

### From public GitHub URL

1. Powers panel → Add power from GitHub
2. Enter repository URL: https://github.com/user/power-repo
3. Click Install

The power must have a valid POWER.md file in the repository root.

### From local path

For powers you create or manage in private repositories, clone the repository locally and install from the local path.

1. Powers panel → Add power from Local Path
2. Select power directory containing POWER.md
3. Click Install

**Example structure:**

```
my-custom-power/
├── POWER.md              # Required
├── mcp.json              # If using MCP servers
└── steering/             # Optional guidance files
    └── workflow.md

```

## Update powers

To update a power to the latest version:

1. Powers panel → power → Check for updates
2. Review changes
3. Click Update

The power refreshes from the remote repository and applies the latest version.

### Powers - IDE - Docs - Kiro

<!-- toolType: power -->

# Powers

---

Kiro powers give your AI agent instant access to specialized knowledge for any technology. Powers package your tools, workflows, and best practices into a format that Kiro can activate on-demand. When you mention relevant keywords, Kiro loads the power's context and tools automatically.

## Get Started

## Concept

### The problem: context overload

**Without framework context, agents guess.** Your agent can call Stripe APIs, but does it know to use idempotent keys? It can query Neon, but does it understand connection pooling for serverless? Without built-in expertise, you're both manually reading documentation and refining approaches until the output is right. Powers give your agent—and by extension, you—instant access to specialized knowledge, so you can work in unfamiliar domains faster.

**With too much context, agents slow down.** Connect five MCP servers and your agent loads 100+ tool definitions before writing a single line of code. Five servers might consume 50,000+ tokens—40% of your context window—before your first prompt. More tools should mean better results, but unstructured context overwhelms the agent, leading to slower responses and lower quality output.

### How powers work

Instead of loading all MCP tools at once, powers activate dynamically based on keywords in your conversation.

When you start a task, Kiro:

1. Reads the task description
2. Evaluates installed powers against the task
3. Loads only relevant powers into context

### What's in a power?

A power is a unified bundle that includes:

1. POWER.md - The steering file that tells the agent what MCP tools it has available and when to use them
2. MCP server configuration - The tools and connection details for the MCP server
3. Steering/hooks - Automated tasks that run on IDE events or via slash commands (optional)

Install the Stripe power with one click. When you mention "payment" or "checkout," the power activates—loading Stripe's MCP tools and the POWER.md steering into context. When you're done with payments and move to database work, the Supabase power activates and Stripe deactivates.

### What makes powers different

**Dynamic MCP tool loading** - Traditional MCP servers load all tools upfront. Powers load tools on-demand, reducing baseline context usage while giving your agent access to dozens of technologies.

**Open ecosystem** - Browse curated powers from launch partners including Datadog, Dynatrace, Figma, Neon, Netlify, Postman, Supabase, Stripe, Strands SDK, and AWS Aurora. Install community-built powers from GitHub URLs, or create and share your own.

**One-click install** - Browse powers directly in Kiro or on kiro.dev. Click "Install" and the power registers automatically. No JSON configuration files, no command-line setup.

## MCP Servers

<!-- toolType: mcp-server -->

### Configuration - IDE - Docs - Kiro

<!-- toolType: mcp-server -->

# Configuration

---

This guide provides detailed information on configuring Model Context Protocol (MCP) servers with Kiro, including configuration file structure, server setup, and best practices.

## Configuration file structure

MCP configuration files use JSON format with the following structure:

```json
{
  "mcpServers": {
    "local-server-name": {
      "command": "command-to-run-server",
      "args": ["arg1", "arg2"],
      "env": {
        "ENV_VAR1": "hard-coded-variable",
        "ENV_VAR2": "${EXPANDED_VARIABLE}"
      },
      "disabled": false,
      "autoApprove": ["tool_name1", "tool_name2"],
      "disabledTools": ["tool_name3"]
    },
    "remote-server-name": {
      "url": "https://endpoint.to.connect.to",
      "headers": {
        "HEADER1": "value1",
        "HEADER2": "value2"
      },
      "disabled": false,
      "autoApprove": ["tool_name1", "tool_name2"],
      "disabledTools": ["tool_name3"]
    }
  }
}

```

### Configuration properties

#### Remote server

| Property | Type | Required | Description |
| --- | --- | --- | --- |
| url | String | Yes | HTTPS endpoint for the remote MCP server (or HTTP endpoint for localhost) |
| headers | Object | No | Headers to pass to the MCP server during connection |
| env | Object | No | Environment variables for the server process |
| disabled | Boolean | No | Whether the server is disabled (default: false) |
| autoApprove | Array | No | Tool names to auto-approve without prompting (use "*" to auto-approve all tools) |
| disabledTools | Array | No | Tool names to omit when calling the Agent |

#### Local server

| Property | Type | Required | Description |
| --- | --- | --- | --- |
| command | String | Yes | The command to run the MCP server |
| args | Array | Yes | Arguments to pass to the command |
| env | Object | No | Environment variables for the server process |
| disabled | Boolean | No | Whether the server is disabled (default: false) |
| autoApprove | Array | No | Tool names to auto-approve without prompting (use "*" to auto-approve all tools) |
| disabledTools | Array | No | Tool names to omit when calling the Agent |

## Configuration locations

You can configure MCP servers at two levels:

1. Workspace Level: .kiro/settings/mcp.json
  - Applies only to the current workspace
  - Ideal for project-specific MCP servers
2. User Level: ~/.kiro/settings/mcp.json
  - Applies globally across all workspaces
  - Best for MCP servers you use frequently

If both files exist, configurations are merged with workspace settings taking precedence.

## Creating configuration files

### Using the command palette

1. Open the command palette:
  - Mac: Cmd + Shift + P
  - Windows/Linux: Ctrl + Shift + P
2. Search for "MCP" and select one of these options:
  - Kiro: Open workspace MCP config (JSON) - For workspace-level configuration
  - Kiro: Open user MCP config (JSON) - For user-level configuration

### Using the Kiro panel

1. Open the Kiro panel
2. Select the Open MCP Config icon

```json
{
  "mcpServers": {
    "web-search": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-bravesearch"
      ],
      "env": {
        "BRAVE_API_KEY": "${BRAVE_API_KEY}"
      }
    }
  }
}

```

## Environment variables

Many MCP servers require environment variables for authentication or configuration:

```json
{
  "mcpServers": {
    "server-name": {
      "env": {
        "API_KEY": "${YOUR_API_KEY}",
        "DEBUG": "true",
        "TIMEOUT": "30000"
      }
    }
  }
}

```

## Disabling servers temporarily

To temporarily disable an MCP server without removing its configuration:

```json
{
  "mcpServers": {
    "server-name": {
      "disabled": true
    }
  }
}

```

## Security considerations

When configuring MCP servers, follow security best practices to protect your credentials and system:

- Use environment variable references (e.g., ${API_TOKEN}) instead of hardcoding sensitive values
- Never commit configuration files with credentials to version control
- Only connect to trusted remote servers
- Review tool permissions before adding them to autoApprove

For comprehensive security guidance, see the [MCP Security Best Practices](/docs/mcp/security) page.

## Troubleshooting configuration issues

If your MCP configuration isn't working:

1. Validate JSON syntax:
  - Ensure your JSON is valid with no syntax errors
  - Check for missing commas, quotes, or brackets
2. Verify command paths:
  - Make sure the command specified exists in your PATH
  - Try running the command directly in your terminal
3. Check environment variables:
  - Verify that all required environment variables are set
  - Check for typos in environment variable names
4. Save configuration changes:
  - Changes to MCP configuration apply automatically when you save the file
  - Simply save the config file (Cmd+S) and servers will reconnect

### Model context protocol (MCP) - IDE - Docs - Kiro

<!-- toolType: mcp-server -->

# Model context protocol (MCP)

---

Model Context Protocol (MCP) extends Kiro's capabilities by connecting to specialized servers that provide additional tools and context. This guide helps you set up, configure, and use MCP servers with Kiro.

## What is MCP?

MCP is a protocol that allows Kiro to communicate with external servers to access specialized tools and information. For example, the AWS Documentation MCP server provides tools to search, read, and get recommendations from AWS documentation directly within Kiro.

With MCP, you can:

- Access specialized knowledge bases and documentation
- Integrate with external services and APIs
- Extend Kiro's capabilities with domain-specific tools
- Create custom tools for your specific workflows

## Setting up MCP

### Prerequisites

Before using MCP, make sure you have:

1. The latest version of Kiro installed
2. Any specific prerequisites for the MCP servers you want to use (listed in each server's documentation)

## Managing MCP servers

### Enabling MCP support

After creating your configuration file:

1. Open Settings with Cmd + , (Mac) or Ctrl + , (Windows/Linux)
2. Search for "MCP"
3. Enable the MCP support setting

### Using the MCP servers tab

The Kiro panel includes an MCP servers tab that shows:

- All configured MCP servers
- Connection status indicators
- Quick access to server tools

To use this feature:

1. Select the Kiro icon in the activity bar
2. Navigate to the MCP servers tab
3. Click any tool name to insert a placeholder prompt in the chat

## Troubleshooting

If you encounter issues with MCP servers:

### Checking MCP logs

1. Open the Kiro panel
2. Select the Output tab
3. Choose "Kiro - MCP Logs" from the dropdown

### Common issues and solutions

| Issue | Solution |
| --- | --- |
| Connection failures | Verify prerequisites are installed correctly |
| Permission errors | Check that tokens and API keys are valid |
| Tool not responding | Review MCP logs for specific error messages |
| Configuration not loading | Validate JSON syntax and save the config file |

## Additional resources

- Official MCP Documentation

## Next steps

Now that you have created a MCP server, you can further learn about MCP servers here:

- Configuring MCPs - Learn about configuring Model Context Protocol (MCP) servers
- MCP Server management - Learn how to use common MCP servers with examples
- Using MCP Tools - Learn how to effectively use MCP tools with Kiro
- Best Practices - Best practices for effective MCP usage

### Best practices - IDE - Docs - Kiro

<!-- toolType: mcp-server -->

# Best practices

---

This guide outlines security best practices for configuring and using Model Context Protocol (MCP) servers with Kiro, helping you protect sensitive information and maintain system security.

## Understanding MCP security

MCP servers extend Kiro's capabilities by connecting to external services and APIs. Since all MCP servers are third-party code, this introduces potential security considerations that should be addressed:

- Access to sensitive information: MCP servers may require API keys or tokens
- External code execution: MCP servers run code outside of Kiro's sandbox
- Data transmission: Information flows between Kiro and external services
- Source verification: Review the source code and verify the server comes from a trusted source before using
- Isolation: Run servers in isolated environments when possible and limit the permissions granted

## Secure configuration

### Protecting API keys and tokens

1. Never commit configuration files with sensitive tokens to version control
2. Create tokens with minimal permissions necessary for the MCP server to function (for example, use fine-grained personal access tokens for GitHub instead of classic tokens)
3. Limit access scope to only the repositories or resources needed
4. Regularly rotate API keys and tokens used in configurations
5. Use environment variables when possible instead of hardcoding values

### Example: Using environment variables

Instead of hardcoding tokens in your configuration:

```json
{
  "mcpServers": {
    "github": {
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
      }
    }
  }
}

```

Set the environment variable in your shell:

```bash
export GITHUB_TOKEN=your-token-value

```

### Approved environment variables

For security, Kiro only expands environment variables that are explicitly approved. Only variables in the approved list will be expanded when found in MCP config files.

When you add or modify an MCP server configuration that includes unapproved environment variables, Kiro displays a security warning popup listing the variables that need approval. You can approve them directly from the popup or manage them in settings.

To manage approved environment variables:

1. Open Kiro settings
2. Search for "Mcp Approved Env Vars"
3. Add the environment variables you want to allow for expansion

This prevents MCP servers from accessing arbitrary environment variables on your system.

### Configuration file permissions

Restrict access to your MCP configuration files:

```bash
# Set restrictive permissions on user-level config
chmod 600 ~/.kiro/settings/mcp.json

# Set restrictive permissions on workspace-level config
chmod 600 .kiro/settings/mcp.json

```

## Safe tool usage

### Tool approval process

1. Review each tool request carefully before approval
2. Check the parameters being passed to the tool
3. Understand what the tool will do before approving it
4. Deny any suspicious requests that don't match your current task

### Auto-approval guidelines

Only auto-approve tools that:

1. Don't have write access to sensitive systems
2. Come from trusted sources with verified code
3. Are used frequently in your workflow
4. Have limited scope of what they can access

```json
{
  "mcpServers": {
    "aws-docs": {
      "autoApprove": [
        "mcp_aws_docs_search_documentation", 
        "mcp_aws_docs_read_documentation"
      ]
    }
  }
}

```

## Workspace isolation

### Using workspace-level configurations

Use workspace-level configurations for project-specific MCP servers:

```
project-a/
├── .kiro/
│   └── settings/
│       └── mcp.json  # Project A specific servers
project-b/
├── .kiro/
│   └── settings/
│       └── mcp.json  # Project B specific servers

```

This ensures that:

- MCP servers only run when working in the relevant project
- Tokens and configurations are isolated between projects
- Security risks are contained to specific workspaces

## Monitoring and auditing

### Checking MCP logs

Regularly review MCP logs to monitor server activity:

1. Open the Kiro panel
2. Select the Output tab
3. Choose "Kiro - MCP Logs" from the dropdown

### Auditing tool usage

Periodically review which tools you've approved:

1. Check your MCP configuration for auto-approved tools
2. Review the MCP logs for tool usage patterns
3. Monitor server activity for unexpected behavior
4. Remove auto-approval for tools you no longer use frequently

## Responding to security incidents

If you suspect a security issue with an MCP server:

1. Disable the server immediately in your configuration
2. Revoke any tokens or API keys associated with the server
3. Check for unauthorized activity in the connected services
4. Report the issue to the MCP server maintainer

## Additional security measures

### Network security

1. Use firewalls to restrict outbound connections from MCP servers
2. Consider using a VPN for sensitive MCP server connections
3. Monitor network traffic to and from MCP servers

### System security

1. Keep your system updated with security patches
2. Run MCP servers with minimal privileges
3. Use separate user accounts for running sensitive MCP servers

### Server directory - IDE - Docs - Kiro

<!-- toolType: mcp-server -->

# Server directory

---

Extend Kiro's capabilities with MCP servers that connect to external services, databases, and tools. Browse the directory below and click `Add to Kiro` for one-click installation.

MCP servers are third-party tools. Only install servers from trusted sources and review their documentation and licensing. Kiro is not responsible for third-party MCP servers.

## MCP server directory

| Name | Install | Description |
| --- | --- | --- |
| Amazon Devices Builder Tools MCP | + Add to Kiro | The Builder Tools MCP provides context and tools to develop, test, and debug apps for Amazon devices. For detailed and up-to-date capabilities, see the official documentation. Requires Node installed. |
| AWS Documentation | + Add to Kiro | Access to AWS documentation, search capabilities, and content recommendations. Requires UV Installed |
| Azure | + Add to Kiro | Interact with Azure services and resources. Requires Node installed |
| Chrome DevTools | + Add to Kiro | Control and inspect a live Chrome browser with DevTools for automation, debugging, and performance analysis. Requires Node installed |
| Context7 | + Add to Kiro | Up-to-date code documentation for any library or framework. Requires Node installed |
| Docker | + Add to Kiro | Manage Docker containers and images. Requires Node installed |
| Dynatrace | + Add to Kiro | Interact with Dynatrace Observability Platform. Requires Node installed |
| Filesystem | + Add to Kiro | Secure file operations within allowed directories. Requires Node installed |
| GCP | + Add to Kiro | Manage Google Cloud Platform resources. Requires Node installed |
| Git | + Add to Kiro | Read, search, and manipulate Git repositories. Requires UV Installed |
| GitHub | + Add to Kiro | Interact with GitHub repositories, issues, and pull requests. |
| Kubernetes | + Add to Kiro | Interact with Kubernetes clusters. Requires Node installed |
| LLM.txt | + Add to Kiro | Access to LLM.txt documentation and resources |
| Memory | + Add to Kiro | Knowledge graph-based persistent memory system for AI agents. Requires Node installed |
| MongoDB | + Add to Kiro | Interact with MongoDB databases. Requires Node installed |
| New Relic | + Add to Kiro | Monitor and analyze application performance with the New Relic observability platform. |
| Pinecone | + Add to Kiro | Vector database for semantic search, RAG workflows, and AI applications. Requires Node installed |
| Playwright | + Add to Kiro | Browser automation with Playwright for web scraping, screenshots, and test code generation. Requires Node installed |
| PostgreSQL | + Add to Kiro | Query and manage PostgreSQL databases. Requires Node installed |
| Sequential Thinking | + Add to Kiro | Dynamic and reflective problem-solving through iterative thinking. Requires Node installed |
| Strands Agent | + Add to Kiro | Access documentation about Strands Agents. Requires UV Installed |
| Web Search | + Add to Kiro | Search the web using Brave Search API. Requires Node installed |

## Share your MCP server

Create one-click installation links that let users add your MCP server to Kiro instantly.

### Install link schema

**URL Format:**

```
https://kiro.dev/launch/mcp/add?name=<server-name>&config=<url-encoded-config>

```

**Query Parameters:**

| Parameter | Type | Required | Description |
| --- | --- | --- | --- |
| name | String | Yes | Display name for the MCP server |
| config | String | Yes | URL-encoded JSON configuration object (see MCP Configuration for schema) |

### Generate an install link

Use these helper functions to programmatically create installation links for your MCP server. These links work universally across GitHub, web browsers, and documentation.

**JavaScript/TypeScript:**

```javascript
function createKiroInstallLink(name, config) {
  const encodedName = encodeURIComponent(name);
  const encodedConfig = encodeURIComponent(JSON.stringify(config));
  return `https://kiro.dev/launch/mcp/add?name=${encodedName}&config=${encodedConfig}`;
}

// Example 1: Local server with command execution
const localServerLink = createKiroInstallLink('aws-docs', {
  command: 'uvx',
  args: ['awslabs.aws-documentation-mcp-server@latest'],
  env: { FASTMCP_LOG_LEVEL: 'ERROR' },
  disabled: false,
  autoApprove: []
});

// Example 2: Remote server with URL endpoint
const remoteServerLink = createKiroInstallLink('aws-knowledge', {
  url: 'https://knowledge-mcp.global.api.aws',
  disabled: false,
  autoApprove: []
});

// Example 3: Server with environment variables
const dbServerLink = createKiroInstallLink('postgresql', {
  command: 'npx',
  args: ['-y', '@modelcontextprotocol/server-postgres'],
  env: { POSTGRES_CONNECTION_STRING: 'postgresql://localhost:5432/mydb' },
  disabled: false,
  autoApprove: []
});

```

**Python:**

```python
import json
from urllib.parse import urlencode, quote

def create_kiro_install_link(name: str, config: dict) -> str:
    """
    Creates a Kiro install link for one-click MCP server installation
    
    Args:
        name: Display name for the MCP server
        config: MCP server configuration dictionary
        
    Returns:
        Formatted HTTPS install link URL
    """
    encoded_name = quote(name)
    encoded_config = quote(json.dumps(config))
    return f"https://kiro.dev/launch/mcp/add?name={encoded_name}&config={encoded_config}"

# Example usage
link = create_kiro_install_link('my-server', {
    'command': 'npx',
    'args': ['-y', '@myorg/my-mcp-server'],
    'disabled': False,
    'autoApprove': []
})

```

**Command Line (Bash):**

```bash
#!/bin/bash

# Function to create Kiro install link
create_kiro_link() {
  local name="$1"
  local config="$2"
  
  # URL encode the parameters
  local encoded_name=$(printf %s "$name" | jq -sRr @uri)
  local encoded_config=$(printf %s "$config" | jq -sRr @uri)
  
  echo "https://kiro.dev/launch/mcp/add?name=${encoded_name}&config=${encoded_config}"
}

# Example usage
CONFIG='{"command":"npx","args":["-y","@modelcontextprotocol/server-git"],"disabled":false,"autoApprove":[]}'
create_kiro_link "git" "$CONFIG"

```

### Add the Kiro badge

Include the `Add to Kiro` badge in your project's README or documentation to let users install your MCP server with a single click:

```html
<a href="https://kiro.dev/launch/mcp/add?name=my-server&config=%7B%22command%22%3A%22npx%22...%7D">
  <img src="https://kiro.dev/images/add-to-kiro.svg" alt="Add to Kiro" />
</a>

```

**Markdown:**

```markdown
[![Add to Kiro](https://kiro.dev/images/add-to-kiro.svg)](https://kiro.dev/launch/mcp/add?name=my-server&config=%7B%22command%22%3A%22npx%22...%7D)

```

When clicked, users are prompted to open Kiro with the server configuration pre-filled. If the prompt doesn't work, the page displays the server name and a retry button.

## Discover more MCP servers

The directory above features curated servers, but hundreds more are available in the MCP ecosystem.

### Official resources

- MCP Registry - Browse the official registry of community-contributed MCP servers with detailed documentation and installation instructions.
- Model Context Protocol Organization - Explore reference implementations and official servers maintained by the MCP team.

### Package registries

- npm (Node.js) - Search for mcp-server or @modelcontextprotocol/server-* to find JavaScript/TypeScript implementations.
- PyPI (Python) - Search for mcp-server or packages with MCP in the name to find Python implementations.

### Tools - IDE - Docs - Kiro

<!-- toolType: mcp-server -->

# Tools

---

This guide explains how to effectively use Model Context Protocol (MCP) tools with Kiro to enhance your productivity and access specialized capabilities.

## Interacting with MCP tools

Once you've [configured MCP servers](/docs/mcp/configuration), you can interact with their tools in several ways:

### Direct questions

The simplest way to use MCP tools is to ask questions related to the server's domain:

```
Tell me about Amazon Bedrock

```

```
How do I configure S3 bucket policies?

```

Kiro automatically selects the appropriate MCP tool based on your question.

### Specific tool requests

You can request specific MCP tools by describing what you want to do:

```
Search AWS documentation for information about ECS task definitions

```

```
Get recommendations for AWS CloudFormation best practices

```

### Explicit context

For more control, provide explicit context to the tool picker:

```
#[aws-docs] search_documentation Tell me about AWS Lambda

```

This format specifies both the server (`aws-docs`) and the tool (`search_documentation`).

## MCP tools panel

The Kiro panel includes an MCP servers tab that provides:

- A list of all configured MCP servers
- Connection status indicators
- Individual tool management
- Quick access to server tools

To access the MCP panel:

1. Select the Kiro icon in the activity bar
2. Navigate to the MCP servers tab
3. View all connected servers and their available tools

### Managing individual tools

Each MCP server can expose multiple tools. You can enable or disable specific tools without affecting the entire server:

**Via the Kiro Panel:**

1. Open the Kiro panel and navigate to MCP servers
2. Expand a server to see its available tools
3. Click on a tool to see options:
  - Enable - Activate a disabled tool
  - Disable - Temporarily disable a tool without removing the server
4. Disabled tools show a "Disabled" label and won't be available to Kiro

**Via JSON Config:**

Use the `disabledTools` array in your MCP configuration to permanently disable specific tools:

```json
{
  "mcpServers": {
    "github": {
      "command": "docker",
      "args": ["run", "-i", "--rm", "-e", "GITHUB_PERSONAL_ACCESS_TOKEN", "ghcr.io/github/github-mcp-server"],
      "disabledTools": ["delete_repository", "force_push", "merge_pull_request"]
    }
  }
}

```

This is useful for:

- Blocking dangerous operations (like delete or force push)
- Reducing tool clutter by hiding tools you don't use
- Improving performance by limiting the tools Kiro considers
- Enforcing team policies when sharing workspace configurations

### Server-level actions

Right-click on a server in the MCP panel to access additional options:

- Reconnect - Restart the connection to the server
- Disable - Temporarily disable the entire server
- Disable All Tools - Disable all tools from this server at once
- Enable All Tools - Re-enable all previously disabled tools
- Show MCP Logs - View detailed logs for troubleshooting

## Tool approval process

When Kiro wants to use an MCP tool, it requests your approval first:

1. You'll see a prompt describing the tool and its purpose
2. Review the tool details and parameters
3. Click "Approve" to allow the tool to run, or "Deny" to prevent it

### Auto-approving trusted tools

To avoid repeated approval prompts for tools you trust:

1. Edit your MCP configuration file
2. Add tool names to the autoApprove array:

```json
{
  "mcpServers": {
    "aws-docs": {
      "autoApprove": [
        "mcp_aws_docs_search_documentation", 
        "mcp_aws_docs_read_documentation"
      ]
    }
  }
}

```

1. Save the file (Cmd+S) to apply changes automatically

## Examples by server type

### AWS Documentation server

#### Searching documentation

```
Search AWS documentation for S3 bucket versioning

```

This uses the `mcp_aws_docs_search_documentation` tool to find relevant AWS documentation.

#### Reading documentation

```
Read the AWS Lambda function URLs documentation

```

This uses the `mcp_aws_docs_read_documentation` tool to retrieve and display documentation content.

#### Getting recommendations

```
Find related content to AWS ECS task definitions

```

This uses the `mcp_aws_docs_recommend` tool to suggest related documentation.

### GitHub MCP server

#### Repository information

```
Show me information about the tensorflow/tensorflow repository

```

This retrieves details about the specified GitHub repository.

#### Code search

```
Find examples of React hooks in facebook/react

```

This searches for code matching your query in the specified repository.

#### Issue management

```
Create an issue in my repository about the login bug

```

This helps you create a new GitHub issue with appropriate details.

## Advanced usage techniques

### Chaining MCP tools

You can use multiple MCP tools in sequence for complex tasks:

```
First search AWS documentation for ECS task definitions, then find related content about service discovery

```

### Combining with local context

MCP tools work best when combined with your local context:

```
Based on my Terraform code, help me optimize my AWS Lambda configuration using best practices from AWS documentation

```

### Using MCP tools in specs

You can use MCP tools within [Kiro Specs](/docs/specs) to enhance your development workflow:

```
In the implementation phase, use AWS documentation to ensure our S3 bucket configuration follows best practices

```

## Troubleshooting tool usage

If you encounter issues when using MCP tools:

### Tool not responding

1. Check the MCP server status in the Kiro panel
2. Review the MCP logs for error messages
3. Use the Ask Kiro feature to resolve errors

### Incorrect results

1. Try rephrasing your request to be more specific
2. Check that you're using the appropriate tool for your task
3. Verify that the MCP server has the necessary permissions

### Tool not available

1. Ensure the MCP server is properly configured
2. Check that the server is running and connected
3. Verify that you have the necessary permissions to use the tool

## Best practices

- Be specific in your requests to get the most relevant results
- Start with direct questions before using explicit tool references
- Auto-approve only tools you trust and use frequently
- Combine MCP tools with local context for best results
- Check tool parameters before approval to ensure they're correct

---

*For information on available MCP servers and their tools, see the MCP Servers page.*

## Custom Agents (CLI)

<!-- toolType: custom-agent -->

### Agent Client Protocol (ACP) - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Agent Client Protocol (ACP)

---

Kiro CLI implements the [Agent Client Protocol (ACP)](https://agentclientprotocol.com/get-started/introduction), an open standard that enables AI agents to work with any compatible editor. This means you can use Kiro's agentic capabilities in JetBrains IDEs, Zed, and other ACP-compatible editors.

## What is ACP?

AI coding agents and editors are tightly coupled, but interoperability isn't the default. Each editor must build custom integrations for every agent, and agents must implement editor-specific APIs. This creates integration overhead, limited compatibility, and developer lock-in.

ACP solves this by providing a standardized protocol for agent-editor communication—similar to how the Language Server Protocol (LSP) standardized language server integration. Agents that implement ACP work with any compatible editor, and editors that support ACP gain access to all ACP-compatible agents.

## Quick start

Run Kiro as an ACP agent:

```bash
kiro-cli acp

```

The agent communicates over stdin/stdout using JSON-RPC 2.0. Configure your editor to spawn this command, and you're ready to go.

## Editor setup

Kiro CLI can be used as an ACP agent in any editor that supports the protocol.

Use the full path to `kiro-cli` in your editor configuration. IDEs often don't inherit your shell's PATH, so commands like `kiro-cli` may not be found. Run `which kiro-cli` to find the path on your system (commonly `~/.local/bin/kiro-cli` on Linux/macOS).

### JetBrains IDEs

JetBrains IDEs (IntelliJ IDEA, WebStorm, PyCharm, etc.) support ACP through AI Assistant. See the [JetBrains ACP documentation](https://www.jetbrains.com/help/ai-assistant/acp.html) for full details.

To add Kiro as a custom agent:

1. Open the AI Chat tool window
2. Click the settings button and select Add Custom Agent
3. Add the following to ~/.jetbrains/acp.json:

```json
{
  "agent_servers": {
    "Kiro Agent": {
      "command": "/full/path/to/kiro-cli",
      "args": ["acp"]
    }
  }
}

```

The agent will appear in the AI Chat mode selector.

### Zed

Zed supports ACP agents natively. See the [Zed external agents documentation](https://zed.dev/docs/ai/external-agents#custom-agents) for full details. Add the following to your Zed settings (`~/.config/zed/settings.json`):

```json
{
  "agent_servers": {
    "Kiro Agent": {
      "type": "custom",
      "command": "~/.local/bin/kiro-cli",
      "args": ["acp"],
      "env": {}
    }
  }
}

```

Select "Kiro Agent" from the agent picker in Zed's AI panel.

### Other editors

Any editor supporting ACP can integrate Kiro by spawning `kiro-cli acp` and communicating via JSON-RPC over stdio. See the [ACP specification](https://agentclientprotocol.com) for protocol details.

## Supported ACP methods

Kiro CLI implements the following ACP methods, giving you access to session management, model selection, and streaming responses when using Kiro through any ACP-compatible editor.

### Core protocol

| Method | Description |
| --- | --- |
| initialize | Initialize the connection and exchange capabilities |
| session/new | Create a new chat session |
| session/load | Load an existing session by ID |
| session/prompt | Send a prompt to the agent |
| session/cancel | Cancel the current operation |
| session/set_mode | Switch agent mode (e.g., different agent configs) |
| session/set_model | Change the model for the session |

### Agent capabilities

The Kiro ACP agent advertises these capabilities during initialization:

- loadSession: true - Supports loading existing sessions
- promptCapabilities.image: true - Supports image content in prompts

### Session updates

The agent sends these session update types via `session/notification`:

| Update Type | Description |
| --- | --- |
| AgentMessageChunk | Streaming text/content from the agent |
| ToolCall | Tool invocation with name, parameters, status |
| ToolCallUpdate | Progress updates for running tools |
| TurnEnd | Signals the agent turn has completed |

## Kiro extensions

Kiro extends ACP with custom methods (prefixed with `_kiro.dev/` per the ACP spec) to expose Kiro-specific features like [slash commands](/docs/cli/reference/slash-commands), [MCP servers](/docs/cli/mcp), and [context compaction](/docs/cli/chat#context-management). Clients that don't support these extensions can safely ignore them—they're optional enhancements.

These extensions are experimental and subject to change in future releases.

### Slash commands

| Method | Type | Description |
| --- | --- | --- |
| _kiro.dev/commands/execute | Request | Execute a slash command (e.g., /agent swap, /context add) |
| _kiro.dev/commands/options | Request | Get autocomplete suggestions for a partial command |
| _kiro.dev/commands/available | Notification | Sent after session creation with the list of available commands |

### MCP server events

| Method | Type | Description |
| --- | --- | --- |
| _kiro.dev/mcp/oauth_request | Notification | Provides OAuth URL when an MCP server requires authentication |
| _kiro.dev/mcp/server_initialized | Notification | Indicates an MCP server has finished initializing and its tools are available |

### Session management

| Method | Type | Description |
| --- | --- | --- |
| _kiro.dev/compaction/status | Notification | Reports progress when compacting conversation context |
| _kiro.dev/clear/status | Notification | Reports status when clearing session history |
| _session/terminate | Notification | Terminates a subagent session |

## Example: Initialize connection

Here's how an ACP client initializes a connection with Kiro:

```json
// Client sends initialize request
{
  "jsonrpc": "2.0",
  "id": 0,
  "method": "initialize",
  "params": {
    "protocolVersion": 1,
    "clientCapabilities": {
      "fs": {
        "readTextFile": true,
        "writeTextFile": true
      },
      "terminal": true
    },
    "clientInfo": {
      "name": "my-editor",
      "version": "1.0.0"
    }
  }
}

// Kiro responds with capabilities
{
  "jsonrpc": "2.0",
  "id": 0,
  "result": {
    "protocolVersion": 1,
    "agentCapabilities": {
      "loadSession": true,
      "promptCapabilities": {
        "image": true
      }
    },
    "agentInfo": {
      "name": "kiro-cli",
      "version": "1.5.0"
    }
  }
}

```

After initialization, create a session and start prompting:

```json
// Create a new session
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "session/new",
  "params": {
    "cwd": "/home/user/my-project",
    "mcpServers": []
  }
}

// Send a prompt
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "session/prompt",
  "params": {
    "sessionId": "sess_abc123",
    "content": [
      {
        "type": "text",
        "text": "Explain this codebase"
      }
    ]
  }
}

```

## Session storage

ACP sessions are persisted to disk at:

```
~/.kiro/sessions/cli/

```

Each session creates two files:

- <session-id>.json - Session metadata and state
- <session-id>.jsonl - Event log (conversation history)

## Logging

ACP agent logs are written to the standard Kiro log location:

| Platform | Location |
| --- | --- |
| macOS | $TMPDIR/kiro-log/kiro-chat.log |
| Linux | $XDG_RUNTIME_DIR/kiro-log/kiro-chat.log |

Control log verbosity with environment variables:

```bash
KIRO_LOG_LEVEL=debug kiro-cli acp
KIRO_CHAT_LOG_FILE=/path/to/custom.log kiro-cli acp

```

## Related

- Interactive Chat - Uses ACP internally
- MCP Integration - MCP servers can be passed to ACP sessions
- CLI Commands Reference

### Authentication methods - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Authentication methods

---

Kiro supports the following authentication providers:

- GitHub: Seamless integration with your GitHub account
- Google: Sign in with your Google credentials
- AWS Builder ID: Quick setup for individual developers
- AWS IAM Identity Center: Enterprise-grade authentication

Users that have a paid Kiro subscription and access it through a social login provider (like GitHub or Google) or through AWS Builder ID are considered *individual subscribers*. We may use certain content from Kiro Free Tier and Kiro individual subscribers for service improvement. For more information on service improvement and how to opt out, see [Service improvement](/docs/privacy-and-security/data-protection/#service-improvement).

## Sign in to Kiro CLI

1. At the command line, enter kiro-cli or kiro-cli login. You'll be prompted to press Enter to complete sign-in in your browser.
2. In your browser, choose the organization or system through which you will authenticate:
  - Google
  - GitHub
  - Builder ID
  - Your organization
3. After you authenticate, you'll receive a message in your browser, directing you back to your terminal.
4. When you return to your terminal, you should be signed in with the Kiro CLI.

## Sign in from a remote machine

When running Kiro CLI on a remote machine (via SSH, SSM, containers, etc.), authentication works differently since the remote machine cannot open a browser.

For Builder ID and IAM Identity Center, Kiro CLI uses device code authentication. You'll see a URL and code to enter in your local browser—no additional setup required.

For social login (Google or GitHub), the CLI uses PKCE authentication which requires port forwarding. The OAuth callback redirects to `localhost`, which won't reach the remote CLI without a tunnel.

**To sign in with social login on a remote machine:**

1. Run kiro-cli login and select "Use for Free with Google or GitHub"
2. Note the port number displayed (it varies each time, e.g., 49153)
3. In a new terminal on your local machine, set up port forwarding:
bashssh -L <PORT>:localhost:<PORT> -N user@remote-host

Replace <PORT> with the port from step 2, and user@remote-host with your remote credentials.
4. Press Enter in the CLI, then open the URL in your local browser
5. Complete authentication—the callback reaches the CLI through the tunnel

**SSH port forwarding examples:**

```bash
# Basic port forwarding (replace 49153 with your actual port)
ssh -L 49153:localhost:49153 -N user@remote-host

# With a custom identity file (common for EC2)
ssh -i ~/.ssh/my-key.pem -L 49153:localhost:49153 -N user@remote-host

# Using an SSH config alias
ssh -L 49153:localhost:49153 -N myserver

```

**Troubleshooting port forwarding:**

- Authentication timed out: Port forwarding isn't active or using the wrong port. Verify the port matches what the CLI displayed.
- Failed to bind callback port: The port is in use on the remote machine. Run lsof -i :<PORT> on the remote to identify the process.
- Address already in use when starting SSH: The port is in use locally. Close other tunnels or stale SSH sessions.
- Tunnel disconnects mid-auth: Keep the SSH terminal open until authentication completes. Add -o ServerAliveInterval=60 to prevent timeouts.

## Sign out of Kiro CLI

**To sign out of Kiro CLI**

1. At the command line, enter kiro-cli logout.

## Troubleshooting authentication issues

If you encounter problems during the authentication process, such as browser redirect failures or sign-in errors, check our [troubleshooting guide](/docs/troubleshooting/#authentication-issues) for platform-specific solutions and common fixes.

## Next steps

- Review FAQ
- Explore Chat features
- Get started with Kiro CLI

### Completions & autocomplete - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Completions & autocomplete

---

Kiro CLI provides two AI-powered assistance features to help you work more efficiently in your terminal:

- Autocomplete Dropdown Menu: A graphical menu showing available command options
- Inline Suggestions: Gray "ghost text" that appears as you type

These features work independently and support hundreds of popular command line tools including `git`, `npm`, `docker`, and `aws`.

## Autocomplete dropdown menu

The autocomplete dropdown appears to the right of your cursor when typing commands, showing available options, subcommands, and arguments that you can select using arrow keys.

### Using autocomplete

The autocomplete dropdown is automatically enabled after you install Kiro CLI:

1. Open your terminal or command prompt
2. Start typing a command
3. A graphical menu will appear showing available options
4. Use arrow keys to navigate suggestions
5. Press Tab or Enter to select an option

### Configuration

Customize the autocomplete behavior:

```bash
# Enable/disable autocomplete
kiro-cli settings autocomplete.disable false  # enable
kiro-cli settings autocomplete.disable true   # disable

# Change theme
kiro-cli theme dark
kiro-cli theme light  
kiro-cli theme system

# View current theme
kiro-cli theme

# List available themes
kiro-cli theme --list

```

## Inline suggestions

Inline suggestions appear as gray "ghost text" directly on your command line as you type. This feature works independently from the dropdown menu.

### Using inline suggestions

Inline suggestions are enabled by default:

1. Start typing a command
2. Gray ghost text will appear showing potential completions
3. Press the right arrow key or Tab to accept
4. Continue typing to ignore the suggestion

### Managing inline suggestions

Control inline suggestions with the `kiro-cli inline` command:

```bash
# Enable inline suggestions
kiro-cli inline enable

# Disable inline suggestions  
kiro-cli inline disable

# Check current status
kiro-cli inline status

# Set customization
kiro-cli inline set-customization [ARN]

# Show available customizations
kiro-cli inline show-customizations

```

## Supported tools

The autocomplete system supports hundreds of command line tools:

### Popular tools

- Git: Branch names, commit hashes, file paths
- Docker: Container names, image tags, commands
- npm/yarn: Package names, scripts, dependencies
- kubectl: Resources, namespaces, contexts
- terraform: Resources, providers, variables
- aws: Services, regions, resource names

### Language tools

- Python: pip, poetry, conda
- Node.js: npm, yarn, pnpm
- Ruby: gem, bundle
- Go: go mod, go build

### System tools

- Standard Unix/Linux commands
- Package managers (apt, brew, yum)
- File operations (ls, find, grep)

## Troubleshooting

### Autocomplete not working

If autocomplete isn't appearing:

1. Verify installation: kiro-cli --version
2. Check if disabled: kiro-cli settings autocomplete.disable
3. Restart your terminal
4. Try a different shell (bash, zsh, fish)

### Inline suggestions issues

If inline suggestions aren't working:

1. Check status: kiro-cli inline status
2. Enable if disabled: kiro-cli inline enable
3. Verify shell compatibility
4. Check terminal emulator support

### Enterprise billing - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Enterprise billing

---

When you subscribe your team to Kiro, you can choose from the following service tiers:  **Kiro Pro**, **Kiro Pro+**, and **Kiro Power**. Depending on usage patterns, higher level tiers will give users more credits to use with Kiro.

Credits are consumed fractionally based on each request. Simple edits and shorter prompts will use fewer credits than complex, lengthy tasks. This means that fractional credits will give you more value from your credit allocation.

## Tier comparison

| Tier | Credits | Overage |
| --- | --- | --- |
| Pro | 1,000 | Opt-in |
| Pro+ | 2,000 | Opt-in |
| Power | 10,000 | Opt-in |

You are billed monthly for each user that you subscribe to Kiro. For more information, see [Kiro pricing](https://kiro.dev/pricing/).

## I've subscribed a user twice. Will I be double-billed?

It depends.

If a user is subscribed twice *under the same Kiro profile* (for example, in two different groups), then you will *not* be charged twice. Instead, you will pay the subscription price of the highest tier assigned to the user. Example: If Alice is subscribed at the Pro tier in group A, and the Pro+ tier in group B, then you will pay the Pro+ tier price for Alice.

If a user is subscribed twice under *different Kiro profiles* (for example, in two different AWS Regions), then you will be charged twice. Example: If Bob is subscribed in Profile A in Europe (Frankfurt) and Profile B in US East (N. Virginia), then you will be charged twice for Bob.

## Proration considerations

- If you unsubscribe a user mid-month, you will pay for the last month in full. The cancellation takes effect at the beginning of the following month.
- If you upgrade a subscription mid-month, you will be refunded for the lower-tier subscription, and you will be charged in full for the higher-tier subscription.
- If you downgrade a subscription mid-month, you will pay in full for the higher-tier subscription, and you will be charged for the lower-tier subscription starting the following month.

## Viewing your bill

- You can view your bill in the AWS console's Billing and Cost Management service. The Kiro expenses are listed on the Charges by service tab, under Kiro. For more information about the Billing and Cost Management service, see What is AWS Billing and Cost Management? in the AWS Billing User Guide.
- You can identify the cost of Kiro subscriptions for specific users with resource IDs through AWS Billing and Cost Management. To do so, in the Billing and Cost Management console, under Data Exports, create either a standard data export or a legacy CUR export with the Include resource IDs option selected. To learn more, refer to Creating data exports in the AWS Data Exports User Guide.

### Built-in tools - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Built-in tools

---

Kiro CLI includes a collection of built-in tools that enhance your terminal experience with AI-powered assistance for common development tasks.

## File read

**Tool name**: `read`

**Description**: Reads files, folders and images

```bash
> what dependencies does my application have

Reading file: src/snake/package.json, all lines (using tool: read)
 ✓ Successfully read 1417 bytes from src/snake/package.json
 - Completed in 0.86s

> Your application has:

Runtime Dependencies:
- typescript (^3.5.1) - TypeScript compiler
- gh-pages (^2.0.1) - GitHub Pages deployment

Dev Dependencies:
- sass (^1.20.3) - CSS preprocessing
- eslint (^5.16.0) + TypeScript plugins - Code linting
- jest (^29.5.0) + ts-jest - Testing framework

No external game libraries or frameworks.

```

You can also configure the `read` tool in the agent configuration to have specific access to the files and folders in your project, giving you granular control over what the Kiro can read.

```json
{
  "toolsSettings": {
    "read": {
      "allowedPaths": ["~/projects", "./src/**"],
      "deniedPaths": ["d1/denied/path/", "d2/denied/path/**/file.txt"]
    }
  }
}

```

### Configuration options

| Option | Type | Required | Description |
| --- | --- | --- | --- |
| allowedPaths | array of paths | No | Paths that can read without prompting. |
| deniedPaths | array of paths | No | Paths that are denied. |

Path values can be glob patterns similar to the behavior as gitignore. For example, `~/temp` would match `~/temp/child` and `~/temp/child/grandchild`

## Glob

**Tool name**: `glob`

**Description**: Fast file discovery using glob patterns. Respects `.gitignore`. Prefer this over `find` command in bash.

```bash
> find all TypeScript test files in my project

Finding files matching pattern: **/*.test.ts (using tool: glob)

 ✓ Found 8 files
 - Completed in 0.12s

> Here are the TypeScript test files:

src/utils/helpers.test.ts
src/utils/validators.test.ts
src/components/button.test.ts
src/components/header.test.ts
src/services/auth.test.ts
src/services/api.test.ts
src/hooks/useAuth.test.ts
src/hooks/useForm.test.ts

```

You can configure the `glob` tool in the agent configuration to control which paths can be searched.

```json
{
  "toolsSettings": {
    "glob": {
      "allowedPaths": ["~/projects", "./src/**"],
      "deniedPaths": ["/etc", "/var"],
      "allowReadOnly": true
    }
  }
}

```

### Configuration options

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| allowedPaths | array of strings | [] | List of paths that can be searched without prompting. Supports glob patterns |
| deniedPaths | array of strings | [] | List of paths that are denied. Deny rules are evaluated before allow rules |
| allowReadOnly | boolean | false | Whether to allow searches anywhere without prompting |

## Grep

**Tool name**: `grep`

**Description**: Fast content search using regex. Respects `.gitignore`. Use this instead of `grep`, `rg`, or `ag` commands in bash.

```bash
> find all TODO comments in my project

Searching for pattern: TODO (using tool: grep)

 ✓ Found 12 matches across 5 files
 - Completed in 0.34s

> Here are the TODO comments I found:

src/utils/helpers.ts:23
  // TODO: Add error handling for edge cases

src/components/header.tsx:45
  {/* TODO: Implement mobile navigation */}

src/api/routes.ts:12
  // TODO: Add rate limiting
  // TODO: Implement caching

src/services/auth.ts:78
  // TODO: Add refresh token logic

...

```

You can configure the `grep` tool in the agent configuration to control which paths can be searched.

```json
{
  "toolsSettings": {
    "grep": {
      "allowedPaths": ["~/projects", "./src/**"],
      "deniedPaths": ["/etc", "/var"],
      "allowReadOnly": true
    }
  }
}

```

### Configuration options

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| allowedPaths | array of strings | [] | List of paths that can be searched without prompting. Supports glob patterns |
| deniedPaths | array of strings | [] | List of paths that are denied. Deny rules are evaluated before allow rules |
| allowReadOnly | boolean | false | Whether to allow searches anywhere without prompting |

## File write

**Tool name**: `write`

**Description**: Tool for creating and editing files

```bash
> collect best practices for writing typescript code and save it to the kiro steering folder as codingpractices.md

I'll create the following file: src/snake/.kiro/steering/codingpractices.md (using tool: write)
Purpose: Create TypeScript coding best practices document

+     1: # TypeScript Coding Best Practices
+     2: 
+     3: ## Type Safety
+     4: - Enable strict mode in `tsconfig.json` (`strict: true`)
+     5: - Avoid `any` type - use `unknown` for truly dynamic types
+     6: - Use explicit return types for functions
+     7: - Leverage type inference where it improves readability
+     8: - Use union types instead of enums when possible
+     9: - Prefer `interface` for object shapes, `type` for unions/intersections
+    10: 
+    11: ## Code Organization
+    12: - One class/interface per file (exceptions for small related types)
+    13: - Group related functionality into modules
+    14: - Use barrel exports (`index.ts`) for clean imports
+    15: - Keep functions small and focused (single responsibility)
+    16: - Separate business logic from presentation logic

```

You can also configure the `write` tool in the agent configuration to have specific access to the files and folders in your project, giving you granular control over what the Kiro can write to.

```json
{
  "toolsSettings": {
    "write": {
      "allowedPaths": ["~/projects/output.txt", "./src/**"],
      "deniedPaths": ["/d1/denied/path/", "/d2/denied/path/**/file.txt"]
    }
  }
}

```

### Custom diff tools

By default, the write tool displays code changes using a built-in inline diff. You can configure an external diff tool to view changes instead. See [Custom diff tools](/docs/cli/chat/diff-tools) for setup instructions and supported tools.

### Configuration options

| Option | Type | Required | Description |
| --- | --- | --- | --- |
| allowedPaths | array of paths | No | Paths that can be written to without prompting. |
| deniedPaths | array of paths | No | Paths that are denied. |

Path values can be glob patterns similar to the behavior as gitignore. For example, `~/temp` would match `~/temp/child` and `~/temp/child/grandchild`

## Execute shell commands

**Tool name**: `shell`

**Description**: Tool for executing a specified bash command.

You can also configure the `shell` tool in the agent configuration to control what commands Kiro can execute.

```json
{
  "toolsSettings": {
    "shell": {
      "allowedCommands": ["git status", "git fetch"],
      "deniedCommands": ["git commit .*", "git push .*"],
      "autoAllowReadonly": true
    }
  }
}

```

### Configuration Options

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| allowedCommands | array of strings | [] | List of commands that are allowed without prompting |
| deniedCommands | array of strings | [] | List of commands that are denied. Deny rules are evaluated before allow rules |
| autoAllowReadonly | boolean | false | When enabled, read-only commands are allowed without prompting. This parameter does not restrict write actions. |
| denyByDefault | boolean | false | When true, deny any command outside allowedCommands and not auto-approved by autoAllowReadonly, instead of prompting for approval |

**Note**: `allowedCommands` and `deniedCommands` support regex formatting. regex entered are anchored with \A and \z, and does NOT support look-around, including look-ahead and look-behind.

## Execute AWS commands

**Tool name**: `aws`

**Description**: Tool for making AWS CLI calls with the specified service, operation, and parameters

```bash
 list my s3 buckets

Running aws cli command (using tool: aws):

Service name: s3api
Operation name: list-buckets
Parameters: 
Region: us-east-1
Label: List all S3 buckets

```

You can also configure the `aws` tool in the agent configuration to only perform specific AWS operations.

```json
{
  "toolsSettings": {
    "aws": {
      "allowedServices": ["s3", "lambda", "ec2"],
      "deniedServices": ["eks", "rds"],
      "autoAllowReadonly": true
    }
  }
}

```

## Web search and fetch

Web access capabilities enable Kiro agent to access current information from the internet in real-time. This feature enables you to get up-to-date answers about topics that may have changed since the model's training data was created. These tools have been designed to not reproduce meaningful chunks of text and it should not be able to access webpages behind paywalls, authentication, and similar access restrictions. Search results may vary over time as internet content changes. Some content may not be accessible through web search due to various restrictions or the nature of the content.

| Tool | Description |
| --- | --- |
| web_search | Tool for searching the web |
| web_fetch | Tool for fetching content from a URL |

You are responsible for your use of output that incorporates web search or grounded information. You will know when your output includes grounded information from citations or links to the source material. You must retain and display these citations and links in the output if you display the grounded output to a downstream user. If you don't want Kiro to use these tools, create a custom agent that [excludes](/docs/cli/custom-agents/configuration-reference/#tools-field) these tools. Citations are provided for output that incorporates web search or grounded information. You can follow a provided citation to the source page.

```bash

# Example 1
> What is the latest on EC2 instances?

> I'll search for the latest information on EC2 instances.
Searching the web for: AWS EC2 instances latest 2025 (using tool: web_search)

 ✓ Found 10 search results
 - Completed in 2.12s

> Here's what I found:

Recent EC2 Instance Launches (2025):

New Instance Families:
- **M8a instances** - General-purpose instances with 5th Gen AMD EPYC (Turin) processors running at 4.5GHz. They deliver up to 30% higher performance and 19% better price-performance versus M7a instances.

- **C8gd, M8gd, R8gd instances** - Graviton-based instances with up to 11.4 TB of local NVMe SSD storage, now generally available.

- **X8g instances** - Powered by AWS Graviton4 processors, delivering up to 60% better performance than X2gd instances. Available in US East (Ohio).

- **R8i and R8i-flex instances** - Intel-based memory-optimized instances offering up to 15% better price-performance and 2.5x more memory bandwidth compared to previous Intel generations. They deliver 20% better performance than R7i 
instances.

- **I7i instances** - Storage-optimized instances with 5th Gen Intel Xeon processors, delivering up to 23% better compute performance and 10% better price-performance over I4i instances.

Expanded Availability:
- C7i-flex and M7i-flex now available in 12xlarge and 16xlarge sizes
- Various instances expanding to additional regions including Europe (Milan) and US West (N. California)

Key Trend: AWS continues focusing on performance improvements (20-30% gains), better price-performance (10-19% improvements), and expanding processor options across Intel, AMD, and Graviton architectures.

References:
[1] Document history for the Amazon EC2 Instance Types Guide - https://docs.aws.amazon.com/ec2/latest/instancetypes/doc-history.html
... 
[10] Amazon EC2 C7i-flex and C7i instances are now available in 2 additional regions - https://aws.amazon.com/about-aws/whats-new/2025/06/amazon-ec2-c7i-flex-c7i-instances-additional-...
 ▸ Time: 19s


# Example 2
> What is the latest on t3 medium instance pricing.

Searching the web for: AWS EC2 t3.medium instance pricing 2025 (using tool: web_search)

 ✓ Found 10 search results
 - Completed in 1.596s

Fetching content from: https://aws.amazon.com/ec2/pricing/on-demand/ (searching for: t3.medium price cost) [mode: selective] (using tool: web_fetch)

 ✓ Fetched 11395 bytes (selective) from URL
 - Completed in 0.718s

> The page doesn't show specific pricing in the excerpt. Let me get the actual pricing information:
Fetching content from: https://instances.vantage.sh/aws/ec2/t3.medium (searching for: t3.medium $0.04) [mode: selective] (using tool: web_fetch)

 ✓ Fetched 3971 bytes (selective) from URL
 - Completed in 0.780s

> Here's what I found:

AWS EC2 t3.medium Instance Pricing (2025):

...

```

To optimize retrieving content from a URL and better manage your context window, `web_fetch` tool has "Selective" and "Truncated" modes.

```bash
# Example - using truncated
>  https://kiro.dev/blog/introducing-kiro-cli/ --> Can you get some of this page for me?

Fetching content from: https://kiro.dev/blog/introducing-kiro-cli/ [mode: truncated] (using tool: web_fetch)

 ✓ Fetched 8051 bytes (truncated content) from URL
 - Completed in 0.521s

> I've fetched the beginning portion of the page. It's a blog post announcing Kiro CLI. Here's what this section covers:

Title: "Bring Kiro agents to your terminal with Kiro CLI" (November 17, 2025)

Main Points:
- Kiro CLI brings AI agents into your terminal so you don't lose context when debugging production servers or working in SSH sessions
- Built on Q Developer CLI technology with additions like social login, Haiku 4.5, and the Auto agent
- Supports custom agents tailored to specific workflows (backend, frontend, DevOps)
- Your .kiro folder configs work in both IDE and CLI

Installation:
bash
curl -fsSL https://cli.kiro.dev/install | bash


Key Features covered in this section:
1. Custom agents with pre-approved tools, persistent context, and controlled access
2. Smart context management (Agent Resources, Session Context, Knowledge Bases)
3. Multiple authentication options (GitHub, Google, AWS Builder ID, IAM Identity Center)
4. Full IDE integration - MCP servers and steering rules transfer seamlessly
5. Interactive chat, multimodal input, and MCP support

The page continues beyond what was fetched. Would you like me to get a specific section or search for particular information?


```

In this case, since no specific pointers on the type of content to retrieve was provided, the tool automatically only retrieves part of the page (up to 8KB) to manage the context window.

```bash
# Example - using selective 

> https://kiro.dev/blog/introducing-kiro-cli/ --> Can you get installation information from this page for me.

Fetching content from: https://kiro.dev/blog/introducing-kiro-cli/ (searching for: installation install getting started) [mode: selective] (using tool: web_fetch)

 ✓ Fetched 7909 bytes (selective) from URL
 - Completed in 0.434s

> Here's the installation information from the page:

## Installation

Kiro CLI is available for macOS and Linux. Installation is straightforward:

bash
curl -fsSL https://cli.kiro.dev/install | bash


## First Steps

1. Authenticate and start chatting: Sign in with your credentials

2. Explore commands: Get help anytime

The page also mentions at the end:

bash
curl -fsSL https://cli.kiro.dev/install | bash


That's the single command you need to install Kiro CLI on macOS or Linux systems.

```

In this case, since the prompt was specific, the tool only retrieves selected content from the page.

### Fetch modes

| Mode | Behavior | Use case |
| --- | --- | --- |
| selective (default) | Returns 10 sentences before/after search term matches; 20 sentences if no matches | Targeted extraction |
| truncated | First 8000 characters | Quick preview |
| full | Complete content (up to 10MB) | Comprehensive analysis |

### Configuration

Configure URL-based permissions using `toolsSettings`:

```json
{
  "toolsSettings": {
    "web_fetch": {
      "trusted": [".*docs\\.aws\\.amazon\\.com.*", ".*github\\.com.*"],
      "blocked": [".*pastebin\\.com.*"]
    }
  }
}

```

| Option | Type | Description |
| --- | --- | --- |
| trusted | array of regex | URL patterns to auto-allow without prompting |
| blocked | array of regex | URL patterns to deny (takes precedence over trusted) |

**Pattern behavior:**

- Patterns are regex, automatically anchored with ^ and $
- blocked takes precedence over trusted
- Invalid regex in blocked denies all URLs (fail-safe)
- Invalid regex in trusted are skipped

### Limitations

- Size: 10MB maximum per page fetch
- Timeout: 30 seconds per request
- Redirects: Maximum 10 redirects followed
- Content type: Only text/html pages supported
- Retries: 3 automatic retry attempts on failure

### Troubleshooting

| Issue | Cause | Solution |
| --- | --- | --- |
| Fetch failed | Page >10MB, timeout, too many redirects, or binary content | Try different URL or check page accessibility |
| Empty content | Search terms don't match page content | Use different search terms or truncated/full mode |
| URL blocked | URL matches blocked pattern | Remove pattern from toolsSettings |
| Tool requires approval | URL not in trusted patterns and web_fetch not in allowedTools | Add URL pattern to trusted or add web_fetch to allowedTools |
| web_search and web_fetch not available | Web tools disabled by enterprise administrator | Contact your administrator to enable web tools |

## Introspect Kiro CLI capabilities

**Tool name**: `introspect`

**Description**: Provides self-awareness for Kiro CLI by answering questions about its features, commands, and functionality using official documentation.

The introspect tool activates automatically when you ask Kiro CLI questions about itself. It searches built-in documentation to provide accurate answers about commands, settings, tools, and features.

```bash
> How do I save conversations?

Introspecting to get you the right information (using tool: introspect) - Completed in 0.68s

> You can save conversations using `/chat save <PATH>`:

- `/chat save ~/conversation.json` - Save to a specific path

Load saved conversations later with `/chat load <PATH>`.

```

### How it works

By default, introspect uses semantic search:

1. Downloads embedding models
2. Uses semantic search to find relevant documentation
3. Returns matched docs directly

For enterprise environments where model downloads may be blocked, enable progressive mode:

```bash
kiro-cli settings set introspect.progressiveMode true

```

Progressive mode skips the model download and returns the documentation index instead. The LLM then fetches specific docs as needed.

Progressive mode may require multiple introspect calls to retrieve all relevant information, which can be slower than semantic search.

### What it provides

- Command help: Real-time documentation for all slash commands (/chat, /context, /agent, etc.)
- Feature guides: Information about capabilities like MCP, hooks, steering, and custom agents
- Settings reference: All configuration options and how to change them
- Tool documentation: Details about built-in tools and their configuration

### Example questions

```bash
> What experimental features does Kiro CLI have?
> Can Kiro CLI read and write files?
> How do I configure MCP servers?
> What settings are available?

```

### Configuration

Enable automatic [tangent mode](/docs/cli/experimental/tangent-mode) for introspect questions to keep help conversations separate from your main work:

```bash
kiro-cli settings set introspect.tangentMode true

```

Be explicit when asking about Kiro CLI — ask "How does Kiro CLI handle files?" rather than "How do you handle files?" for more accurate responses. Despite safeguards, the AI may occasionally provide inaccurate information, so always verify important details using the documentation links provided in responses.

## Code intelligence

**Tool name**: `code`

**Description**: Provides code intelligence capabilities including symbol search, LSP integration, and pattern-based code search and rewriting.

```bash
> Find the UserRepository class

Searching for symbols matching: "UserRepository" (using tool: code)

 ✓ Found 1 match
 - Completed in 0.45s

> Found:
  Class UserRepository at src/repositories/user.repository.ts:15:1

```

For comprehensive documentation on code intelligence features, see [Code Intelligence](/docs/cli/code-intelligence).

This tool has no configuration options.

## Delegate tasks

**Tool name**: `delegate`

**Description**: Delegate tasks to background agents that run asynchronously. Useful for long-running tasks that don't need immediate results.

```bash
> Analyze all TypeScript files for potential bugs and create a report

Delegating task to background agent (using tool: delegate)

 ✓ Task delegated successfully
 - Agent ID: agent-abc123
 - Check status with /delegate status

> I've started analyzing your TypeScript files in the background. 
  Use /delegate status to check progress.

```

This tool has no configuration options.

## Submit an issue or feature request

**Tool name**: `report`

**Description**: Opens the browser to a pre-filled GitHub issue template to report chat issues, bugs, or feature requests.

This tool has no configuration options.

## Knowledge tool (experimental)

**Tool name**: `knowledge`

**Description**: Store and retrieve information in a knowledge base across chat sessions. Provides semantic search capabilities for files, directories, and text content.

This tool has no configuration options.

## Thinking tool (experimental)

**Tool name**: `thinking`

**Description**: An internal reasoning mechanism that improves the quality of complex tasks by breaking them down into atomic actions.

This tool has no configuration options.

## ToDo list tool (experimental)

**Tool name**: `todo`

**Description**:

Create and manage ToDo lists for tracking multi-step tasks.

This tool has no configuration options.

## Subagent tool

**Tool name**: `use_subagent`

**Description**: Delegate complex tasks to specialized subagents that run in parallel with isolated context. Useful for breaking down multi-step tasks into parallel subtasks, preventing context window bloat, running independent research simultaneously, or delegating to different agent configurations.

This tool is included in the default agent. For custom agents, you need to explicitly add `use_subagent` to your `tools` array or include it via the `@builtin` sigil.

**Features:**

- Spawn up to 4 subagents simultaneously for parallel task execution
- Each subagent operates with its own isolated context to prevent main conversation bloat
- Real-time visual indicator showing status of all running subagents
- Support for different agent configurations per subagent
- Automatic execution summary with tool usage and duration metrics

### Configuration

The `use_subagent` tool itself has no configurable `toolsSettings`. However, subagents can use different agent configurations:

- Default subagent: Uses the built-in default agent configuration
- Custom subagents: Can reference custom agent configurations by name when delegating tasks

The subagent inherits its tool access, permissions, and behavior from whichever agent configuration it's assigned to use.

### Example workflow

```bash
> Research the top 3 JavaScript frameworks and compare their performance

# Main agent spawns 3 subagents:
# - Subagent 1: Research React performance metrics
# - Subagent 2: Research Vue.js performance metrics
# - Subagent 3: Research Angular performance metrics

# Each subagent:
# - Conducts independent research
# - Gathers relevant data
# - Calls summary tool with findings

# Main agent receives all summaries and synthesizes comparison

```

For details on how subagents work and best practices, see [Subagents](/docs/cli/chat/subagents).

## Using tool settings in agent configuration

Tool settings are specified in the `toolsSettings` section of the agent configuration file. Each tool's settings are specified using the tool's name as the key.

For MCP server tools, use the format `@server_name/tool_name` as the key:

```json
{
  "toolsSettings": {
    "write": {
      "allowedPaths": ["~/projects"]
    },
    "@git/git_status": {
      "git_user": "$GIT_USER"
    }
  }
}

```

## Tool permissions

Tools can be explicitly allowed in the `allowedTools` section of the agent configuration:

```json
{
  "allowedTools": [
    "read",
    "knowledge",
    "@git/git_status"
  ]
}

```

If a tool is not in the `allowedTools` list, the user will be prompted for permission when the tool is used unless an allowed `toolSettings` configuration is set.

Some tools have default permission behaviors:

- report is trusted by default
- read, grep, and glob are trusted in the current working directory
- shell, write, and aws prompt for permission by default, but can be configured to allow specific commands/paths/services

## Next steps

- Agent Integration - Use tools with custom agents
- MCP Integration - Connect external tools via MCP
- Settings - Configure tool preferences
- Troubleshooting - Common tool issues

### Chat - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Chat

---

The Kiro CLI provides an interactive chat mode that lets you have natural conversations with AI directly in your terminal. This feature brings the power of conversational AI to your command-line workflow.

## Starting a session

To start a chat session

```bash
kiro-cli

```

Or start a chat with a specific context:

```bash
kiro-cli --agent myagent

```

## Entering multi-line statements

To enter multi-line statements, use the `/editor` command or type `Ctrl(^) + J` to insert new-line for multi-line prompt

```bash
/editor

```

This opens your default editor (defaults to vi) where you can compose longer, multi-line prompts. After you save and close the editor, the content will be sent as your message to Kiro.

You can also:

- Use the /reply command to open your editor with the most recent assistant message quoted for reply, which is useful for multi-line responses to previous messages.

## Conversation persistence

Kiro can remember your conversations based on the folder where you started them. When you start a session where you previously chatted with Kiro, you can tell Kiro to automatically load that conversation history, allowing you to seamlessly continue your discussion.

### Directory-based persistence

If it's your first time chatting in that directory, Kiro will start a new conversation (taking into consideration any designated context).

To explicitly resume a conversation in the current directory, use:

```bash
$ kiro-cli chat --resume

```

To open an interactive session picker to choose from previous sessions:

```bash
$ kiro-cli chat --resume-picker

```

### Manually saving and loading conversations

You can also manually save and load conversations using the following commands while in a chat session:

```bash
    /chat save [path] – Saves your current conversation to a JSON file.

        Add -f or --force to overwrite an existing file

        Examples:

        /chat save ./my-project-conversation -f

        /chat save /home/user/project/my-project-conversation.json

        You cannot use ~ to denote your home directory.

    /chat load [path] – Loads a conversation from a previously saved JSON file

        Example: /chat load ./my-project-conversation.json

```

The `/chat save` and `/chat load` commands operate independently of the directory where the conversation was originally created. When loading a conversation, be mindful that it will replace your current conversation regardless of which directory it was saved from.

### Checkpointing - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Checkpointing

---

Checkpointing enables session-scoped snapshots for tracking file changes using Git-like commands. This feature creates a shadow bare git repository to manage file state across your chat session.

## Overview

Checkpointing provides version control for your chat session, allowing you to:

- Create snapshots of file changes at any point
- Compare different states of your files
- Restore to previous checkpoints
- Track what changed during each turn of conversation

## Enabling checkpointing

```bash
kiro-cli settings chat.enableCheckpoint true

```

Or use the experiment command:

```bash
/experiment
# Select "Checkpointing" from the list

```

## How it works

### Automatic initialization

- In git repositories: Auto-enables when you start a chat session
- Non-git directories: Requires manual initialization with /checkpoint init
- Session-scoped: Shadow repository is cleaned up when session ends

### Shadow repository

Checkpointing creates a temporary bare git repository that:

- Tracks file changes without affecting your actual git repo
- Stores snapshots for each turn of conversation
- Allows comparison and restoration of file states
- Is automatically cleaned up when the session ends

## Commands

### /checkpoint init

Manually enable checkpoints (required if not in a git repository):

```bash
/checkpoint init

```

### /checkpoint list

Show turn-level checkpoints with file statistics:

```bash
/checkpoint list [--limit N]

```

**Example output:**

```
[0] 2025-09-18 14:00:00 - Initial checkpoint
[1] 2025-09-18 14:05:31 - add two_sum.py (+1 file)
[2] 2025-09-18 14:07:10 - add tests (modified 1)
[3] 2025-09-18 14:10:45 - refactor algorithm (modified 1)

```

### /checkpoint expand

Show tool-level checkpoints under a specific turn:

```bash
/checkpoint expand <tag>

```

**Example:**

```
> /checkpoint expand 2

[2] 2025-09-18 14:07:10 - add tests
 └─ [2.1] write: Add minimal test cases to two_sum.py (modified 1)

```

### /checkpoint diff

Compare checkpoints or compare with current state:

```bash
/checkpoint diff <tag1> [tag2|HEAD]

```

**Examples:**

```bash
/checkpoint diff 1 2        # Compare checkpoint 1 to checkpoint 2
/checkpoint diff 1 HEAD     # Compare checkpoint 1 to current state
/checkpoint diff 1          # Same as above (HEAD is default)

```

### /checkpoint restore

Restore to a checkpoint:

```bash
/checkpoint restore [<tag>] [--hard]

```

**Interactive picker**: If no tag specified, shows interactive selection

**Restore options:**

- Default: Reverts tracked changes and deletions; keeps files created after checkpoint
- --hard: Makes workspace exactly match checkpoint; deletes tracked files created after it

**Examples:**

```bash
/checkpoint restore 2       # Restore to checkpoint 2 (soft)
/checkpoint restore 2 --hard # Restore to checkpoint 2 (hard)
/checkpoint restore         # Interactive selection

```

### /checkpoint clean

Delete the session shadow repository:

```bash
/checkpoint clean

```

**Warning**: This removes all checkpoint data for the current session.

## Restore modes

### Default restore (soft)

Reverts tracked changes and deletions but keeps new files:

```bash
/checkpoint restore 2

```

**What happens:**

- Modified files are reverted to checkpoint state
- Deleted files are restored
- Files created after checkpoint are kept

**Use when:**

- You want to undo changes but keep new work
- Testing different approaches
- Reverting specific modifications

### Hard restore

Makes workspace exactly match checkpoint state:

```bash
/checkpoint restore 2 --hard

```

**What happens:**

- Modified files are reverted to checkpoint state
- Deleted files are restored
- Files created after checkpoint are deleted

**Use when:**

- You want exact checkpoint state
- Completely abandoning recent work
- Starting fresh from a known good state

**⚠️ Warning**: Hard restore permanently deletes files. Use with caution.

## Use cases

### Experimenting with changes

```
> Help me refactor this function

# Kiro makes changes...

> /checkpoint list
[0] Initial checkpoint
[1] Refactored function (modified 1)

> Actually, let's try a different approach

> /checkpoint restore 0
# Back to original state

> Now try using a different pattern...

```

### Comparing approaches

```
> Implement feature A

# Implementation complete

> /checkpoint list
[1] Implemented feature A (modified 2)

> Now show me an alternative implementation

# Alternative implementation

> /checkpoint list
[2] Alternative implementation (modified 2)

> /checkpoint diff 1 2
# See differences between approaches

```

### Tracking progress

```
> /checkpoint list
[0] Initial state
[1] Added user model (+1 file)
[2] Added authentication (+2 files)
[3] Added tests (modified 3)

> /checkpoint expand 2
[2] Added authentication
 └─ [2.1] write: Create auth.py (+1 file)
 └─ [2.2] write: Update routes.py (modified 1)

```

### Recovering from mistakes

```
> /checkpoint list
[0] Working code
[1] Attempted optimization (modified 1)
[2] More changes (modified 2)

# Realize the optimization broke things

> /checkpoint restore 0
# Back to working state

```

## Conversation history

When you restore to a checkpoint, the conversation history also unwinds to that point. This means:

- Messages after the checkpoint are removed
- Context returns to the checkpoint state
- Kiro's understanding resets to that point

This ensures consistency between file state and conversation context.

## Best practices

### When to use checkpointing

- Experimental changes: Try different approaches safely
- Complex refactoring: Track each step of major changes
- Learning: Compare different implementations
- Debugging: Isolate when problems were introduced

### Checkpoint management

- Review checkpoints regularly: Use /checkpoint list to see progress
- Use descriptive changes: Kiro's checkpoint messages help identify states
- Clean up when done: Use /checkpoint clean to remove session data
- Be cautious with --hard: Only use when you're sure

### Workflow integration

1. Enable at session start: Turn on for complex work
2. Check progress: Use /checkpoint list periodically
3. Compare approaches: Use /checkpoint diff to see changes
4. Restore when needed: Go back to known good states
5. Clean up: Remove shadow repo when session ends

## Limitations

### Session scope

- Checkpoints only exist for current session
- Shadow repository is cleaned up when session ends
- Cannot share checkpoints across sessions

### File tracking

- Only tracks files modified during session
- Doesn't track files outside working directory
- Binary files are tracked but diffs may not be useful

### Performance

- Large files may slow down checkpoint operations
- Many checkpoints can consume disk space
- Diff operations on large changes may be slow

## Troubleshooting

### Checkpointing not working

1. Verify it's enabled:
bashkiro-cli settings chat.enableCheckpoint
2. Initialize manually (if not in git repo):
bash/checkpoint init
3. Check for errors: Look for error messages in chat

### Cannot restore checkpoint

1. Verify checkpoint exists:
bash/checkpoint list
2. Check file permissions: Ensure write access to files
3. Try soft restore first: Use default restore before --hard

### Shadow repository issues

If shadow repository becomes corrupted:

1. Clean and reinitialize:
bash/checkpoint clean
/checkpoint init
2. Restart session: Start a new chat session

## Important notes

⚠️ **Checkpointing creates temporary git repositories** that are cleaned up when the session ends.

⚠️ **Use caution with --hard restore** as it permanently deletes files.

⚠️ **Checkpoints are session-scoped** and don't persist across sessions.

⚠️ **Conversation history unwinds** when restoring to maintain consistency.

## Related features

- Experimental Features
- Tangent Mode - Conversation checkpoints
- TODO Lists - Task tracking

## Next steps

- Enable other experimental features
- Learn about custom agents
- Configure settings

### Get started - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Get started

---

The Kiro CLI brings the power of AI-assisted development to your terminal. Build, test, and deploy applications using natural language commands and automated workflows.

Get started with the Kiro CLI in minutes. Install on macOS and Linux:

Start using Kiro CLI:

```bash
cd my-project
kiro-cli

```

## Core features

## Use cases

The Kiro CLI is perfect for:

- Interactive Development: Chat with Kiro directly in your terminal for instant help
- Custom Automation: Create specialized agents for your specific workflows
- Team Standardization: Use team level best practises and preferences
- External Integrations: Connect tools and services through MCP servers
- Intelligent Assistance: Get context-aware suggestions and auto-completion
- Workflow Optimization: Automate repetitive tasks with smart hooks

## What's next?

### Ready to get started?

Install the CLI and create your first project in under 5 minutes.

### CLI commands - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# CLI commands

---

This page provides a comprehensive reference for all Kiro CLI commands and their arguments.

## Global arguments

These arguments work with any Kiro CLI command:

| Argument | Short | Description |
| --- | --- | --- |
| --verbose | -v | Increase logging verbosity (can be repeated: -v, -vv, -vvv) |
| --agent | -v | Start a conversation using a specific custom agent configuration |
| --help | -h | Show help information |
| --version | -V | Show version information |
| --help-all |  | Print help for all subcommands |

## Commands

### kiro-cli agent

Manage agent configurations.

**Syntax:**

```bash
kiro-cli agent [SUBCOMMAND] [OPTIONS]

```

**Subcommands:**

| Subcommand | Description |
| --- | --- |
| list | List the available agents |
| create | Create an agent config |
| edit | Edit an existing agent config |
| validate | Validate a config with the given path |
| migrate | Migrate profiles to agents (potentially destructive to existing agents) |
| set-default | Define a default agent to use when starting a session |

**Examples:**

```bash
kiro-cli agent list
kiro-cli agent create my-agent
kiro-cli agent edit my-agent
kiro-cli agent validate ./my-agent.json
kiro-cli agent set-default my-agent

```

### kiro-cli chat

Start an interactive chat session with Kiro. When no subcommand is specified, `kiro` defaults to `kiro-cli chat`.

**Syntax:**

```bash
kiro-cli chat [OPTIONS] [INPUT]

```

**Arguments:**

| Argument | Description |
| --- | --- |
| --no-interactive | Print first response to STDOUT without interactive mode |
| --resume / -r | Resume the previous conversation from this directory |
| --resume-picker | Open interactive session picker to choose which session to resume |
| --list-sessions | List all saved chat sessions for the current directory |
| --delete-session <ID> | Delete a saved chat session by ID |
| --agent | Specify which agent to use |
| --trust-all-tools | Allow the model to use any tool without confirmation |
| --trust-tools | Trust only specified tools (comma-separated list) |
| --require-mcp-startup | Exit with code 3 if any MCP server fails to start |
| --wrap | Line wrapping mode: always, never, or auto (default) |
| INPUT | The first question to ask (positional argument) |

**Examples:**

```bash
# Start interactive chat
kiro-cli 

# Ask a question directly
kiro-cli chat "How do I list files in Linux?"

# Non-interactive mode with trusted tools
kiro-cli chat --no-interactive --trust-all-tools "Show me the current directory"

# Resume previous conversation
kiro-cli chat --resume

# Open session picker to choose which session to resume
kiro-cli chat --resume-picker

# List all saved sessions
kiro-cli chat --list-sessions

# Use specific agent
kiro-cli chat --agent my-agent "Help me with AWS CLI"

```

### kiro-cli translate

Translate natural language instructions to executable shell commands using AI.

**Syntax:**

```bash
kiro-cli translate [OPTIONS] [INPUT...]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --n | -n | Number of completions to generate (max 5) |
| INPUT |  | Natural language description (positional arguments) |

**Examples:**

```bash
kiro-cli translate "list all files in the current directory"
kiro-cli translate "find all Python files modified in the last week"
kiro-cli translate "compress all log files older than 30 days"
kiro-cli translate -n 3 "search for text in files"

```

### kiro-cli doctor

Diagnose and fix common installation and configuration issues.

**Syntax:**

```bash
kiro-cli doctor [OPTIONS]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --all | -a | Run all diagnostic tests without fixes |
| --strict | -s | Error on warnings |
| --format | -f | Output format: plain, json, json-pretty |

**Examples:**

```bash
kiro-cli doctor
kiro-cli doctor --all
kiro-cli doctor --strict

```

### kiro-cli update

Update Kiro CLI to the latest version.

**Syntax:**

```bash
kiro-cli update [OPTIONS]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --non-interactive | -y | Don't prompt for confirmation |
| --relaunch-dashboard |  | Relaunch dashboard after update (default: true) |

**Examples:**

```bash
kiro-cli update
kiro-cli update --non-interactive

```

### kiro-cli theme

Get or set the visual theme for the autocomplete dropdown menu.

**Syntax:**

```bash
kiro-cli theme [OPTIONS] [THEME]

```

**Arguments:**

| Argument | Description |
| --- | --- |
| --list | List all available themes |
| --folder | Show the theme directory path |
| THEME | Theme name: dark, light, system |

**Examples:**

```bash
kiro-cli theme --list
kiro-cli theme dark
kiro-cli theme light
kiro-cli theme system

```

### kiro-cli integrations

Manage system integrations for Kiro.

**Syntax:**

```bash
kiro-cli integrations [SUBCOMMAND] [OPTIONS]

```

**Subcommands:**

| Subcommand | Description |
| --- | --- |
| install | Install an integration |
| uninstall | Uninstall an integration |
| reinstall | Reinstall an integration |
| status | Check integration status |

**Options:**

- --silent / -s: Suppress status messages
- --format / -f: Output format (for status command)

**Examples:**

```bash
kiro-cli integrations install
kiro-cli integrations status
kiro-cli integrations uninstall --silent

```

### kiro-cli inline

Manage inline suggestions (ghost text) that appear as you type.

**Syntax:**

```bash
kiro-cli inline [SUBCOMMAND] [OPTIONS]

```

**Subcommands:**

| Subcommand | Description |
| --- | --- |
| enable | Enable inline suggestions |
| disable | Disable inline suggestions |
| status | Show current status |
| set-customization | Select a customization model |
| show-customizations | Show available customizations |

**Examples:**

```bash
kiro-cli inline enable
kiro-cli inline disable
kiro-cli inline status
kiro-cli inline set-customization
kiro-cli inline show-customizations --format json

```

### kiro-cli login

Authenticate with Kiro.

**Syntax:**

```bash
kiro-cli login [OPTIONS]

```

**Arguments:**

| Argument | Description |
| --- | --- |
| --use-device-flow | Use OAuth device flow for authentication |

**Examples:**

```bash
kiro-cli login
kiro-cli login --use-device-flow

```

### kiro-cli logout

Sign out of your kiro-cli session.

**Syntax:**

```bash
kiro-cli logout

```

### kiro-cli whoami

Display information about the current user and authentication status, including your email address for Builder ID, IAM Identity Center, and Social login types.

**Syntax:**

```bash
kiro-cli whoami [OPTIONS]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --format | -f | Output format: plain, json, json-pretty |

**Examples:**

```bash
kiro-cli whoami
# Logged in with Builder ID
# Email: user@example.com

kiro-cli whoami --format json

```

### kiro-cli settings

Manage kiro-cli configuration settings.

**Syntax:**

```bash
kiro-cli settings [SUBCOMMAND] [OPTIONS] [KEY] [VALUE]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --delete | -d | Delete a setting |
| --format | -f | Output format: plain, json, json-pretty |
| KEY |  | Setting key (positional) |
| VALUE |  | Setting value (positional) |

**Subcommands:**

| Subcommand | Description |
| --- | --- |
| open | Open settings file in default editor |
| list | List configured settings |
| list --all | List all available settings with descriptions |

**Examples:**

```bash
# View all settings
kiro-cli settings list

# View all available settings
kiro-cli settings list --all

# Get a specific setting
kiro-cli settings telemetry.enabled

# Set a setting
kiro-cli settings telemetry.enabled true

# Delete a setting
kiro-cli settings --delete chat.defaultModel

# Open settings file
kiro-cli settings open

# JSON output
kiro-cli settings list --format json-pretty

```

### kiro-cli diagnostic

Run diagnostic tests to troubleshoot issues.

**Syntax:**

```bash
kiro-cli diagnostic [OPTIONS]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --format | -f | Output format: plain, json, json-pretty |
| --force |  | Force limited diagnostic output |

### kiro-cli issue

Create a GitHub issue for feedback or bug reports.

**Syntax:**

```bash
kiro-cli issue [OPTIONS] [DESCRIPTION...]

```

**Arguments:**

| Argument | Short | Description |
| --- | --- | --- |
| --force | -f | Force issue creation |
| DESCRIPTION |  | Issue description (positional) |

**Examples:**

```bash
kiro-cli issue
kiro-cli issue "Autocomplete not working in zsh"

```

### kiro-cli version

Display version information and changelog.

**Syntax:**

```bash
kiro-cli version [OPTIONS]

```

**Arguments:**

| Argument | Description |
| --- | --- |
| --changelog | Show changelog for current version |
| --changelog=all | Show changelog for all versions |
| --changelog=x.x.x | Show changelog for specific version |

**Examples:**

```bash
kiro-cli version
kiro-cli version --changelog
kiro-cli version --changelog=all
kiro-cli version --changelog=1.5.0

```

### kiro-cli mcp

Manage Model Context Protocol (MCP) servers.

**Syntax:**

```bash
kiro-cli mcp [SUBCOMMAND] [OPTIONS]

```

**Subcommands:**

#### kiro-cli mcp add

Add or replace a configured MCP server.

**Arguments:**

| Argument | Description |
| --- | --- |
| --name | Server name (required) |
| --command | Launch command (required) |
| --scope | Scope: workspace or global |
| --env | Environment variables: key1=value1,key2=value2 |
| --timeout | Launch timeout in milliseconds |
| --force | Overwrite existing server |

**Example:**

```bash
kiro-cli mcp add --name my-server --command "node server.js" --scope workspace

```

#### kiro-cli mcp remove

Remove an MCP server.

**Arguments:**

| Argument | Description |
| --- | --- |
| --name | Server name (required) |
| --scope | Scope: workspace or global |

**Example:**

```bash
kiro-cli mcp remove --name my-server --scope workspace

```

#### kiro-cli mcp list

List configured MCP servers.

**Syntax:**

```bash
kiro-cli mcp list [SCOPE]

```

**Example:**

```bash
kiro-cli mcp list
kiro-cli mcp list workspace
kiro-cli mcp list global

```

#### kiro-cli mcp import

Import server configuration from a file.

**Arguments:**

| Argument | Description |
| --- | --- |
| --file | Configuration file (required) |
| --force | Overwrite existing servers |
| SCOPE | Scope: workspace or global |

**Example:**

```bash
kiro-cli mcp import --file config.json workspace

```

#### kiro-cli mcp status

Get the status of an MCP server.

**Arguments:**

| Argument | Description |
| --- | --- |
| --name | Server name (required) |

**Example:**

```bash
kiro-cli mcp status --name my-server

```

## Session management

Kiro CLI automatically saves all chat sessions on every conversation turn. You can resume from any previous chat session at any time.

### From the command line

```bash
# Resume the most recent chat session
kiro-cli chat --resume

# Interactively pick a chat session to resume
kiro-cli chat --resume-picker

# List all saved chat sessions for the current directory
kiro-cli chat --list-sessions

# Delete a saved chat session
kiro-cli chat --delete-session <SESSION_ID>

```

### From within a chat session

Use the `/chat` command to manage sessions:

```bash
# Resume a chat session (interactive selector)
/chat resume

# Save current session to a file
/chat save <FILE_PATH>

# Load a session from a file
/chat load <FILE_PATH>

```

The `.json` extension is optional when loading - Kiro will try both with and without the extension.

### Custom session storage

You can use custom scripts to control where chat sessions are saved to and loaded from. This allows you to store sessions in version control systems, cloud storage, databases, or any custom location.

```bash
# Save session via custom script (receives JSON via stdin)
/chat save-via-script <SCRIPT_PATH>

# Load session via custom script (outputs JSON to stdout)
/chat load-via-script <SCRIPT_PATH>

```

**Tips:**

- Session IDs are UUIDs that uniquely identify each chat session
- Sessions are stored per directory, so each project has its own set of sessions
- The most recently updated sessions appear first in the list

## Log files

Kiro CLI maintains log files for troubleshooting:

**Locations:**

- macOS: $TMPDIR/kiro-log/
- Linux: $XDG_RUNTIME_DIR or /tmp/kiro-log/

**Log Levels:**

Set via `KIRO_LOG_LEVEL` environment variable:

- error: Only errors (default)
- warn: Warnings and errors
- info: Info, warnings, and errors
- debug: Debug info and above
- trace: All messages including detailed traces

**Example:**

```bash
# Enable debug logging
export KIRO_LOG_LEVEL=debug
kiro-cli chat

# For fish shell
set -x KIRO_LOG_LEVEL debug
kiro-cli chat

```

**Warning:** Log files may contain sensitive information including file paths, code snippets, and command outputs. Be cautious when sharing logs.

## Next steps

- Slash Commands Reference
- Settings Configuration
- Troubleshooting Guide

### Code Intelligence - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Code Intelligence

---

Code Intelligence provides two complementary layers of code understanding:

**Tree-sitter (Built-in)** - Out-of-the-box code intelligence for 18 languages. Search symbols with fuzzy matching, get document symbols, and lookup definitions without installing an LSP. With incremental loading and support for millions of tokens of indexed content, agents can efficiently search large codebases.

**LSP Integration (Optional)** - Enhanced precision with find references, go to definition, hover documentation, rename refactoring, and diagnostics. Requires language server installation.

## Supported Languages

Bash, C, C++, C#, Elixir, Go, Java, JavaScript, Kotlin, Lua, PHP, Python, Ruby, Rust, Scala, Swift, TSX, TypeScript

## Built-in Features

Code Intelligence provides these operations (no LSP required):

- Symbol search - Find functions, classes, methods by name (fuzzy matching)
- Document symbols - List all symbols in a file
- Symbol lookup - Look up specific symbols by exact name
- Pattern search - AST-based structural code search
- Pattern rewrite - Automated code transformations using AST patterns
- Codebase overview - High-level codebase structure overview
- Codebase map - Explore directory structure and understand code organization

With LSP enabled (optional), additional operations become available:

- Find references - Locate all usages of a symbol at a position
- Go to definition - Navigate to where a symbol is defined
- Rename symbol - Rename symbols across the codebase
- Get diagnostics - Get errors and warnings for a file
- Hover documentation - Get type information and documentation at position
- Completions - Get completion suggestions at position

## Codebase Overview

Get a complete overview of any workspace in seconds:

```bash
/code overview

```

Specify a path to focus on a specific directory:

```bash
/code overview ./src/components

```

Use `--silent` for a cleaner output when diving deep into a package:

```bash
/code overview --silent

```

Ideal for:

- Onboarding to new codebases
- Q&A sessions about project structure
- Understanding unfamiliar packages quickly

## Documentation Generation

Generate documentation for your codebase with an interactive session:

```bash
/code summary

```

This starts an interactive session where you can choose the output format:

- AGENTS.md - Documentation for AI agents working with your codebase
- README.md - Standard project documentation
- CONTRIBUTING.md - Contributor guidelines

The generated documentation is based on analysis of your codebase structure, dependencies, and code patterns.

## Pattern Search & Rewrite

AST-based structural code search and transformation. Find and modify code by structure, not just text.

### Metavariables

- $VAR - Matches single node (identifier, expression)
- $$$ - Matches zero or more nodes (statements, parameters)

### Pattern Search Examples

```javascript
// Find all console.log calls
pattern: console.log($ARG)
language: javascript

// Find all async functions
pattern: async function $NAME($$$PARAMS) { $$$ }
language: typescript

// Find all .unwrap() calls
pattern: $E.unwrap()
language: rust

```

### Pattern Rewrite Examples

```javascript
// Convert var to const
pattern: var $N = $V
replacement: const $N = $V
language: javascript

// Modernize hasOwnProperty
pattern: $O.hasOwnProperty($P)
replacement: Object.hasOwn($O, $P)
language: javascript

// Convert unwrap to expect
pattern: $E.unwrap()
replacement: $E.expect("unexpected None")
language: rust

```

### Rewrite Workflow

1. Use pattern_search first to verify matches
2. Review matches to ensure correctness
3. Run pattern_rewrite with dry_run: true to preview
4. Apply changes with dry_run: false

## LSP Integration (Optional)

Code intelligence is configured per workspace, not globally. Each project maintains its own LSP settings independently.

Run `/code init` to unlock full LSP-powered code intelligence with enhanced features like find references, hover documentation, and rename refactoring.

### How it works

Kiro CLI spawns LSP server processes in the background that communicate via JSON-RPC over stdio. When you initialize a workspace, it detects languages from project markers (like `package.json`, `Cargo.toml`) and file extensions, then starts the appropriate language servers. These servers continuously analyze your code and maintain an index of symbols, types, and references. When you make queries, Kiro translates your natural language into LSP protocol requests, sends them to the relevant server, and formats the responses back into readable output.

### Installing Language Servers

Default LSP configurations are included for: C/C++, Go, Java, Kotlin, Python, Ruby, Rust, TypeScript/JavaScript

**TypeScript/JavaScript**

```bash
npm install -g typescript-language-server typescript

```

**Rust**

```bash
rustup component add rust-analyzer

```

**Python**

```bash
pip install pyright
# or with pipx (recommended for isolation)
pipx install pyright

```

**Go**

```bash
go install golang.org/x/tools/gopls@latest

```

**Java**

```bash
# macOS
brew install jdtls

# Linux - download from https://download.eclipse.org/jdtls/snapshots/
# Extract and add to PATH

```

**Ruby**

```bash
gem install solargraph

```

**C/C++**

```bash
# macOS
brew install llvm
# or
brew install clangd

# Linux (Debian/Ubuntu)
sudo apt install clangd

# Linux (Arch)
sudo pacman -S clang

```

**Kotlin**

```bash
brew install kotlin-language-server

```

### Initialize LSP

Run this slash command in your project root:

```
/code init

```

This creates `lsp.json` configuration and starts language servers.

What you'll see:

```
✓ Workspace initialization started

Workspace: /path/to/your/project
Detected Languages: ["python", "rust", "typescript"]
Project Markers: ["Cargo.toml", "package.json"]

Available LSPs:
○ clangd (cpp) - available
○ gopls (go) - not installed
◐ jdtls (java) - initializing...
✓ pyright (python) - initialized (687ms)
✓ rust-analyzer (rust) - initialized (488ms)
○ solargraph (ruby) - not installed
✓ typescript-language-server (typescript) - initialized (214ms)

```

**Status indicators:**

- ✓ - Initialized and ready
- ◐ - Currently initializing
- ○ available - Installed but not needed for detected languages
- ○ not installed - Not installed on your system

**Restart LSP servers:** If language servers shut down or become unresponsive, use `/code init -f`.

**Auto-initialization:** After the first `/code init`, Kiro CLI automatically initializes code intelligence on startup when `lsp.json` exists in the workspace.

**Disabling code intelligence:** Delete `lsp.json` from your project root to disable. Re-enable anytime with `/code init`.

### Using Language Servers

Language servers provide semantic code intelligence through natural language queries. You can search symbols, navigate definitions, find references, rename across files, get diagnostics, view method documentation, and discover available APIs on classes and objects.

**Find a symbol:**

```
> Find the UserRepository class

Searching for symbols matching: "UserRepository"
  1. Class UserRepository at src/repositories/user.repository.ts:15:1

```

**Find all references:**

```
> Find references of Person class

Finding all references at: auth.ts:42:10
  1. src/auth.ts:42:10 - export function authenticate(...)
  2. src/handlers/login.ts:15:5 - authenticate(credentials)
  3. src/handlers/api.ts:89:12 - await authenticate(token)

```

**Go to definition:**

```
> Find the definition of UserService

src/services/user.service.ts:42:1: export class UserService { ...

```

**Get file symbols:**

```
> What symbols are in auth.service.ts?

Getting symbols from: auth.service.ts
  1. Class AuthService at auth.service.ts:12:1
  2. Function login at auth.service.ts:25:3
  3. Function logout at auth.service.ts:45:3
  4. Function validateToken at auth.service.ts:62:3

```

**Rename with dry run:**

```
> Dry run: rename the method "FetchUser" to "fetchUserData"

Dry run: Would rename 12 occurrences in 5 files

```

**Get diagnostics:**

```
> Get diagnostics for main.ts

  1. Error line 15:10: Cannot find name 'undefined_var'
  2. Warning line 42:5: 'result' is declared but never used

```

**Get hover documentation:**

```
> What's the documentation for the authenticate method in AuthService?

Type: (credentials: Credentials) => Promise<AuthResult>

Documentation: Authenticates a user with the provided credentials.
Returns an AuthResult containing the user token and profile.

@param credentials - User login credentials
@throws AuthenticationError if credentials are invalid

```

**Discover available methods:**

```
> What methods are available on the s3Client instance?

Available completions:
  1. putObject - Function: (params: PutObjectRequest) => Promise<PutObjectOutput>
  2. getObject - Function: (params: GetObjectRequest) => Promise<GetObjectOutput>
  3. deleteObject - Function: (params: DeleteObjectRequest) => Promise<DeleteObjectOutput>
  4. listObjects - Function: (params: ListObjectsRequest) => Promise<ListObjectsOutput>
  5. headObject - Function: (params: HeadObjectRequest) => Promise<HeadObjectOutput>

```

### Custom Language Servers

Add custom language servers by editing `lsp.json` in your project root:

```json
{ 
  "languages": { 
    "mylang": { 
      "name": "my-language-server", 
      "command": "my-lsp-binary", 
      "args": ["--stdio"], 
      "file_extensions": ["mylang", "ml"], 
      "project_patterns": ["mylang.config"], 
      "exclude_patterns": ["**/build/**"], 
      "multi_workspace": false, 
      "initialization_options": { "custom": "options" },
      "request_timeout_secs": 60
    } 
  } 
}

```

**Fields:**

- name: Display name for the language server
- command: Binary/command to execute
- args: Command line arguments (usually ["--stdio"])
- file_extensions: File extensions this server handles
- project_patterns: Files that indicate a project root (e.g., package.json)
- exclude_patterns: Glob patterns to exclude from analysis
- multi_workspace: Set to true if the LSP supports multiple workspace folders (default: false)
- initialization_options: LSP-specific configuration passed during initialization
- request_timeout_secs: Timeout in seconds for LSP requests. Default is 60.

After editing, restart Kiro CLI to load the new configuration.

## Slash Commands

### /code init

Initialize code intelligence in current directory.

### /code init -f

Force re-initialization (restart all LSP servers).

### /code status

Show workspace status and LSP server states.

### /code logs

Display LSP logs for troubleshooting.

```bash
/code logs                    # Show last 20 ERROR logs
/code logs -l INFO            # Show INFO level and above
/code logs -n 50              # Show last 50 entries
/code logs -l DEBUG -n 100    # Show last 100 DEBUG+ logs
/code logs -p ./lsp-logs.json # Export logs to JSON file

```

**Options:**

- -l, --level <LEVEL>: Log level filter (ERROR, WARN, INFO, DEBUG, TRACE). Default: ERROR
- -n, --lines <N>: Number of log lines to display. Default: 20
- -p, --path <PATH>: Export logs to JSON file

## Supported LSP Servers

| Language | Extensions | Server | Install Command |
| --- | --- | --- | --- |
| TypeScript/JavaScript | .ts, .js, .tsx, .jsx | typescript-language-server | npm install -g typescript-language-server typescript |
| Rust | .rs | rust-analyzer | rustup component add rust-analyzer |
| Python | .py | pyright | pip install pyright |
| Go | .go | gopls | go install golang.org/x/tools/gopls@latest |
| Java | .java | jdtls | brew install jdtls (macOS) |
| Ruby | .rb | solargraph | gem install solargraph |
| C/C++ | .c, .cpp, .h, .hpp | clangd | brew install llvm (macOS) or apt install clangd (Linux) |
| Kotlin | .kt, .kts | kotlin-language-server | brew install kotlin-language-server |

## Troubleshooting

| Issue | Cause(s) | Solution |
| --- | --- | --- |
| Code tool is not enabled for this agent | Agent doesn't have the code tool in its tool list | Add "code" to the agent's tools array, or use @builtin to include all built-in tools, or use @builtin/code |
| Workspace is still initializing | LSP servers are starting up | Wait and try again. If servers crashed, use /code init -f to restart |
| LSP initialization failed |  | Check logs for details: /code logs -l ERROR |
| No symbols found | Language server is still indexing or File has syntax errors or Symbol name doesn't match | Check file for errors, try broader search terms |
| No definition found | Position doesn't point to a symbol | Verify the row and column numbers point to a symbol name |

## Best Practices

1. Initialize once per project - Run /code init in project root
2. Use exact positions - Row and column must point to the symbol
3. Use dry_run for renames - Preview changes before applying
4. Check diagnostics first - Syntax errors can prevent analysis
5. Be specific in searches - "UserService" > "user"
6. Ask for documentation naturally - "What does the login method do?" instead of specifying coordinates
7. Discover APIs conversationally - "What methods does s3Client have?" to explore external library functionality

## Limitations

1. LSP feature support varies by language server - not all servers support every operation (e.g., some may not support rename or formatting)
2. Large codebases may have slow initial indexing

### Compliance validation for Kiro - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Compliance validation for Kiro

---

To learn whether an AWS service is within the scope of specific compliance programs, see [AWS services in Scope by Compliance Program](https://aws.amazon.com/compliance/services-in-scope/) and choose the compliance program that you are interested in. For general information, see [AWS Compliance Programs](https://aws.amazon.com/compliance/programs/).

You can download third-party audit reports using AWS Artifact. For more information, see [Downloading Reports in AWS Artifact](https://docs.aws.amazon.com/artifact/latest/ug/downloading-documents.html). If you are signing in to Kiro with GitHub or Google, you will not be able to download third-party audit reports using AWS Artifact.

Your compliance responsibility when using AWS services is determined by the sensitivity of your data, your company's compliance objectives, and applicable laws and regulations. AWS provides the following resources to help with compliance:

- Security Compliance & Governance – These solution implementation guides discuss architectural considerations and provide steps for deploying security and compliance features.
- HIPAA Eligible Services Reference – Lists HIPAA eligible services. Not all AWS services are HIPAA eligible.
- AWS Compliance Resources – This collection of workbooks and guides might apply to your industry and location.
- AWS Customer Compliance Guides in the AWS Config Developer Guide – Understand the shared responsibility model through the lens of compliance. The guides summarize the best practices for securing AWS services and map the guidance to security controls across multiple frameworks (including National Institute of Standards and Technology (NIST), Payment Card Industry Security Standards Council (PCI), and International Organization for Standardization (ISO)).
- Evaluating Resources with Rules – The AWS Config service assesses how well your resource configurations comply with internal practices, industry guidelines, and regulations.
- AWS Security Hub – This AWS service provides a comprehensive view of your security state within AWS. Security Hub uses security controls to evaluate your AWS resources and to check your compliance against security industry standards and best practices. For a list of supported services and controls, see Security Hub controls reference.
- Amazon GuardDuty – This AWS service detects potential threats to your AWS accounts, workloads, containers, and data by monitoring your environment for suspicious and malicious activities. GuardDuty can help you address various compliance requirements, like PCI DSS, by meeting intrusion detection requirements mandated by certain compliance frameworks.
- AWS Audit Manager – This AWS service helps you continuously audit your AWS usage to simplify how you manage risk and compliance with regulations and industry standards.

### Concepts - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Concepts

---

## AWS IAM Identity Center

An AWS service that provides a central place to manage user identities of Kiro subscribers.

## AWS region

A physical location around the world where AWS clusters its data centers. There are two AWS Regions relevant to Kiro administrators:

- The Region where your IAM Identity Center instance is enabled. This is where user identities are managed, and where subscriptions are stored.
- The Region where your Kiro profile is created. This is where data is stored, and might be different from your IAM Identity Center instance's Region.

For more information about Regions, see [Supported Regions](../supported-regions).

## Group

A collection of users within IAM Identity Center. When you subscribe a group to Kiro, the users within it are individually subscribed. (There is no concept of a group subscription.)

## Kiro console

A console within the AWS console where you create and manage Kiro subscriptions and control settings. The Kiro console appears as **Kiro** in the drop-down list of AWS services.

## Kiro credits

A unit of consumption that measures usage of Kiro's AI-powered features. Credits are spent when you interact with AI capabilities and are replenished based on your subscription tier.

## Kiro enterprise user

A user that you have added and subscribed to a Kiro subscription tier through the AWS console, capable of accessing Kiro through IAM Identity Center.

## Kiro profile

The management abstraction that defines and enforces administrative settings and subscriptions to enterprise users in a given AWS account and Region. A Kiro profile corresponds to a combination of an AWS account (management or member) and the Region for that account. This implies that you can only have one profile for each AWS account in a given Region. You set up Kiro profiles through the Kiro console.

## Kiro subscription tier

A distinctive pricing plan with a predetermined number of Kiro credits.

### Configuration - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Configuration

---

This guide provides detailed information on configuring Model Context Protocol (MCP) servers with Kiro CLI, including configuration file structure, server setup, and management.

## Configuration file structure

MCP configuration files use JSON format with the following structure:

```json
{
  "mcpServers": {
    "local-server-name": {
      "command": "command-to-run-server",
      "args": ["arg1", "arg2"],
      "env": {
        "ENV_VAR1": "hard-coded-variable",
        "ENV_VAR2": "${EXPANDED_VARIABLE}"
      },
      "disabled": false,
      "disabledTools": ["tool_name3"]
    },
    "remote-server-name": {
      "url": "https://endpoint.to.connect.to",
      "headers": {
        "HEADER1": "value1",
        "HEADER2": "value2"
      },
      "disabled": false,
      "disabledTools": ["tool_name3"]
    }
  }
}

```

### Configuration properties

#### Local server

| Property | Type | Required | Description |
| --- | --- | --- | --- |
| command | String | Yes | The command to run the MCP server |
| args | Array | Yes | Arguments to pass to the command |
| env | Object | No | Environment variables for the server process |
| disabled | Boolean | No | Whether the server is disabled (default: false) |
| autoApprove | Array | No | Tool names to auto-approve without prompting |
| disabledTools | Array | No | Tool names to omit when calling the Agent |

#### Remote server

| Property | Type | Required | Description |
| --- | --- | --- | --- |
| url | String | Yes | HTTPS endpoint for the remote MCP server (or HTTP endpoint for localhost) |
| headers | Object | No | Headers to pass to the MCP server during connection |
| env | Object | No | Environment variables for the server process |
| disabled | Boolean | No | Whether the server is disabled (default: false) |
| autoApprove | Array | No | Tool names to auto-approve without prompting |
| disabledTools | Array | No | Tool names to omit when calling the Agent |

## Example configurations

### Local server with environment variables

```json
{
  "mcpServers": {
    "web-search": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-bravesearch"
      ],
      "env": {
        "BRAVE_API_KEY": "${BRAVE_API_KEY}"
      }
    }
  }
}

```

### Remote server with headers

```json
{
  "mcpServers": {
    "api-server": {
      "url": "https://api.example.com/mcp",
      "headers": {
        "Authorization": "Bearer ${API_TOKEN}",
        "X-Custom-Header": "value"
      }
    }
  }
}

```

### Multiple servers

```json
{
  "mcpServers": {
    "fetch": {
      "command": "uvx",
      "args": ["mcp-server-fetch"]
    },
    "git": {
      "command": "uvx",
      "args": ["mcp-server-git"],
      "env": {
        "GIT_CONFIG_GLOBAL": "/dev/null"
      }
    },
    "aws-docs": {
      "command": "npx",
      "args": ["-y", "@aws/aws-documentation-mcp-server"]
    }
  }
}

```

## MCP server loading priority

When multiple configurations define the same MCP server, they are loaded based on this hierarchy (highest to lowest priority):

1. Agent Config - mcpServers field in agent JSON
2. Workspace MCP JSON - .kiro/settings/mcp.json
3. Global MCP JSON - ~/.kiro/settings/mcp.json

### Example scenarios

**Complete override:**

```
Agent config:     { "fetch": { command: "fetch-v2" } }
Workspace config: { "fetch": { command: "fetch-v1" } }
Global config:    { "fetch": { command: "fetch-old" } }

Result: Only "fetch-v2" from agent config is used

```

**Additive (different names):**

```
Agent config:     { "fetch": {...} }
Workspace config: { "git": {...} }
Global config:    { "aws": {...} }

Result: All three servers are used (fetch, git, aws)

```

**Disable via override:**

```
Agent config:     { "fetch": { command: "...", disabled: true } }
Workspace config: { "fetch": { command: "..." } }

Result: No fetch server is launched

```

## Environment variables

Many MCP servers require environment variables for authentication or configuration. Use the `${VARIABLE_NAME}` syntax to reference environment variables:

```json
{
  "mcpServers": {
    "server-name": {
      "env": {
        "API_KEY": "${YOUR_API_KEY}",
        "DEBUG": "true",
        "TIMEOUT": "30000"
      }
    }
  }
}

```

Make sure to set these environment variables in your shell before running Kiro CLI:

```bash
export YOUR_API_KEY="your-actual-key"
export DEBUG="true"

```

## Disabling servers

To temporarily disable an MCP server without removing its configuration:

```json
{
  "mcpServers": {
    "server-name": {
      "disabled": true
    }
  }
}

```

## Disabling specific tools

To prevent an agent from using specific tools from an MCP server:

```json
{
  "mcpServers": {
    "server-name": {
      "disabledTools": ["delete_file", "execute_command"]
    }
  }
}

```

## Viewing loaded servers

To see which MCP servers are currently loaded in an interactive chat session:

```bash
/mcp

```

This displays all active MCP servers and their available tools.

## Troubleshooting configuration

1. Validate JSON syntax
  - Ensure your JSON is valid with no syntax errors:
  - Check for missing commas, quotes, or brackets
  - Use a JSON validator or linter
2. Verify command paths
  - Make sure the command specified exists in your PATH
  - Try running the command directly in your terminal
3. Check environment variables
  - Verify that all required environment variables are set
  - Check for typos in environment variable names
4. Review configuration loading

bash# Check workspace config
cat .kiro/settings/mcp.json

# Check user config
cat ~/.kiro/settings/mcp.json
  - Check which configuration files are being loaded and their priority:

## Security considerations

When configuring MCP servers, follow these security best practices:

- Use environment variable references (e.g., ${API_TOKEN}) instead of hardcoding sensitive values
- Never commit configuration files with credentials to version control
- Only connect to trusted remote servers
- Use disabledTools to restrict access to dangerous operations

For comprehensive security guidance, see the [MCP Security Best Practices](/docs/cli/mcp/security) page.

### Agent configuration reference - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Agent configuration reference

---

Every agent configuration file can include the following sections:

- name — The name of the agent (optional, derived from filename if not specified).
- description — A description of the agent.
- prompt — High-level context for the agent.
- mcpServers — The MCP servers the agent has access to.
- tools — The tools available to the agent.
- toolAliases — Tool name remapping for handling naming collisions.
- allowedTools — Tools that can be used without prompting.
- toolsSettings — Configuration for specific tools.
- resources — Resources available to the agent.
- hooks — Commands run at specific trigger points.
- includeMcpJson — Whether to include MCP servers from mcp.json files.
- model — The model ID to use for this agent.
- keyboardShortcut — Keyboard shortcut for quickly switching to this agent.
- welcomeMessage — Message displayed when switching to this agent.

## Name field

The `name` field specifies the name of the agent. This is used for identification and display purposes.

```json
{
  "name": "aws-expert"
}

```

## Description field

The `description` field provides a description of what the agent does. This is primarily for human readability and helps users distinguish between different agents.

```json
{
  "description": "An agent specialized for AWS infrastructure tasks"
}

```

## Prompt field

The `prompt` field is intended to provide high-level context to the agent, similar to a system prompt. It supports both inline text and file:// URIs to reference external files.

### Inline prompt

```json
{
  "prompt": "You are an expert AWS infrastructure specialist"
}

```

### File URI prompt

You can reference external files using `file://` URIs. This allows you to maintain long, complex prompts in separate files for better organization and version control, while keeping your agent configuration clean and readable.

```json
{
  "prompt": "file://./my-agent-prompt.md"
}

```

#### File URI path resolution

- Relative paths: Resolved relative to the agent configuration file's directory
  - "file://./prompt.md" → prompt.md in the same directory as the agent config
  - "file://../shared/prompt.md" → prompt.md in a parent directory
- Absolute paths: Used as-is
  - "file:///home/user/prompts/agent.md" → Absolute path to the file

#### File URI examples

```json
{
  "prompt": "file://./prompts/aws-expert.md"
}

```

```json
{
  "prompt": "file:///Users/developer/shared-prompts/rust-specialist.md"
}

```

## McpServers field

The `mcpServers` field specifies which Model Context Protocol (MCP) servers the agent has access to. Each server is defined with a command and optional arguments.

```json
{
  "mcpServers": {
    "fetch": {
      "command": "fetch3.1",
      "args": []
    },
    "git": {
      "command": "git-mcp",
      "args": [],
      "env": {
        "GIT_CONFIG_GLOBAL": "/dev/null"
      },
      "timeout": 120000
    }
  }
}

```

Each MCP server configuration can include:

- command (required): The command to execute to start the MCP server
- args (optional): Arguments to pass to the command
- env (optional): Environment variables to set for the server
- timeout (optional): Timeout for each MCP request in milliseconds (default: 120000)

## Tools field

The `tools` field lists all tools that the agent can potentially use. Tools include built-in tools and tools from MCP servers.

- Built-in tools are specified by their name (e.g., read, shell)
- MCP server tools are prefixed with @ followed by the server name (e.g., @git)
- To specify a specific tool from an MCP server, use @server_name/tool_name
- Use * as a special wildcard to include all available tools (both built-in and from MCP servers)
- Use @builtin to include all built-in tools
- Use @server_name to include all tools from a specific MCP server

```json
{
  "tools": [
    "read",
    "write",
    "shell",
    "@git",
    "@rust-analyzer/check_code"
  ]
}

```

To include all available tools, you can simply use:

```json
{
  "tools": ["*"]
}

```

## ToolAliases field

The `toolAliases` field is an advanced feature that allows you to remap tool names. This is primarily used to resolve naming collisions between tools from different MCP servers, or to create more intuitive names for specific tools.

For example, if both `@github-mcp` and `@gitlab-mcp` servers provide a tool called `get_issues`, you would have a naming collision. You can use `toolAliases` to disambiguate them:

```json
{
  "toolAliases": {
    "@github-mcp/get_issues": "github_issues",
    "@gitlab-mcp/get_issues": "gitlab_issues"
  }
}

```

With this configuration, the tools will be available to the agent as `github_issues` and `gitlab_issues` instead of having a collision on `get_issues`.

You can also use aliases to create shorter or more intuitive names for frequently used tools:

```json
{
  "toolAliases": {
    "@aws-cloud-formation/deploy_stack_with_parameters": "deploy_cf",
    "@kubernetes-tools/get_pod_logs_with_namespace": "pod_logs"
  }
}

```

The key is the original tool name (including server prefix for MCP tools), and the value is the new name to use.

## AllowedTools field

The `allowedTools` field specifies which tools can be used without prompting the user for permission. This is a security feature that helps prevent unauthorized tool usage.

```json
{
  "allowedTools": [
    "read",
    "write",
    "@git/git_status",
    "@server/read_*",
    "@fetch"
  ]
}

```

You can allow tools using several patterns:

### Exact matches

- Built-in tools: "read", "shell", "knowledge"
- Specific MCP tools: "@server_name/tool_name" (e.g., "@git/git_status")
- All tools from MCP server: "@server_name" (e.g., "@fetch")

### Wildcard patterns

The `allowedTools` field supports glob-style wildcard patterns using `*` and `?`:

#### MCP tool patterns

- Tool prefix: "@server/read_*" → matches @server/read_file, @server/read_config
- Tool suffix: "@server/*_get" → matches @server/issue_get, @server/data_get
- Server pattern: "@*-mcp/read_*" → matches @git-mcp/read_file, @db-mcp/read_data
- Any tool from pattern servers: "@git-*/*" → matches any tool from servers matching git-*

Optionally, you can also prefix native tools with the namespace `@builtin`.

### Examples

```json
{
  "allowedTools": [
    // Exact matches
    "read",
    "knowledge",
    "@server/specific_tool",
    
    // Native tool wildcards
    "r*",                    // Read
    "w*",               // Write
    @builtin,                // All native tools
    
    // MCP tool wildcards
    "@server/api_*",           // All API tools from server
    "@server/read_*",          // All read tools from server
    "@git-server/get_*_info",  // Tools like get_user_info, get_repo_info
    "@*/status",               // Status tool from any server
    
    // Server-level permissions
    "@fetch",                  // All tools from fetch server
    "@git-*"                   // All tools from any git-* server
  ]
}

```

### Pattern matching rules

- * matches any sequence of characters (including none)
- ? matches exactly one character
- Exact matches take precedence over patterns
- Server-level permissions (@server_name) allow all tools from that server
- Case-sensitive matching

Unlike the `tools` field, the `allowedTools` field does not support the `"*"` wildcard for allowing all tools. To allow tools, you must use specific patterns or server-level permissions.

## ToolsSettings field

The `toolsSettings` field provides configuration for specific tools. Each tool can have its own unique configuration options.
Note that specifications that configure allowable patterns will be overridden if the tool is also included in `allowedTools`.

```json
{
  "toolsSettings": {
    "write": {
      "allowedPaths": ["~/**"]
    },
    "@git/git_status": {
      "git_user": "$GIT_USER"
    }
  }
}

```

## Resources field

The `resources` field gives an agent access to local resources. Resources can be files, skills, or knowledge bases.

```json
{
  "resources": [
    "file://README.md",
    "file://.kiro/steering/**/*.md",
    "skill://.kiro/skills/**/SKILL.md"
  ]
}

```

Resources support different types via URI schemes:

- file:// — Files loaded directly into context at startup
- skill:// — Skills with metadata loaded at startup, full content loaded on demand

Both support:

- Specific paths: file://README.md or skill://my-skill.md
- Glob patterns: file://.kiro/**/*.md or skill://.kiro/skills/**/SKILL.md
- Absolute or relative paths

### File resources

File resources are loaded directly into the agent's context when the agent starts. Use these for content the agent always needs.

```json
{
  "resources": [
    "file://README.md",
    "file://docs/**/*.md"
  ]
}

```

### Skill resources

Skills are progressively loaded — only metadata (name and description) is loaded at startup, with full content loaded on demand when the agent determines it's needed. This keeps context lean while giving agents access to extensive documentation.

Skill files must begin with YAML frontmatter containing `name` and `description`:

```markdown
---
name: dynamodb-data-modeling
description: Guide for DynamoDB data modeling best practices. Use when designing or analyzing DynamoDB schema.
---

# DynamoDB Data Modeling

... full content here ...

```

```json
{
  "resources": [
    "skill://.kiro/skills/**/SKILL.md"
  ]
}

```

Write specific descriptions so the agent can reliably determine when to load the full content.

### Knowledge base resources

Knowledge base resources allow agents to search indexed documentation and content. With support for millions of tokens of indexed content and incremental loading, agents can efficiently search large documentation sets.

```json
{
  "resources": [
    {
      "type": "knowledgeBase",
      "source": "file://./docs",
      "name": "ProjectDocs",
      "description": "Project documentation and guides",
      "indexType": "best",
      "autoUpdate": true
    }
  ]
}

```

**Fields:**

| Field | Required | Description |
| --- | --- | --- |
| type | Yes | Must be "knowledgeBase" |
| source | Yes | Path to index. Use file:// prefix for local paths |
| name | Yes | Display name for the knowledge base |
| description | No | Brief description of the content |
| indexType | No | Indexing strategy: "best" (default, higher quality) or "fast" (quicker indexing) |
| autoUpdate | No | Re-index when agent spawns. Default: false |

**Use cases:**

- Share team documentation across agents
- Give agents access to project-specific context (specs, decisions, meeting notes)
- Index large codebases and documentation
- Keep agent knowledge current with autoUpdate: true

## Hooks field

The `hooks` field defines commands to run at specific trigger points during agent lifecycle and tool execution.

For detailed information about hook behavior, input/output formats, and examples, see the [Hooks documentation](/docs/cli/hooks).

```json
{
  "hooks": {
    "agentSpawn": [
      {
        "command": "git status"
      }
    ],
    "userPromptSubmit": [
      {
        "command": "ls -la"
      }
    ],
    "preToolUse": [
      {
        "matcher": "execute_bash",
        "command": "{ echo \"$(date) - Bash command:\"; cat; echo; } >> /tmp/bash_audit_log"
      },
      {
        "matcher": "use_aws",
        "command": "{ echo \"$(date) - AWS CLI call:\"; cat; echo; } >> /tmp/aws_audit_log"
      }
    ],
    "postToolUse": [
      {
        "matcher": "fs_write",
        "command": "cargo fmt --all"
      }
    ]
  }
}

```

Each hook is defined with:

- command (required): The command to execute
- matcher (optional): Pattern to match tool names for preToolUse and postToolUse hooks. Hook matchers use internal tool names (fs_read, fs_write, execute_bash, use_aws) rather than simplified names. See built-in tools documentation for available tool names.

Available hook triggers:

- agentSpawn: Triggered when the agent is initialized.
- userPromptSubmit: Triggered when the user submits a message.
- preToolUse: Triggered before a tool is executed. Can block the tool use.
- postToolUse: Triggered after a tool is executed.
- stop: Triggered when the assistant finishes responding.

## includeMcpJson field

The `includeMcpJson` field determines whether to include MCP servers defined in the MCP configuration files (`~/.kiro/settings/mcp.json` for global and `<cwd>/.kiro/settings/mcp.json` for workspace).

```json
{
  "includeMcpJson": true
}

```

When set to `true`, the agent will have access to all MCP servers defined in the global and local configurations in addition to those defined in the agent's `mcpServers` field.

## Model field

The `model` field specifies the model ID to use for this agent. If not specified, the agent will use the default model.

```json
{
  "model": "claude-sonnet-4"
}

```

The model ID must match one of the available models returned by the Kiro CLI's model service. You can see available models by using the `/model` command in an active chat session.

If the specified model is not available, the agent will fall back to the default model and display a warning.

## KeyboardShortcut field

The `keyboardShortcut` field configures a keyboard shortcut for quickly switching to this agent during a chat session.

```json
{
  "keyboardShortcut": "ctrl+a"
}

```

Shortcuts consist of a modifier and a key, separated by `+`:

**Modifiers** (optional):

- ctrl - Control key
- shift - Shift key

**Keys**:

- Single letter: a-z (case insensitive)
- Single digit: 0-9

**Examples**:

```json
"keyboardShortcut": "ctrl+a"           // Control + A
"keyboardShortcut": "shift+b"          // Shift + B

```

**Toggle Behavior:**

When you press a keyboard shortcut:

- If you're on a different agent: switches to this agent
- If you're already on this agent: switches back to your previous agent

**Conflict Handling:**

If multiple agents have the same keyboard shortcut, a warning is logged and the shortcut is disabled. Use `/agent swap` to switch manually in this case.

## WelcomeMessage field

The `welcomeMessage` field specifies a message displayed when switching to this agent.

```json
{
  "welcomeMessage": "What would you like to build today?"
}

```

This message appears after the agent switch confirmation, helping orient users to the agent's purpose.

## Complete example

Here's a complete example of an agent configuration file:

```json
{
  "name": "aws-rust-agent",
  "description": "A specialized agent for AWS and Rust development tasks",
  "mcpServers": {
    "fetch": {
      "command": "fetch3.1",
      "args": []
    },
    "git": {
      "command": "git-mcp",
      "args": []
    }
  },
  "tools": [
    "read",
    "write",
    "shell",
    "aws",
    "@git",
    "@fetch/fetch_url"
  ],
  "toolAliases": {
    "@git/git_status": "status",
    "@fetch/fetch_url": "get"
  },
  "allowedTools": [
    "read",
    "@git/git_status"
  ],
  "toolsSettings": {
    "write": {
      "allowedPaths": ["src/**", "tests/**", "Cargo.toml"]
    },
    "aws": {
      "allowedServices": ["s3", "lambda"]
    }
  },
  "resources": [
    "file://README.md",
    "file://docs/**/*.md"
  ],
  "hooks": {
    "agentSpawn": [
      {
        "command": "git status"
      }
    ],
    "userPromptSubmit": [
      {
        "command": "ls -la"
      }
    ]
  },
  "useLegacyMcpJson": true,
  "model": "claude-sonnet-4",
  "keyboardShortcut": "ctrl+r",
  "welcomeMessage": "Ready to help with AWS and Rust development!"
}

```

Agent configuration files are JSON files that define how your custom agents behave. The filename (without `.json`) becomes the agent's name.

## Quick start

We recommend using the `/agent generate` command within your active Kiro session to intelligently generate agent configurations with AI assistance.

## File locations

You can define local agents and global agents.

### Local agents (project-specific)

```
.kiro/agents/

```

Local agents are specific to the current workspace and only available when running Kiro CLI from that directory or its subdirectories.

**Example:**

```
my-project/
├── .kiro/
│   └── agents/
│       ├── dev-agent.json
│       └── aws-specialist.json
└── src/
    └── main.py

```

### Global agents (user-wide)

```
~/.kiro/agents/

```

Global agents are available from any directory.

**Example:**

```
~/.kiro/agents/
├── general-assistant.json
├── code-reviewer.json
└── documentation-writer.json

```

### Agent precedence

When Kiro CLI looks for an agent:

1. Local first: Checks .kiro/agents/ in the current directory
2. Global fallback: Checks ~/.kiro/agents/ in the HOME directory

If both locations have agents with the same name, the local agent takes precedence with a warning message.

## Configuration fields

### name

The agent's name for identification and display.

```json
{
  "name": "aws-expert"
}

```

### description

Human-readable description of the agent's purpose.

```json
{
  "description": "An agent specialized for AWS infrastructure tasks"
}

```

### prompt

High-level context for the agent, similar to a system prompt. Supports inline text or `file://` URIs.

**Inline:**

```json
{
  "prompt": "You are an expert AWS infrastructure specialist"
}

```

**File URI:**

```json
{
  "prompt": "file://./my-agent-prompt.md"
}

```

**Path Resolution:**

- Relative paths: Resolved relative to agent config file
  - "file://./prompt.md" → Same directory as agent config
  - "file://../shared/prompt.md" → Parent directory
- Absolute paths: Used as-is
  - "file:///home/user/prompts/agent.md"

### mcpServers

MCP servers the agent can access.

```json
{
  "mcpServers": {
    "fetch": {
      "command": "fetch-server",
      "args": []
    },
    "git": {
      "command": "git-mcp",
      "args": [],
      "env": {
        "GIT_CONFIG_GLOBAL": "/dev/null"
      },
      "timeout": 120000
    }
  }
}

```

**Fields:**

- command (required): Command to start the MCP server
- args (optional): Arguments for the command
- env (optional): Environment variables
- timeout (optional): Request timeout in milliseconds (default: 120000)

### tools

Tools available to the agent.

```json
{
  "tools": [
    "read",
    "write",
    "shell",
    "@git",
    "@rust-analyzer/check_code"
  ]
}

```

**Tool References:**

- Built-in tools: "read", "shell"
- All MCP server tools: "@server_name"
- Specific MCP tool: "@server_name/tool_name"
- All tools: "*"
- All built-in tools: "@builtin"

### toolAliases

Remap tool names to resolve naming collisions or create intuitive names.

```json
{
  "toolAliases": {
    "@github-mcp/get_issues": "github_issues",
    "@gitlab-mcp/get_issues": "gitlab_issues",
    "@aws-cloud-formation/deploy_stack_with_parameters": "deploy_cf"
  }
}

```

### allowedTools

Tools that can be used without prompting for permission.

```json
{
  "allowedTools": [
    "read",
    "@git/git_status",
    "@server/read_*",
    "@fetch"
  ]
}

```

**Pattern Support:**

**Exact Matches:**

- Built-in: "read", "shell"
- MCP tool: "@server_name/tool_name"
- All server tools: "@server_name"

**Wildcards:**

- Prefix: "code_*" → code_review, code_analysis
- Suffix: "*_bash" → execute_bash, run_bash
- Single char: "?ead" → read, head
- MCP patterns: "@server/read_*", "@git-*/status"

### toolsSettings

Configuration for specific tools.

```json
{
  "toolsSettings": {
    "write": {
      "allowedPaths": ["~/**"]
    },
    "shell": {
      "allowedCommands": ["git status", "git fetch"],
      "deniedCommands": ["git commit .*", "git push .*"],
      "autoAllowReadonly": true
    },
    "@git/git_status": {
      "git_user": "$GIT_USER"
    }
  }
}

```

See [Built-in Tools](/docs/cli/reference/built-in-tools) for tool-specific options.

### resources

Local resources available to the agent. Supports file resources, skill resources, and knowledge bases.

**File resources:**

```json
{
  "resources": [
    "file://README.md",
    "file://.kiro/steering/**/*.md",
    "skill://.kiro/skills/**/SKILL.md"
  ]
}

```

**Knowledge base resources:**

```json
{
  "resources": [
    {
      "type": "knowledgeBase",
      "source": "file://./docs",
      "name": "ProjectDocs",
      "description": "Project documentation",
      "indexType": "best",
      "autoUpdate": true
    }
  ]
}

```

Resource types:

- file:// — Loaded into context at startup
- skill:// — Metadata loaded at startup, full content loaded on demand

Both support specific files, glob patterns, and absolute or relative paths.

Knowledge base fields:

- type: Must be "knowledgeBase"
- source: Path to index (use file:// prefix)
- name: Display name
- description: Optional description
- indexType: "best" (default) or "fast"
- autoUpdate: Re-index on agent spawn (default: false)

### hooks

Commands to run at specific trigger points.

```json
{
  "hooks": {
    "agentSpawn": [
      {
        "command": "git status"
      }
    ],
    "userPromptSubmit": [
      {
        "command": "ls -la"
      }
    ],
    "preToolUse": [
      {
        "matcher": "execute_bash",
        "command": "{ echo \"$(date) - Bash:\"; cat; } >> /tmp/audit.log"
      }
    ],
    "postToolUse": [
      {
        "matcher": "fs_write",
        "command": "cargo fmt --all"
      }
    ],
    "stop": [
      {
        "command": "npm test"
      }
    ]
  }
}

```

**Hook Types:**

- agentSpawn: When agent is activated
- userPromptSubmit: When user submits a prompt
- preToolUse: Before tool execution (can block)
- postToolUse: After tool execution
- stop: When assistant finishes responding

See [Hooks](/docs/cli/hooks) for detailed documentation.

### model

Model ID to use for this agent.

```json
{
  "model": "claude-sonnet-4"
}

```

If not specified or unavailable, falls back to default model.

### keyboardShortcut

Keyboard shortcut for quickly switching to this agent.

```json
{
  "keyboardShortcut": "ctrl+a"
}

```

**Format:** `[modifier+]key`

**Modifiers:** `ctrl`, `shift`

**Keys:** `a-z`, `0-9`

**Behavior:**

- Pressing the shortcut switches to this agent
- Pressing again while on this agent switches back to the previous agent
- Conflicting shortcuts are disabled with a warning

### welcomeMessage

Message displayed when switching to this agent.

```json
{
  "welcomeMessage": "What would you like to build today?"
}

```

This message appears after the agent switch confirmation, helping orient users to the agent's purpose.

## Complete example

```json
{
  "name": "aws-rust-agent",
  "description": "Specialized agent for AWS and Rust development",
  "prompt": "file://./prompts/aws-rust-expert.md",
  "mcpServers": {
    "fetch": {
      "command": "fetch-server",
      "args": []
    },
    "git": {
      "command": "git-mcp",
      "args": []
    }
  },
  "tools": [
    "read",
    "write",
    "shell",
    "aws",
    "@git",
    "@fetch/fetch_url"
  ],
  "toolAliases": {
    "@git/git_status": "status",
    "@fetch/fetch_url": "get"
  },
  "allowedTools": [
    "read",
    "@git/git_status"
  ],
  "toolsSettings": {
    "write": {
      "allowedPaths": ["src/**", "tests/**", "Cargo.toml"]
    },
    "aws": {
      "allowedServices": ["s3", "lambda"],
      "autoAllowReadonly": true
    }
  },
  "resources": [
    "file://README.md",
    "file://docs/**/*.md"
  ],
  "hooks": {
    "agentSpawn": [
      {
        "command": "git status"
      }
    ],
    "postToolUse": [
      {
        "matcher": "fs_write",
        "command": "cargo fmt --all"
      }
    ]
  },
  "model": "claude-sonnet-4",
  "keyboardShortcut": "ctrl+shift+r",
  "welcomeMessage": "Ready to help with AWS and Rust development!"
}

```

## Best practices

1. Start restrictive: Begin with minimal tool access and expand as needed
2. Name clearly: Use descriptive names that indicate the agent's purpose
3. Document usage: Add clear descriptions to help team members understand the agent
4. Version control: Store agent configurations in your project repository
5. Test thoroughly: Verify tool permissions work as expected before sharing

### Local vs global agents

**Use Local Agents For:**

- Project-specific configurations
- Agents needing project files/tools
- Development environments with unique requirements
- Sharing with team via version control

**Use Global Agents For:**

- General-purpose agents across projects
- Personal productivity agents
- Agents without project-specific context
- Commonly used tools and workflows

### Security

- Review allowedTools carefully
- Use specific patterns over wildcards
- Configure toolsSettings for sensitive operations
- Test agents in safe environments first

### Organization

- Use descriptive agent names
- Document agent purposes in descriptions
- Keep prompt files organized
- Version control local agents with projects

## Next steps

- Creating Custom Agents
- Built-in Tools Reference
- Hooks Documentation
- Agent Examples

### Contacting billing support - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Contacting billing support

---

If you need assistance with billing questions, payment issues, subscription changes, or other account-related concerns, you can contact our billing support team directly.

## When to contact billing support

Contact billing support for help with:

- Payment issues - Failed payments, updating payment methods, or billing errors
- Subscription questions - Plan changes, upgrade/downgrade assistance, or billing cycle inquiries
- Account access - Issues accessing your account or billing dashboard
- Refund requests - Questions about refunds or billing disputes
- Usage clarification - Understanding your usage charges or tier limits
- Invoice questions - Requesting copies of invoices or clarifying charges

## How to contact support

You can contact billing support in two ways:

### Option 1: Command line

Use the Kiro CLI issue reporting command:

```bash
kiro-cli issue

```

### Option 2: From within chat

If you're already in a Kiro CLI chat session, you can use the built-in issue reporting tool to create a GitHub issue with pre-filled context. Just tell Kiro in natural language about the issue that you want to report, and it will help you create the issue on GitHub.

Both methods will help you create a support request that gets routed to our billing team.

## What information you'll need

When creating your support request, include:

- Issue title - Brief description of your billing concern
- Detailed description - Specific information about your billing question or issue
- Account details - Your Kiro account email and subscription information
- Context - Any relevant error messages or circumstances

## Tips for effective support requests

To help us resolve your issue quickly:

- Be specific - Clearly describe the billing problem you're experiencing
- Include relevant details - Account email, subscription tier, approximate dates of issues
- Mention previous attempts - Let us know if you've tried any troubleshooting steps

For general product questions or technical support, please refer to our [documentation](/docs) or visit our community forums [Discord](https://discord.gg/kirodotdev) and [GitHub](https://github.com/kirodotdev/kiro). Billing support specifically handles account, payment, and subscription-related inquiries.

## Alternative resources

Before contacting support, you might find answers in these resources:

- Billing overview - Complete guide to Kiro's billing system
- Managing your payments - Self-service payment management
- FAQs - Frequently asked questions about Kiro
- Troubleshooting - Common issues and solutions

### Context management - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Context management

---

## Choosing the right context approach

Kiro offers three ways to provide context, each optimized for different use cases:

| Approach | Context Window Impact | Persistence | Best For |
| --- | --- | --- | --- |
| Agent Resources | Always active (consumes tokens) | Persistent across sessions | Essential project files, standards, configs |
| Skills | On demand | Persistent across sessions | Large guides, reference docs, specialized knowledge |
| Session Context | Always active (consumes tokens) | Current session only | Temporary files, quick experiments |
| Knowledge Bases | Only when searched | Persistent across sessions | Large codebases, extensive documentation |

## Decision flowchart

1. Use this decision tree to choose the appropriate context approach:
  - Is your content larger than 10MB or contains thousands of files?
    - Yes → Use Knowledge Bases
    - No → Continue to step 2
2. Do you need this context in every conversation?
  - Yes → Use Agent Resources
  - No → Use Session Context

### Quick reference

- Essential project files (README, configs, standards) → Agent Resources
- Large codebases or documentation sets → Knowledge Bases
- Temporary files for current task → Session Context

## Understanding context window impact

- Context files and agent resources consume tokens from your context window on every request, whether referenced or not.

```bash
> /context show

Agent 
  - .kiro/steering/**/*.md  <project-root>/.kiro/steering/product.md
<project-root>/.kiro/steering/structure.md
<project-root>/.kiro/steering/tech.md
<project-root>/.kiro/steering/testing.md
  - README.md <project-root>/snake/README.md
  - ~/.kiro/steering/**/*.md (no matches)

Session (temporary)
  <none>

5 matched files in use
- <project-root>/.kiro/steering/testing.md (0.1% of context window)
- <project-root>/snake/.kiro/steering/tech.md (0.1% of context window)
- <project-root>/snake/README.md (0.1% of context window)
- <project-root>/snake/.kiro/steering/structure.md (0.2% of context window)
- <project-root>/snake/.kiro/steering/product.md (0.1% of context window)

Context files total: 0.5% of context window

```

- The output shows:
  - Agent: Persistent context from your agent's resources field
  - Session: Temporary context added during the current session
- Context files are limited to 75% of your model's context window. Files exceeding this limit are automatically dropped.
- Knowledge bases don't consume context window space until searched, making them ideal for large reference materials. For more information, see Knowledge base context (for large datasets).

## Managing context

Context files contain information you want Kiro to consider during your conversations. These can include project requirements, coding standards, development rules, or any other information that helps Kiro provide more relevant responses.

### Configuring persistent context with agent resources

The recommended way to configure context is through the resources field in your agent configuration file. This creates persistent context that is available every time you use the agent.

Add file paths or glob patterns to the resources array in your agent config:

```json
{
  "name": "my-agent",
  "description": "My development agent",
  "resources": [
    "file://README.md",
    "file://docs/**/*.md",
    "file://src/config.py"
  ]
}

```

Resources use URI schemes to specify the type:

- file:// — Files loaded directly into context at startup
- skill:// — Skills with metadata loaded at startup, full content loaded on demand
- knowledgeBase — Indexed content searched on demand (configured as objects, not URI strings)

These files will be automatically available in all chat sessions using this agent. For more details on resource types, see the [Agent Configuration Reference](/docs/cli/custom-agents/configuration-reference#resources-field).

### Adding temporary session context

You can temporarily add files to your current chat session using the /context add command. These additions are only available for the current session and will not persist when you start a new chat session.

```bash
> /context add README.md
Added 1 path(s) to context.

```

**Note**: Context modifications via slash command is temporary.

You can also add multiple files at once using glob patterns:

```bash
> /context add docs/*.md
Added 3 path(s) to context.


```

To make context changes permanent, add the files to your agent's resources field instead. For more information, see Configuring persistent context with agent resources.

### Knowledge base context (for large datasets)

For large codebases, documentation sets, or reference materials that would exceed context window limits, use knowledge bases. Knowledge bases provide semantic search capabilities without consuming context window space until searched.

Enable knowledge bases:

kiro-cli settings chat.enableKnowledge true

Add content to a knowledge base:

kiro-cli chat

> /knowledge add /path/to/large-codebase --include "/*.py" --exclude "node_modules/"

Knowledge bases are searched on-demand by Kiro when relevant information is needed, making them ideal for large reference materials.

### Conversation compaction

Compaction summarizes older messages while retaining recent ones, freeing up context window space.

- Manual: Run /compact
- Automatic: Triggers when context window overflows

#### Configuration

| Setting | Default | Description |
| --- | --- | --- |
| compaction.excludeMessages | 2 | Minimum message pairs to retain |
| compaction.excludeContextWindowPercent | 2 | Minimum % of context window to retain |

Both settings are evaluated, and the more conservative (larger) value wins.

Compaction will create a new session. You can resume the original via `/chat resume`.

### Viewing context usage

To view your current context, use the /context show command:

```bash
> /context show

Current context window (5.9% used)
|||████████████████████████████████████████████████████████████████ 5.9%

█ Context files 0.9%
█ Tools 0.5%
█ Kiro responses 0.7%
█ Your prompts 3.8%

```

### Removing context

To remove files from your current session context:

```bash
> /context remove src/temp-file.py
Removed 1 path(s) from context.

```

To clear all session context, use the /context clear command:

```bash
> /context clear
Cleared context
Note: Context modifications via slash command is temporary.

```

Note: You cannot remove agent-defined context using /context commands. To permanently remove context, edit your agent's resources field.

## Context management actions

Here are some common reasons for actively managing your context window:

1. If you find yourself repeatedly adding the same context files using /context add commands, consider moving them to your agent's resources field for persistence:

```bash
# Instead of running these commands every session:
> /context add README.md
> /context add docs/*.md

# Add them to your agent config once:
{
  "resources": [
    "file://README.md",
    "file://docs/**/*.md"
  ]
}

```

You can configure a default agent that includes your preferred context files. This ensures your context is automatically available in new chat sessions without needing to specify the agent each time.

```bash
   >kiro-cli settings chat.defaultAgent my-project-agent

```

1. If you have large context files (consume significant part of context window) consider using knowledge base instead of including those files as is. Use cases to consider knowledge:
  - You have large codebases or documentation sets
  - You need semantic search across extensive materials
  - You want to avoid constant context window consumption
  - Example: Instead of adding a large codebase as context files:

```bash
# This would consume too many tokens:
> /context add src/**/*.py

# Use knowledge base instead:
> /knowledge add src/ --include "**/*.py" --exclude "__pycache__/**"

```

## Best practices

### Context file organization

1. Keep context files focused and relevant to avoid token limits
2. Use descriptive filenames that indicate their purpose
3. Organize rules and documentation in logical directory structures
4. Consider file size - very large files may consume significant tokens

### Performance considerations

1. Monitor token usage with /context show to stay within limits
2. Use specific glob patterns rather than overly broad ones
3. Remove unused context files from agent configurations
4. Consider splitting large context files into smaller, focused files
5. Use knowledge bases for large datasets to avoid context window consumption

### Security considerations

1. Avoid including sensitive information in context files
2. Use .gitignore to prevent accidental commits of sensitive context
3. Review context files regularly to ensure they don't contain outdated information
4. Be mindful of what information is shared when using context in conversations

## Related documentation

- Slash Commands - In-chat context commands
- CLI Commands - Terminal context commands
- Interactive Chat Mode - Using context in chat

### Creating custom agents - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Creating custom agents

---

Custom agents allow you to tailor Kiro CLI behavior for specific tasks by defining which tools are available, what permissions are granted, and what context is automatically included.

## Quick start

You can create an agent configuration using a slash command from within a Kiro CLI chat session. It will guide you through the process of configuring the agent:

```
> /agent generate

✔ Enter agent name:  · backend-specialist
✔ Enter agent description:  · You are specialist in backend coding practices 
✔ Agent scope · Local (current workspace)
Select MCP servers (use Space to toggle, Enter to confirm): markdown-downloader (node), code-analysis (uv)

✓ Agent 'backend-specialist' has been created and saved successfully!

```

Alternatively, you can also use the CLI command to create a new custom agent:

```bash
kiro-cli agent create --name my-agent

```

This will guide you through the setup process and create a configuration file at `~/.kiro/agents/my-agent.json`.

## Agent configuration file

Custom agents are defined using JSON configuration files. Here's a basic example:

```json
{
  "name": "my-agent",
  "description": "A custom agent for my workflow",
  "tools": ["read","write"],
  "allowedTools": ["read"],
  "resources": [
    "file://README.md",
    "file://.kiro/steering/**/*.md",
    "skill://.kiro/skills/**/SKILL.md"
  ],
  "prompt": "You are a helpful coding assistant",
  "model": "claude-sonnet-4"
}

```

## Using your custom agent

Start a new chat session - which uses the default agent ("kiro_default") and swap to an agent using the agent slash command

```bash
> /agent swap

 Choose one of the following agents 
❯ rust-developer-agent
  kiro_default
  backend-specialist

```

After selecting an agent, you will see the following:

```bash
✔ Choose one of the following agents · backend-specialist

[backend-specialist] > 

```

Alternatively, start a chat session with your custom agent:

```bash
kiro-cli --agent my-agent

```

## Next steps

- Explore Agent Configuration options in detail

### Custom agents - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Custom agents

---

Custom agents provide a way to customize Kiro behavior by defining specific configurations for different use cases. Each custom agent is defined by a configuration file that specifies which tools the agent can access, what permissions it has, and what context it should include.

By default, Kiro CLI provides access to all available tools but requires user confirmation for most operations. This approach prioritizes security but can interrupt your workflow with frequent permission prompts.

Custom agents solve this by allowing you to:

- Pre-approve specific tools - Define which tools can run without prompting
- Limit tool access - Restrict which tools are available to reduce complexity
- Include relevant context - Automatically load project files, documentation, or system information
- Configure tool behavior - Set specific parameters for how tools should operate

### Benefits of using custom agents

1. Workflow optimization - Create custom agents tailored to specific tasks like AWS infrastructure management, code reviews, or debugging sessions.
2. Reduced interruptions - Pre-approve trusted tools to eliminate permission prompts during focused work sessions.
3. Enhanced context - Automatically include relevant project documentation, configuration files, or system information.
4. Team collaboration - Share custom agent configurations with team members to ensure consistent development environments.
5. Security control - Limit tool access to only what's needed for specific workflows, reducing potential security risks.

### Relationship to MCP and built-in tools

Custom agents work with both built-in tools and external tools provided through the Model Context Protocol (MCP). This gives you flexibility to:

- Use built-in tools - File operations, command execution, AWS CLI integration, and other core functionality
- Integrate MCP servers - Add custom tools and services through MCP server configurations
- Control tool access - Specify exactly which tools from each source are available
- Manage tool conflicts - Use aliases to handle naming conflicts between different tool sources

## Next steps

- Learn how to Create Custom Agents

### Viewing Kiro usage on the dashboard - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Viewing Kiro usage on the dashboard

---

Available only for Kiro admins, the Kiro dashboard summarizes useful data about how your subscribers use the Kiro IDE and Kiro CLI.

Kiro generates and displays new metrics on an hourly basis for the most part. The only section that is not updated hourly is the **Active users** widget, which is updated daily according to the coordinated universal time (UTC) clock.

## View the dashboard

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console.
3. From the navigation pane, choose Dashboard.
4. (Optional) Filter the information by date range or programming language.

- If the Dashboard link is not available in the navigation pane, see Troubleshoot the dashboard.
- If you'd like to send user metrics to a daily report with a per-user breakdown of their Kiro usage, see View per-user activity in Kiro.
- For information about specific metrics, see Dashboard metrics or choose the help link at the top-right of the dashboard page.

## Disable the dashboard

You might want to disable the Kiro dashboard if you have concerns about data privacy, page load times, or other potential issues. When you disable the dashboard, the dashboard page (and any links to it) will no longer be available in the Kiro console.

For more information about the dashboard, see [viewing usage metrics (dashboard)](/docs/enterprise/monitor-and-track/dashboard/#dashboard-metrics).

#### To disable the dashboard

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console.
3. Choose Settings, and in the Kiro Settings section, disable Kiro usage dashboard.

## Troubleshoot the dashboard

If the Kiro dashboard page is not available, do the following:

- Verify your permissions. To view the dashboard, you need the following permissions:

For more information about permissions, see Policy: Allow administrators to configure Kiro and subscribe users.
  - q:ListDashboardMetrics
  - codewhisperer:ListProfiles
  - sso:ListInstances
  - user-subscriptions:ListUserSubscriptions
- Verify your settings. In the Kiro console, choose Settings and make sure that the Kiro usage dashboard toggle is enabled.

## Dashboard metrics

The following table describes the metrics shown in the Kiro dashboard.

| Metric name | Description |
| --- | --- |
| Total subscriptions per tier | Shows the total subscriptions broken down by subscription tier (Pro, Pro+, Power). Displays both per-group breakdown and total counts across all groups in the current AWS account, as well as subscriptions in member accounts if you're signed in to a management account for which organization-wide visibility of subscriptions has been enabled. |
| Active subscriptions per tier | Shows the total active subscriptions broken down by subscription tier (Pro, Pro+, Power).Active subscriptions are those belonging to users who have started using Kiro in their integrated development environment (IDE) or CLI. You are being charged for these subscriptions. For more information about active subscriptions, see Subscription statuses. |
| Pending subscriptions per tier | Shows the total pending subscriptions broken down by subscription tier (Pro, Pro+, Power).Pending subscriptions are those belonging to users who have not yet started using Kiro. You are not being charged for these subscriptions. For more information about pending subscriptions, see Subscription statuses. |
| Active users | Shows the number of unique users actively utilizing Kiro on a daily, weekly, and monthly basis. Includes breakdowns by:- Client type (IDE vs. CLI)- Subscription tier (Pro, Pro+, Power) |
| Credits consumed | Shows total Kiro credits consumed with time-based views (daily, weekly, monthly). Includes breakdowns by:- Subscription tier (Pro, Pro+, Power)- Client type (IDE vs. CLI) |

### Data protection - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Data protection

---

The AWS [shared responsibility model](https://aws.amazon.com/compliance/shared-responsibility-model/) applies to data protection in Kiro. As described in this model, AWS is responsible for protecting the global infrastructure that runs all of the AWS Cloud. You are responsible for maintaining control over your content that is hosted on this infrastructure. You are also responsible for the security configuration and management tasks for the AWS services that you use. For more information about data privacy, see the [Data Privacy FAQ](https://aws.amazon.com/compliance/data-privacy-faq/).

## Data storage

Kiro stores your questions, its responses, and additional context, such as code, to generate new responses to your requests. For information about how data is encrypted, see [Data encryption](#data-encryption). For information about how AWS may use some questions that you ask Kiro and its responses to improve our services, see [Kiro service improvement](#service-improvement).

### AWS regions where content is stored and processed

If you are a Kiro Free Tier user or a Kiro individual subscriber, your content, such as prompts and responses, will be stored in the US East (N. Virginia) Region.

If you are a [Kiro enterprise user](../../enterprise/concepts/#kiro-enterprise-user), your content will be stored in the AWS Region where your Kiro profile was created.

With cross-region inferencing, your content may be processed in a different Region within the geography where your content is stored. For more information, see [Cross-region processing](#cross-region-processing).

## Cross-region processing

The following sections describe how cross-region inference and cross-region calls are used to provide the Kiro service.

### Cross-region inference

Kiro is powered by Amazon Bedrock, and uses cross-region inference to distribute traffic across different AWS Regions to enhance large language model (LLM) inference performance and reliability. With cross-region inference, you get increased throughput and resilience during high demand periods, as well as improved performance.

Cross region inference doesn’t affect where your data is stored. For information on where data is stored when you use Kiro, see [AWS Regions where content is stored and processed](#aws-regions-where-content-is-stored-and-processed).

### Supported regions for Kiro cross-region inference

For models or capabilities under the experimental tag, see “[Global cross-region inference for experimental features](#global-cross-region-inference-for-experimental-features)”.

| Supported Kiro geography | Inference regions |
| --- | --- |
| United States | US East (N. Virginia) (us-east-1)US West (Oregon) (us-west-2)US East (Ohio) (us-east-2) |
| Europe | Europe (Frankfurt) (eu-central-1)Europe (Ireland) (eu-west-1)Europe (Paris) (eu-west-3)Europe (Stockholm) (eu-north-1)Europe (Milan) (eu-south-1)Europe (Spain) (eu-south-2) |

### Global cross-region inference for experimental features

Kiro may introduce new models and capabilities under an experimental tag, which process data differently than in the table above. When a model is launched as experimental, Kiro may use global cross-region inference to improve performance, increase throughput, and take advantage of available capacity across supported commercial AWS Regions worldwide. Global cross-region inference applies only to models and features explicitly designated as experimental.

For models and capabilities marked as experimental:

- Inference requests may be processed in multiple AWS Regions globally, including Regions outside the one associated with your Kiro profile.
- The Region where your data is stored is not affected by global cross-region inference.
- This global routing is used to optimize resource availability and allow consistent performance for experimental model launches.

## Data encryption

This topic provides information specific to Kiro about encryption in transit and encryption at rest.

### Encryption in transit

All communication between customers and Kiro and between Kiro and its downstream dependencies is protected using TLS 1.2 or higher connections.

### Encryption at rest

Kiro encrypts your data using AWS owned encryption keys from AWS Key Management Service (AWS KMS). You don’t have to take any action to protect the AWS managed keys that encrypt your data. For more information, see [AWS owned keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) in the *AWS Key Management Service Developer Guide*.

When you subscribe with Kiro enterprise, administrators have the option to create customer managed keys to encrypt your data. Customer managed keys are KMS keys in your AWS account that you create, own, and manage to directly control access to your data by controlling access to the KMS key. Only symmetric keys are supported. For information on creating your own KMS key, see [Creating keys](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) in the *AWS Key Management Service Developer Guide*.

To set up a customer managed key to encrypt data as a Kiro enterprise administrator, you need permissions to use AWS KMS. The required KMS permissions are included in the [example IAM policy](). After creating a customer managed KMS key, you must provide the key in the Kiro console to use it to encrypt data.

## Service improvement

To help Kiro provide the most relevant information, we may use certain content from Kiro, such as questions that you ask Kiro, other inputs you provide, and the responses and code that Kiro generates, for service improvement. This page explains what content we use and how to opt out.

### Kiro content used for service improvement

We may use certain content from Kiro Free Tier and Kiro individual subscribers for service improvement. Users that have a paid Kiro subscription and access it through a social login provider (like GitHub or Google) or through AWS Builder ID are considered *individual subscribers*. Content that Kiro may use for service improvement includes, for example, your questions to Kiro, other inputs you provide, and the responses and code that Kiro generates. Kiro may use this content, for example, to provide better responses to common questions, fix Kiro operational issues, for de-bugging, or for model training.

We do not use content from [Kiro enterprise users](../../enterprise/concepts/#kiro-enterprise-user) for service improvement.

If you have an Amazon Q Developer Pro subscription and access Kiro through your AWS account with the Amazon Q Developer Pro subscription, then Kiro will not use your content for service improvement.

## Opt out of data sharing

By default, Kiro collects usage data, errors, crash reports, and other metrics as well as content for service improvement from Kiro Free Tier users and Kiro individual subscribers. This section explains how to opt out of sharing your data in Kiro for Kiro Free Tier and Kiro individual subscribers. For information on how Kiro uses this data, see [Kiro service improvement](#service-improvement).

[Kiro enterprise users](../../enterprise/concepts/#kiro-enterprise-user) are automatically opted out of telemetry and content collection by AWS. Telemetry collection settings for [user activity reports](../../enterprise/monitor-and-track/user-activity/) are controlled by the administrator in the Kiro console and cannot be configured by Kiro enterprise users. For more information, see [Kiro enterprise settings](../../enterprise/settings).

### Opting out of sharing data in the IDE

To opt out of sharing your client-side telemetry and content in the Kiro IDE, use this procedure:

1. Open Settings in Kiro.
2. Switch to the User sub-tab.
3. Choose Application, and then choose Telemetry and Content.
4. To opt out of telemetry collection, uncheck the box for Data Sharing and Prompt Logging: Usage Analytics And Performance Metrics. To opt out of content collection, uncheck the box for Data Sharing and Prompt Logging: Content Collection for Service Improvement.

### Opting out of sharing data in the CLI

To opt out of sharing your client-side telemetry and content in the Kiro CLI, use this procedure:

1. Open Preferences in the Kiro CLI application.
2. To opt out of telemetry collection, toggle off the Telemetry setting. To opt out of content collection, toggle off the Share Kiro content with AWS setting.

## Types of telemetry collected

- Usage data — Information such as the Kiro version, operating system (Windows, Linux, or macOS), and the anonymous machine ID.
- Performance metrics — The request count, errors, and latency for various features:
  - Login
  - Tab completion
  - Code generation
  - Steering
  - Hooks
  - Spec generation
  - Tools
  - MCP

### Delegate - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Delegate

---

The experimental delegate tool will be replaced by the official [subagents](/docs/cli/chat/subagents) tool in a future release. We recommend using subagents for new workflows.

Delegate enables launching and managing asynchronous task processes, allowing you to run Kiro chat sessions with specific agents in parallel to your main conversation. Subagents extend this capability by providing specialized agents that can autonomously handle complex tasks with real-time progress tracking.

## Overview

The delegate feature allows you to:

- Launch background tasks using natural language
- Run parallel Kiro chat sessions with specific agents
- Monitor task progress independently
- Continue your main conversation while tasks run

## Enabling delegate

```bash
kiro-cli settings chat.enableDelegate true

```

Or use the experiment command:

```bash
/experiment
# Select "Delegate" from the list

```

## How it works

### Task creation

Use natural language to ask Kiro to launch a background task:

```
> Can you create a background task to analyze the performance of our API endpoints?

```

Kiro will:

1. Understand the task requirements
2. Determine if an agent is needed
3. Request approval if using an agent
4. Launch the task in the background
5. Return control to your main conversation

### Agent approval flow

**Tasks with agents:**

- Require explicit approval
- Show agent details before execution
- Display agent configuration and permissions

**Tasks without agents:**

- Run with a warning about trust-all permissions
- May have broader access to tools

### Task management

Once delegated, tasks work independently. You can:

- Check progress at any time
- Read results when complete
- Delete tasks when no longer needed

## Usage examples

### Example 1: Code analysis

```
> Can you create a background task to analyze the performance of our API endpoints?

I'll create a background task to analyze your API performance.

Agent: performance-analyzer
Tools: read, shell, aws
Resources: api-docs, performance-metrics

Approve this agent? (y/n): y

✓ Task created: api-performance-analysis
  Task ID: task-abc123
  Status: Running

You can continue working while the analysis runs in the background.

> Great! Now help me with the frontend code...

# Continue main conversation

> Check the status of my API analysis task

Let me check on that task...

Task: api-performance-analysis (task-abc123)
Status: Complete
Duration: 2m 34s

Results:
- Analyzed 15 API endpoints
- Found 3 performance bottlenecks
- Generated optimization recommendations

Would you like me to show you the detailed results?

```

### Example 2: Test suite execution

```
> Run our test suite in the background while I work on the new feature

I'll start the test suite in a background task.

✓ Task created: test-suite-run
  Task ID: task-def456
  Status: Running

# Continue working on feature

> How's the test suite doing?

Let me check...

Task: test-suite-run (task-def456)
Status: Running (45% complete)
Progress: 127/283 tests passed

Still running. I'll let you know when it's complete.

```

### Example 3: Documentation generation

```
> Generate API documentation in the background

I'll create a task to generate your API documentation.

✓ Task created: api-docs-generation
  Task ID: task-ghi789
  Status: Running

# Work on other things

> Show me the results from the documentation task

Task: api-docs-generation (task-ghi789)
Status: Complete

Generated documentation for:
- 23 API endpoints
- 15 data models
- 8 authentication methods

Documentation saved to: docs/api/

```

## Task lifecycle

### 1. Creation

```
> Create a background task to [description]

```

Kiro analyzes the request and determines:

- What agent (if any) is needed
- What tools are required
- What resources to access

### 2. Approval (if needed)

If an agent is required, you'll see:

```
Agent: task-agent-name
Description: What this agent does
Tools: List of tools it can use
Resources: Files it can access

Approve this agent? (y/n):

```

### 3. Execution

Task runs in the background while you continue your main conversation.

### 4. Monitoring

Check status anytime:

```
> Check on [task name]
> What's the status of my background task?
> Show me task progress

```

### 5. Completion

When complete, you can:

```
> Show me the results from [task name]
> What did the background task find?

```

### 6. Cleanup

Delete tasks when done:

```
> Delete the [task name] task
> Clean up completed tasks

```

## Best practices

### When to use delegate

- Long-running operations: Test suites, builds, analysis
- Independent tasks: Work that doesn't need your input
- Parallel work: Multiple tasks that can run simultaneously
- Background monitoring: Continuous checks or watches

### When not to use

- Interactive tasks: Work requiring your input
- Quick operations: Tasks that complete in seconds
- Dependent work: Tasks that need results from main conversation
- Simple commands: Direct execution is faster

### Task organization

- Use descriptive names: Make tasks easy to identify
- Monitor progress: Check on long-running tasks periodically
- Clean up completed tasks: Delete when no longer needed
- Limit concurrent tasks: Too many may slow down system

## Security considerations

### Agent approval

Always review agent details before approval:

- Tools: What can the agent do?
- Resources: What files can it access?
- Permissions: What operations are allowed?

### Trust-all warning

Tasks without agents run with elevated permissions:

- Can access all tools
- May have broader file access
- Should be used carefully

### Best practices

1. Review agent configurations: Understand what you're approving
2. Use specific agents: Create agents with minimal required permissions
3. Monitor task activity: Check what tasks are doing
4. Delete sensitive results: Clean up tasks with sensitive data

## Limitations

### Concurrency

- Limited number of concurrent tasks
- System resources shared between tasks
- May impact performance with many tasks

### Task isolation

- Tasks run independently
- Cannot directly communicate with main conversation
- Results must be explicitly retrieved

### Persistence

- Tasks are session-scoped
- May not survive session restarts
- Results should be saved if needed long-term

## Troubleshooting

### Task not starting

1. Verify delegate is enabled:
bashkiro-cli settings chat.enableDelegate
2. Check for errors: Look for error messages in chat
3. Try simpler task: Test with a basic task first

### Cannot check task status

1. Verify task ID: Ensure you're using correct task name/ID
2. Check if task completed: Completed tasks may be cleaned up
3. List all tasks: Ask Kiro to show all active tasks

### Agent approval issues

1. Review agent details carefully: Ensure you understand permissions
2. Check agent exists: Verify agent is properly configured
3. Try without agent: Some tasks can run without specific agents

## Advanced usage

### Custom agents for tasks

Create specialized agents for common background tasks:

```json
{
  "name": "test-runner",
  "description": "Runs test suites in background",
  "tools": ["shell", "read"],
  "allowedTools": ["shell"],
  "toolsSettings": {
    "shell": {
      "allowedCommands": ["npm test", "pytest", "cargo test"]
    }
  }
}

```

### Task patterns

**Analysis Tasks:**

```
> Analyze code quality in the background
> Run security scan as a background task
> Generate performance report in background

```

**Build Tasks:**

```
> Build the project in the background
> Compile and run tests as a background task
> Generate production bundle in background

```

**Monitoring Tasks:**

```
> Monitor log files in the background
> Watch for file changes as a background task
> Track system metrics in background

```

## Related features

- Experimental Features
- Custom Agents
- TODO Lists

## Next steps

- Create custom agents for tasks
- Configure agents
- Enable other experimental features

### Custom Diff Tools - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Custom Diff Tools

---

When Kiro proposes file changes, it displays them using a built-in diff tool. If you prefer a different diff experience—whether that's syntax highlighting, side-by-side views, or your favorite GUI tool—you can configure Kiro to use an external diff tool instead.

## Configuration

Configure your preferred diff tool with the `chat.diffTool` setting:

```bash
kiro-cli settings chat.diffTool <tool-name>

```

For example, to use delta:

```bash
kiro-cli settings chat.diffTool delta

```

To reset to the built-in diff:

```bash
kiro-cli settings -d chat.diffTool

```

## Terminal tools

These tools display diffs directly in your terminal, keeping you in your workflow:

| Tool | Config value | Best for |
| --- | --- | --- |
| delta | delta | Git users who want syntax highlighting and line numbers |
| difftastic | difft | Language-aware structural diffs that ignore formatting |
| icdiff | icdiff | Quick side-by-side colored comparisons |
| diff-so-fancy | diff-so-fancy | Clean, human-readable output |
| colordiff | colordiff | Simple colorized diffs |
| diff-highlight | diff-highlight | Word-level highlighting (ships with Git) |
| ydiff | ydiff | Side-by-side with word-level highlighting |
| bat | bat | Syntax highlighting with Git integration |

## GUI tools

These open a separate window for reviewing changes:

| Tool | Config value |
| --- | --- |
| VS Code | code |
| VSCodium | codium |
| Meld | meld |
| KDiff3 | kdiff3 |
| FileMerge (macOS) | opendiff |
| Vim | vimdiff or vim |
| Neovim | nvim |

GUI diff tools open temporary files for viewing only. Any edits you make in the GUI tool will not be saved or applied to Kiro's proposed changes.

## Custom arguments

You can customize tool behavior by including arguments in quotes:

```bash
# Enable side-by-side view in delta
kiro-cli settings chat.diffTool "delta --side-by-side"

```

## Other tools

Kiro can work with diff tools not listed above. When you configure a tool, Kiro tries two approaches:

1. Pipes a unified diff to the tool via stdin
2. Invokes the tool with two temporary file paths as arguments

If neither approach works, Kiro falls back to the built-in inline diff.

## Troubleshooting

If you see the error "Couldn't find the diff tool", the tool isn't installed or isn't in your PATH. Verify the tool is accessible:

```bash
which delta

```

If nothing is returned, install the tool first. For example, to install delta:

```bash
# macOS
brew install git-delta

# Ubuntu/Debian
sudo apt install git-delta

```

For other tools, check the tool's documentation for installation instructions.

### Examples - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Examples

---

This guide provides information about a few sample Model Context Protocol (MCP) servers, their capabilities, and how to set them up with Kiro.

Only add MCP servers from trusted sources, and review all applicable server licensing information and documentation. Kiro is not responsible for any third-party MCP servers or other packages.

## AWS Documentation server

The AWS Documentation server provides access to AWS documentation, search capabilities, and content recommendations.
Capabilities

- Search AWS documentation across all services
- Read documentation pages in markdown format
- Get content recommendations related to specific documentation pages

### Setup instructions

#### Prerequisites

1. Install uv from Astral:

```bash
# On macOS/Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# On Windows PowerShell
irm https://astral.sh/uv/install.ps1 | iex

```

1. Install Python 3.10 or newer:

```bash
    uv python install 3.10

```

#### Configuration

For macOS/Linux:

```json
{
  "mcpServers": {
    "aws-docs": {
      "command": "uvx",
      "args": ["awslabs.aws-documentation-mcp-server@latest"],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      },
      "disabled": false,
      "autoApprove": []
    }
  }
}

```

For Windows:

```json
{
  "mcpServers": {
    "aws-docs": {
      "command": "uv",
      "args": [
        "tool",
        "run",
        "--from",
        "awslabs.aws-documentation-mcp-server@latest",
        "awslabs.aws-documentation-mcp-server.exe"
      ],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      }
    }
  }
}

```

### Available tools

| Tool Name | Description |
| --- | --- |
| mcp_aws_docs_search_documentation | Search AWS documentation for specific topics |
| mcp_aws_docs_read_documentation | Read AWS documentation pages in markdown format |
| mcp_aws_docs_recommend | Get content recommendations related to a documentation page |

### Usage examples

```
# Search for information about S3 bucket policies
Search AWS documentation for S3 bucket policies

# Read specific documentation
Read the AWS Lambda function URLs documentation

# Get recommendations
Find related content to AWS ECS task definitions

```

## GitHub MCP server

The GitHub MCP server allows Kiro to interact with GitHub repositories, issues, and pull requests.

### Capabilities

- Access repository information including files, commits, and branches
- Create and manage issues and pull requests
- Search repositories for specific content

### Setup instructions

The previously recommended @modelcontextprotocol/server-github package has been archived. GitHub now recommends using their official Docker-based MCP server.

### Prerequisites

1. Install Docker if not already installed:
  - Docker Desktop for macOS and Windows
  - Docker Engine for Linux
2. Create a GitHub Personal Access Token:
  - Go to GitHub Settings > Developer settings > Personal access tokens (fine-grained)
  - Generate a new token with permissions that fit the tools you need

### Configuration

Follow these steps from the official GitHub documentation:

1. Create a .kiro/settings/mcp.json file in your workspace directory (or edit if it already exists)
2. Add this configuration:

```json
{
  "mcpServers": {
    "github": {
      "command": "docker",
      "args": [
        "run", 
        "-i", 
        "--rm", 
        "-e", 
        "GITHUB_PERSONAL_ACCESS_TOKEN",
        "ghcr.io/github/github-mcp-server"
      ],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "your-token-here"
      },
      "disabled": false,
      "autoApprove": []
    }
  }
}

```

For more detailed installation instructions, refer to the official GitHub MCP Server documentation.

### Common tools

The GitHub MCP server provides a comprehensive set of tools for interacting with GitHub. Here are some of the most commonly used tools organized by category:

| Category | Tool Name | Description |
| --- | --- | --- |
| Repository Tools | search_repositories | Search for GitHub repositories |
| Repository Tools | list_branches | List branches in a repository |
| Issue Tools | list_issues | List issues in a repository |
| Issue Tools | update_issue | Update an existing issue |
| Issue Tools | add_issue_comment | Add a comment to an issue |
| Pull Request Tools | create_pull_request | Create a new pull request |

### Available toolsets

The GitHub MCP server organizes its functionality into toolsets that can be enabled or disabled as needed. By default, all toolsets are enabled. You can specify which toolsets you want to enable when configuring the GitHub MCP server. This allows you to control which GitHub API capabilities are available to your AI tools.

You can specify which toolsets you want to enable when configuring the GitHub MCP server. This allows you to control which GitHub API capabilities are available to your AI tools.
Using Toolsets With Docker

When using Docker, you can pass the toolsets as environment variables:

```bash
docker run -i --rm \
  -e GITHUB_PERSONAL_ACCESS_TOKEN=<your-token> \
  -e GITHUB_TOOLSETS="repos,issues,pull_requests,actions,code_security,experiments" \
  ghcr.io/github/github-mcp-server

```

### Usage examples

```
# Get repository information
Show me information about the tensorflow/tensorflow repository

# Search for code
Find examples of React hooks in facebook/react

# Create an issue
Create an issue in my repository about the login bug

```

## Custom MCP servers

You can create your own MCP servers to extend Kiro's capabilities for your specific needs.

### Creating a custom server

1. Choose a programming language (Python, Node.js, etc.)
2. Implement the MCP protocol using available libraries
3. Define your tools and their capabilities
4. Package and distribute your server

#### Resources for custom server development

- MCP Protocol Specification
- MCP Server Template (Python)
- MCP Server Template (Node.js)

### Additional MCP servers

#### Database servers

- PostgreSQL MCP Server: Query and manage PostgreSQL databases
- MongoDB MCP Server: Interact with MongoDB databases

#### Development tools

- Docker MCP Server: Manage Docker containers and images
- Kubernetes MCP Server: Interact with Kubernetes clusters

### Finding more MCP servers

To discover additional MCP servers:

- Visit the MCP Registry
- Check the GitHub MCP Organization
- Search for mcp-server on npm or PyPI

## In the meantime

While we prepare comprehensive examples, you can:

- Review Security Best Practices for secure integration
- Visit the official MCP documentation
- Return to MCP Overview

## Next steps

- Review Security Best Practices
- Return to MCP Overview

### Exit codes - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Exit codes

---

Kiro CLI returns specific exit codes to indicate operation status. Use these in scripts and CI/CD pipelines to detect success, failures, and specific error conditions.

## Exit code reference

| Code | Name | Description |
| --- | --- | --- |
| 0 | Success | Command completed successfully |
| 1 | Failure | General failure (auth error, invalid args, operation failed) |
| 3 | MCP Startup Failure | MCP server failed to start (requires --require-mcp-startup) |

## Requiring MCP servers

By default, MCP server failures are logged as warnings but don't affect the exit code. Use `--require-mcp-startup` to fail fast when MCP servers are critical to your workflow:

```bash
kiro-cli chat --require-mcp-startup --no-interactive "Run task"

```

If any configured MCP server fails to start, the CLI exits immediately with code 3.

Use `--require-mcp-startup` in CI/CD pipelines where MCP tools are essential. This prevents silent failures where tasks complete without the expected tooling.

## Scripting examples

Handle different exit codes to take appropriate action in your automation:

### Bash script

```bash
#!/bin/bash
kiro-cli chat --require-mcp-startup --no-interactive --trust-all-tools "Run analysis"
exit_code=$?

case $exit_code in
    0) echo "Success" ;;
    3) echo "MCP servers failed to start"; exit 1 ;;
    *) echo "Failed with code $exit_code"; exit $exit_code ;;
esac

```

### CI/CD pipeline

```yaml
- name: Run Kiro task
  run: |
    kiro-cli chat --require-mcp-startup --no-interactive --trust-all-tools "Analyze code"
  continue-on-error: false

```

## Hook exit codes

[Hooks](/docs/cli/hooks) use a separate set of exit codes to control tool execution:

| Code | Behavior |
| --- | --- |
| 0 | Hook succeeded |
| 2 | (PreToolUse only) Block tool execution; STDERR returned to LLM |
| Other | Hook failed; STDERR shown as warning |

## Best practices

- Use --require-mcp-startup in CI/CD when your tasks depend on MCP tools
- Add verbose logging (-v or -vv) when debugging exit code issues
- Check exit codes explicitly rather than relying on implicit shell behavior
- Separate MCP failures from general failures to provide better error messages to users

### Experimental features - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Experimental features

---

Kiro CLI includes experimental features that provide advanced functionality. These features are in active development and can be toggled on/off using the `/experiment` command.

These features may change or be removed at any time. The experience might not be perfect. Use at your own discretion in production workflows.

These features are provided to gather feedback and test new capabilities. Please report issues through the `kiro issue` command.

## Managing experiments

Use the `/experiment` command to toggle experimental features:

```bash
/experiment

```

This shows an interactive menu where you can:

- See current status of each experiment (ON/OFF)
- Toggle experiments by selecting them
- View descriptions of what each experiment does

## Available experiments

### Knowledge management

**Command:** `/knowledge`

Enables persistent context storage and retrieval across chat sessions with semantic search capabilities.

**Features:**

- Store and search through files, directories, and text content
- Semantic search for better context retrieval
- Persistent knowledge base across sessions
- Agent-specific knowledge isolation

**Enable:**

```bash
kiro-cli settings chat.enableKnowledge true

```

[Learn more about Knowledge Management →](/docs/cli/experimental/knowledge-management)

### Tangent mode

**Command:** `/tangent` or **Ctrl+T**

Create conversation checkpoints to explore side topics without disrupting your main conversation flow.

**Features:**

- Create conversation checkpoints
- Explore tangential topics
- Return to main conversation thread
- Preserve conversation context

**Enable:**

```bash
kiro-cli settings chat.enableTangentMode true

```

[Learn more about Tangent Mode →](/docs/cli/experimental/tangent-mode)

### TODO lists

**Tool:** `todo` | **Command:** `/todo`

Enables Kiro to create and modify TODO lists automatically, with commands for you to view and manage them.

**Features:**

- Kiro automatically creates TODO lists when appropriate
- View, manage, and delete TODOs
- Resume existing TODO lists
- Persisted across chat sessions

**Enable:**

```bash
kiro-cli settings chat.enableTodoList true

```

[Learn more about TODO Lists →](/docs/cli/experimental/todo-lists)

### Thinking tool

Shows AI reasoning process for complex problems with step-by-step thought processes.

**Features:**

- Transparent decision-making process
- Step-by-step reasoning display
- Useful for debugging and learning
- Better understanding of conclusions

**Enable:**

```bash
kiro-cli settings chat.enableThinking true

```

[Learn more about Thinking Tool →](/docs/cli/experimental/thinking)

### Checkpointing

**Command:** `/checkpoint`

Enables session-scoped checkpoints for tracking file changes using Git-like commands.

**Features:**

- Snapshots file changes into shadow git repo
- List, expand, diff, and restore checkpoints
- Conversation history unwinds when restoring
- Auto-enables in git repositories
- Manual initialization for non-git directories

**Enable:**

```bash
kiro-cli settings chat.enableCheckpoint true

```

**Basic Usage:**

```bash
/checkpoint list                    # Show checkpoints
/checkpoint expand <tag>            # Show detailed checkpoint info
/checkpoint diff <tag1> [tag2]      # Compare checkpoints
/checkpoint restore [<tag>]         # Restore to checkpoint
/checkpoint clean                   # Delete session shadow repo

```

[Learn more about Checkpointing →](/docs/cli/experimental/checkpointing)

### Context usage percentage

Shows context window usage as a percentage in the chat prompt with color-coded indicators.

**Features:**

- Displays percentage in prompt (e.g., "[rust-agent] 6% >")
- Color-coded indicators:
  - Green: Less than 50% usage
  - Yellow: 50-89% usage
  - Red: 90-100% usage
- Helps monitor context consumption

**Enable:**

```bash
kiro-cli settings chat.enableContextUsageIndicator true

```

### Delegate

Launch and manage asynchronous task processes, running Kiro chat sessions with specific agents in parallel.

**Features:**

- Launch background tasks using natural language
- Run parallel chat sessions with specific agents
- Monitor task progress independently
- Agent approval flow for security

**Enable:**

```bash
kiro-cli settings chat.enableDelegate true

```

**Usage:**
Use natural language to ask Kiro to launch a background task:

```
Can you create a background task to analyze the performance of our API endpoints?

```

Then check on results:

```
Check the status of my API analysis task
Show me the results from the background analysis

```

[Learn more about Delegate →](/docs/cli/experimental/delegate)

## Settings integration

Experiments are stored as settings and persist across sessions:

```bash
# View all experimental settings
kiro-cli settings list | grep -i enable

# Enable/disable specific experiments
kiro-cli settings chat.enableKnowledge true
kiro-cli settings chat.enableTangentMode true
kiro-cli settings chat.enableTodoList true
kiro-cli settings chat.enableThinking true
kiro-cli settings chat.enableCheckpoint true
kiro-cli settings chat.enableContextUsageIndicator true
kiro-cli settings chat.enableDelegate true

```

## Fuzzy search support

All experimental commands are available in fuzzy search (Ctrl+S):

- /experiment - Manage experimental features
- /knowledge - Knowledge base commands (when enabled)
- /todo - TODO list commands (when enabled)
- /tangent - Tangent mode toggle (when enabled)
- /checkpoint - Checkpoint commands (when enabled)

## Best practices

1. Test in safe environments: Try experimental features on non-critical projects first
2. Provide feedback: Report issues and suggestions using kiro issue
3. Stay updated: Check release notes for changes to experimental features
4. Understand limitations: Read individual feature documentation for known issues
5. Have backups: Some features modify files (checkpointing, TODO lists)

## Troubleshooting

### Feature not working

1. Verify feature is enabled:
bashkiro-cli settings list | grep -i enable
2. Check for error messages in chat
3. Try disabling and re-enabling:
bashkiro-cli settings chat.enableFeatureName false
kiro-cli settings chat.enableFeatureName true
4. Restart Kiro CLI

### Commands not available

Ensure the feature is enabled before using its commands. For example, `/knowledge` only works when knowledge management is enabled.

## Next steps

- Knowledge Management
- Tangent Mode
- TODO Lists
- Settings Configuration

### Configuring a firewall, proxy server, or data perimeter for Kiro - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Configuring a firewall, proxy server, or data perimeter for Kiro

---

If you're using a firewall, proxy server, or [data perimeter](https://aws.amazon.com/identity/data-perimeters-on-aws/), make sure to allowlist traffic to the following URLs and Amazon Resource Names (ARNs) so that Kiro works as expected.

## General urls to allowlist

In the following URLs, replace:

- idc-directory-id-or-alias with your IAM Identity Center instance's directory ID or alias. For more information about IAM Identity Center, see What is IAM Identity Center? in the AWS IAM Identity Center User Guide.
- sso-region with the AWS Region where your IAM Identity Center instance is enabled.

| URL | Purpose |
| --- | --- |
| <idc-directory-id-or-alias>.awsapps.com | Authentication |
| oidc.<sso-region>.amazonaws.com | Authentication |
| *.sso.<sso-region>.amazonaws.com | Authentication |
| *.sso-portal.<sso-region>.amazonaws.com | Authentication |
| *.aws.dev | Authentication |
| *.awsstatic.com | Authentication |
| *.console.aws.a2z.com | Authentication |
| *.sso.amazonaws.com | Authentication |
| https://aws-toolkit-language-servers.amazonaws.com/* | Kiro, language processing |
| https://aws-language-servers.us-east-1.amazonaws.com/* | Kiro, language processing |
| https://client-telemetry.us-east-1.amazonaws.com | Kiro, telemetry |
| https://cognito-identity.us-east-1.amazonaws.com | Kiro, telemetry |
| https://prod.us-east-1.telemetry.desktop.kiro.dev | Telemetry |
| https://prod.us-east-1.auth.desktop.kiro.dev | Authentication |

### Onboarding quickstart - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Onboarding quickstart

---

## Audience

Read this page, and the **Enterprise** section, if you're an administrator who wants to onboard your team to Kiro and manage their subscriptions.

For detailed onboarding instructions, see [Subscribe your team to Kiro](../subscribe).

## To onboard your team to Kiro

1. Create an AWS account if you don't have one already (see Create an AWS account).
2. Sign in to your AWS account. You can sign in as an AWS root user or as a user with a privileged role. Alternatively, allow adminitrators to use Kiro with minimum permissions.
3. Enable AWS IAM Identity Center in your AWS account. Add users to its directory, or connect it to an external identity provider (IdP). If this is your first time setting up an IAM Identity Center instance, see Getting started with IAM Identity Center.
4. Create a Kiro profile and subscribe users. Within the AWS console, navigate to the Kiro console and use the available UI to create a profile and subscribe users. The profile is the glue that ties your user identities with their Kiro subscriptions and settings. Once your Kiro profile is created and connected, you can import your users and groups and subscribe your team to Kiro.
5. Have users check their email. Within 24 hours of being subscribed, users should receive an email that contains download instructions for the Kiro IDE and Kiro CLI, as well as sign-in instructions.

### Working with Git - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Working with Git

---

When working with Git repositories, Kiro CLI's fuzzy finder is Git-aware, making it easier to select and add relevant files to your context. This feature helps you quickly identify and include files that are part of your Git repository.

## How Git-aware selection works

The Git-aware fuzzy finder automatically integrates with your repository's Git information to provide enhanced file selection capabilities:

- Recognizes Git-tracked files in your repository
- Shows Git status indicators alongside files
- Prioritizes relevant files based on Git history

## Using Git-aware file selection

###### To use git-aware file selection

1. Navigate to your Git repository in the terminal.
2. Run the context add command:
/context add
3. In the fuzzy finder interface, you'll see files from your repository with Git status indicators:
  - M – Modified files
  - A – Added files
  - ? – Untracked files
4. Type to filter files, using Git status as part of your search criteria.
5. Use the arrow keys to navigate and press Enter to select files to add to your context.

## Tips for Git-aware selection

- Use Git status indicators in your search to quickly find modified or untracked files
- The fuzzy finder prioritizes recently modified files in Git history
- Files ignored by Git (via .gitignore) are still available but deprioritized in the results

### Governance - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Governance

---

Pro-tier customers using IAM Identity Center as the sign-in method can control MCP access for users within their organization. By default, your users can use any MCP server in their Kiro client. As an administrator, you have the ability to either entirely disable the use of MCP servers by your users, or specify a vetted list of MCP servers that your users are allowed use.

You control these restrictions using an MCP on/off toggle and an MCP registry. The MCP toggle and registry attributes are part of the [Kiro Profile](/docs/cli/enterprise/subscribe/) used for Kiro subscription users, and [Q Developer Profile](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/q-admin-setup-subscribe-general.html) used for Q subscription users.

These profiles can be defined at an organization level or at an account level, with the account-level profile superseding the organizational-level profile. You can specify a default MCP policy for your organization and override it for specific accounts; for example, disable MCP for the organization but enable it with an allow-list for certain teams (accounts).

Both the toggle and the registry settings are enforced on the client side. Be aware that your end users could circumvent it.

## Disabling MCP for your organization

To disable MCP for your account or organization:

1. Open the Kiro console.
2. Choose Settings
3. Choose the Kiro or Q Developer tab, depending on user subscription type.
4. Toggle Model Context Protocol (MCP) to Off.

## Specifying an MCP allow-list for your organization

MCP allow-list is currently supported only for Q subscription users.

To control which MCP servers your users can access, create a JSON file with the allowed servers, serve it over HTTPS, and add the URL to your Q Developer profile. Kiro clients using this profile allow users to access only the MCP servers in your allow-list.

### Specifying the MCP registry URL

1. Open the Kiro console.
2. Choose Settings.
3. Choose the Q Developer tab.
4. Ensure Model Context Protocol (MCP) is On.
5. In the MCP Registry URL field, choose Edit.
6. Enter the URL of an MCP registry JSON file containing the allow-listed MCP servers.
7. Choose Save.

The MCP registry URL is encrypted both in transit and at rest in accordance with [our data encryption policy](/docs/cli/privacy-and-security/data-protection/#data-encryption).

### MCP registry file format

The format of the registry JSON file is a subset of the server schema JSON in the [MCP registry standard](https://github.com/modelcontextprotocol/registry) v0.1. The JSON schema definition for the subset supported by Kiro is available in the [registry schema](#mcp-registry-json-schema) section at the end of this document.

The following example shows an MCP registry file containing both a remote (HTTP) and a local (stdio) MCP server definition.

```
{
  "servers": [
    {
      "server": {
        "name": "my-remote-server",
        "title": "My server",
        "description": "My server description",
        "version": "1.0.0",
        "remotes": [
          {
            "type": "streamable-http",
            "url": "https://acme.com/my-server",
            "headers": [
              {
                "name": "X-My-Header",
                "value": "SomeValue"
              }
            ]
          }
        ]
      }
    },
    {
      "server": {
        "name": "my-local-server",
        "title": "My server",
        "description": "My server description",
        "version": "1.0.0",
        "packages": [
          {
            "registryType": "npm",
            "registryBaseUrl": "https://npm.acme.com",
            "identifier": "@acme/my-server",
            "transport": {
              "type": "stdio"
            },
            "runtimeArguments": [
              {
                "type": "positional",
                "value": "-q"
              }
            ],
            "packageArguments": [
              {
                "type": "positional",
                "value": "start"
              }
            ],
            "environmentVariables": [
              {
                "name": "ENV_VAR",
                "value": "ENV_VAR_VALUE"
              }
            ]
          }
        ]
      }
    }
  ]
}

```

The following table lists the properties for the registry JSON file. All properties are mandatory, unless otherwise noted. See the [registry schema](#mcp-registry-json-schema) section for the full JSON schema.

Nested attributes appear indented from their parent. For example, "headers" is a child attribute of "remotes", and "name" and "value" are child attributes of "headers".

| Attribute | Description | Optional? | Example value |
| --- | --- | --- | --- |
| Common attributes |  |  |  |
| name | Server name. Must be unique within a given registry file. |  | "aws-ccapi-mcp" |
| title | Human-readable server name. | Yes | "AWS CC API" |
| description | Description of server. |  | "Manage AWS infra through natural language." |
| version | Version of server. Semantic versioning (x.y.z) is strongly recommended. |  | "1.0.2" |
| Remote (HTTP) server attributes |  |  |  |
| remotes | Array with exactly one entry specifying the remote endpoint. |  | - |
| type | Must be one of "streamable-http" or "sse". |  | "streamable-http" |
| url | MCP server endpoint URL. |  | "https://mcp.figma.com/mcp" |
| headers | Array of HTTP headers to include in each request. | Yes | - |
| name | HTTP header name. |  | "Authorization" |
| value | HTTP header value. |  | "Bearer mF_9.B5f-4.1JqM" |
| Local (stdio) server attributes |  |  |  |
| packages | Array with exactly one entry containing the MCP server definition. |  | - |
| registryType | Must be one of "npm", "pypi", or "oci".The following package runners are used to download and run the MCP server package: For registry type "npm", the "npx" runner is used For "pypi", "uvx" is used For "oci", "docker" is used Client machines must have the appropriate package runners pre-installed. |  | “npm” |
| registryBaseUrl | Package registry URL. | Yes | "https://npm.acme.com" |
| identifier | Server package identifier. |  | "@acme/my-server" |
| transport | Object with exactly one property, "type". |  | - |
| type | Must be "stdio". |  | “stdio” |
| runtimeArguments | Array of arguments provided to the runtime, that is, to npx, uvx or docker. | Yes | - |
| type | Must be "positional". |  | “positional” |
| value | Runtime argument value. |  | “-q” |
| packageArguments | Array of arguments provided to the MCP server. | Yes | - |
| type | Must be "positional". |  | “positional” |
| value | Package argument value. |  | “start” |
| environmentVariables | Array of env vars to set before starting the server. | Yes | - |
| name | Environment variable name. |  | "LOG_LEVEL" |
| value | Environment variable value. |  | “INFO” |

### Serving the MCP registry file

Serve the MCP registry JSON file over HTTPS using any web server, such as Amazon S3, Apache, or nginx. The URL must be accessible to Kiro clients on your users' computers but can be private to your corporate network.

The HTTPS endpoint must have a valid SSL certificate signed by a trusted Certificate Authority. Self-signed certificates are not supported.

Kiro fetches the MCP registry at startup and every 24 hours. During periodic synchronization, if a locally installed MCP server is no longer in the registry, Kiro terminates that server and prevents users from adding it back. If the locally installed server has a different version than the server in the registry, Kiro relaunches the server with the version defined in the registry.

### Kiro CLI

When users launch Kiro CLI, it checks whether a registry URL is defined in the profile. If so, it retrieves the registry JSON at that URL and enforces that users can only use the MCP servers defined in the registry. When users run **/mcp add**, Kiro displays a list of servers from the registry they can select from.

Registry MCP server parameters (URL, package identifier, runtimeArguments, and so forth) are read-only. However, users can:

1. Specify additional environment variables for local MCP servers.
2. Specify additional HTTP headers for remote MCP servers.
3. Change the request timeout.
4. Set the MCP server scope (Global, Workspace, or a specific Agent Configuration).
5. Set MCP tool trust permissions.

User-specified environment variables or HTTP headers override registry definitions. This allows users to specify attributes specific to their setup, such as authentication keys or local folder paths.

For detailed user workflows, troubleshooting, and examples, see [MCP Registry](/docs/cli/mcp/registry).

### MCP registry JSON schema

The following JSON schema defines the MCP registry file format supported by Kiro. You can use this schema to validate any registry files that you create.

```
{
  "$schema": "https://json-schema.org/draft-07/schema",
  "properties": {
    "servers": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "server": {
            "$ref": "#/definitions/ServerDetail"
          }
        },
        "required": [
          "server"
        ]
      }
    }
  },
  "definitions": {
    "ServerDetail": {
      "properties": {
        "name": {
          "description": "Server name. Must be unique within a given registry file.",
          "example": "weather-mcp",
          "maxLength": 200,
          "minLength": 3,
          "pattern": "^[a-zA-Z0-9._-]+$",
          "type": "string"
        },
        "title": {
          "description": "Optional human-readable title or display name for the MCP server. MCP subregistries or clients MAY choose to use this for display purposes.",
          "example": "Weather API",
          "maxLength": 100,
          "minLength": 1,
          "type": "string"
        },
        "description": {
          "description": "Clear human-readable explanation of server functionality. Should focus on capabilities, not implementation details.",
          "example": "MCP server providing weather data and forecasts via OpenWeatherMap API",
          "maxLength": 100,
          "minLength": 1,
          "type": "string"
        },
        "version": {
          "description": "Version string for this server. SHOULD follow semantic versioning (e.g., '1.0.2', '2.1.0-alpha'). Equivalent of Implementation.version in MCP specification. Non-semantic versions are allowed but may not sort predictably. Version ranges are rejected (e.g., '^1.2.3', '~1.2.3', '\u003e=1.2.3', '1.x', '1.*').",
          "example": "1.0.2",
          "maxLength": 255,
          "type": "string"
        },
        "packages": {
          "items": {
            "$ref": "#/definitions/Package"
          },
          "type": "array"
        },
        "remotes": {
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/StreamableHttpTransport"
              },
              {
                "$ref": "#/definitions/SseTransport"
              }
            ]
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "description",
        "version"
      ],
      "type": "object"
    },
    "Package": {
      "properties": {
        "registryType": {
          "description": "Registry type indicating how to download packages (e.g., 'npm', 'pypi', 'oci')",
          "enum": [
            "npm",
            "pypi",
            "oci"
          ],
          "type": "string"
        },
        "registryBaseUrl": {
          "description": "Base URL of the package registry",
          "examples": [
            "https://registry.npmjs.org",
            "https://pypi.org",
            "https://docker.io"
          ],
          "format": "uri",
          "type": "string"
        },
        "identifier": {
          "description": "Package identifier - either a package name (for registries) or URL (for direct downloads)",
          "examples": [
            "@modelcontextprotocol/server-brave-search",
            "https://github.com/example/releases/download/v1.0.0/package.mcpb"
          ],
          "type": "string"
        },
        "transport": {
          "anyOf": [
            {
              "$ref": "#/definitions/StdioTransport"
            },
            {
              "$ref": "#/definitions/StreamableHttpTransport"
            },
            {
              "$ref": "#/definitions/SseTransport"
            }
          ],
          "description": "Transport protocol configuration for the package"
        },

        "runtimeArguments": {
          "description": "A list of arguments to be passed to the package's runtime command (such as docker or npx).",
          "items": {
            "$ref": "#/definitions/PositionalArgument"
          },
          "type": "array"
        },
        "packageArguments": {
          "description": "A list of arguments to be passed to the package's binary.",
          "items": {
            "$ref": "#/definitions/PositionalArgument"
          },
          "type": "array"
        },
        "environmentVariables": {
          "description": "A mapping of environment variables to be set when running the package.",
          "items": {
            "$ref": "#/definitions/KeyValueInput"
          },
          "type": "array"
        }
      },
      "required": [
        "registryType",
        "identifier",
        "transport"
      ],
      "type": "object"
    },
    "StdioTransport": {
      "properties": {
        "type": {
          "description": "Transport type",
          "enum": [
            "stdio"
          ],
          "example": "stdio",
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "StreamableHttpTransport": {
      "properties": {
        "type": {
          "description": "Transport type",
          "enum": [
            "streamable-http"
          ],
          "example": "streamable-http",
          "type": "string"
        },
        "url": {
          "description": "URL template for the streamable-http transport. Variables in {curly_braces} reference argument valueHints, argument names, or environment variable names. After variable substitution, this should produce a valid URI.",
          "example": "https://api.example.com/mcp",
          "type": "string"
        },
        "headers": {
          "description": "HTTP headers to include",
          "items": {
            "$ref": "#/definitions/KeyValueInput"
          },
          "type": "array"
        }
      },
      "required": [
        "type",
        "url"
      ],
      "type": "object"
    },
    "SseTransport": {
      "properties": {
        "type": {
          "description": "Transport type",
          "enum": [
            "sse"
          ],
          "example": "sse",
          "type": "string"
        },
        "url": {
          "description": "Server-Sent Events endpoint URL",
          "example": "https://mcp-fs.example.com/sse",
          "format": "uri",
          "type": "string"
        },
        "headers": {
          "description": "HTTP headers to include",
          "items": {
            "$ref": "#/definitions/KeyValueInput"
          },
          "type": "array"
        }
      },
      "required": [
        "type",
        "url"
      ],
      "type": "object"
    },
    "PositionalArgument": {
      "properties": {
        "type": {
          "enum": [
            "positional"
          ],
          "example": "positional",
          "type": "string"
        },
        "value": {
          "description": "The value for the input.",
          "type": "string"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "type": "object"
    },
    "KeyValueInput": {
      "properties": {
        "name": {
          "description": "Name of the header or environment variable.",
          "example": "SOME_VARIABLE",
          "type": "string"
        },
        "value": {
          "description": "The value for the input.",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    }
  },
  "required": [
    "servers"
  ],
  "type": "object"
}

```

## Next steps

- For end users working with MCP registry, see MCP Registry
- Learn about MCP Configuration
- Review MCP Security

### Help Agent - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Help Agent

---

The Help Agent is a built-in agent that answers questions about Kiro CLI features, commands, tools, and configuration. Unlike general AI responses, answers come from actual Kiro CLI documentation. It can also create agents, prompts, and LSP configs in your `.kiro/` directory.

## Quick start

Switch to the Help Agent:

```
> /help
✔ Switched to agent: kiro_help

[help] > 

```

Or ask a question directly:

```
> /help How do I configure MCP servers?

```

Use `/help --legacy` for the classic command listing.

## What you can ask

The Help Agent has access to comprehensive Kiro CLI documentation:

- Commands: Slash commands (/chat, /agent, /context) and CLI commands (kiro-cli chat, kiro-cli settings)
- Tools: Built-in tools like fs_read, code, grep, glob
- Settings: Any setting available via kiro-cli settings
- Features: Tangent Mode, Hooks, MCP, Code Intelligence, Subagents
- Shortcuts: Keyboard shortcuts and how to use them

## Creating configuration

The Help Agent can create and modify files in `.kiro/` directories:

```
[help] > Create an agent for writing tests

✔ Created .kiro/agents/test-writer.yaml

I've created a test-writing agent. Switch to it with:
/agent swap test-writer

```

It can create:

- Agents in .kiro/agents/
- Prompts in .kiro/prompts/
- LSP configs in .kiro/

## Examples

Here are some common questions and how the Help Agent responds.

### Ask about a command

```
[help] > How do I save a conversation?

Use `/chat save` to save your current conversation:

/chat save ~/my-session.json   # Save to a specific path

Saved conversations can be loaded later with /chat load.

```

### Ask about a tool

```
[help] > What does the code tool do?

The code tool provides code intelligence:

• search_symbols - Find symbol definitions by name
• lookup_symbols - Get details for specific symbols  
• get_document_symbols - List all symbols in a file
• pattern_search - AST-based structural search

It uses AST parsing for accurate code understanding across languages.

```

### Ask about configuration

```
[help] > How do I enable tangent mode?

Enable Tangent Mode with:

kiro-cli settings chat.enableTangentMode true

Or use /tangent during a chat session to toggle it.

```

## Returning to your previous agent

Run `/help` again while in the Help Agent to return to your previous agent:

```
[help] > /help
✔ Switched to agent: kiro_default

```

Or use `/agent swap <name>` to switch to a specific agent.

## Related

- Slash Commands - All available slash commands
- Custom Agents - Create your own agents
- Settings Reference - All configuration options

### Hooks - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Hooks

---

Hooks allow you to execute custom commands at specific points during agent lifecycle and tool execution. This enables security validation, logging, formatting, context gathering, and other custom behaviors.

## Defining hooks

Hooks are defined in the agent configuration file. See the [Agent Configuration Reference](/docs/cli/custom-agents/configuration-reference#hooks-field) for the complete syntax and examples.

## Hook event

Hooks receive hook event in JSON format via STDIN:

```json
{
  "hook_event_name": "agentSpawn",
  "cwd": "/current/working/directory"
}

```

For tool-related hooks, additional fields are included:

- tool_name: Name of the tool being executed
- tool_input: Tool-specific parameters (see individual tool documentation)
- tool_response: Tool execution results (PostToolUse only)

## Hook output

- Exit code 0: Hook succeeded. STDOUT is captured but not shown to user.
- Exit code 2: (PreToolUse only) Block tool execution. STDERR is returned to the LLM.
- Other exit codes: Hook failed. STDERR is shown as warning to user.

## Tool matching

Use the `matcher` field to specify which tools the hook applies to. You can use either canonical tool names or their aliases.

### Examples

- "fs_write" or "write" - Match write tool
- "fs_read" or "read" - Match read tool
- "execute_bash" or "shell" - Match shell command execution
- "use_aws" or "aws" - Match AWS CLI tool
- "@git" - All tools from git MCP server
- "@git/status" - Specific tool from git MCP server
- "*" - All tools (built-in and MCP)
- "@builtin" - All built-in tools only
- No matcher - Applies to all tools

Hook matchers support both canonical names (`fs_read`, `fs_write`, `execute_bash`, `use_aws`) and their aliases (`read`, `write`, `shell`, `aws`). Use whichever you prefer.

For complete tool reference format, see [Agent Configuration Reference](/docs/cli/custom-agents/configuration-reference#tools-field).

## Hook types

### AgentSpawn

Runs when agent is activated. No tool context provided.

**Hook Event**

```json
{
  "hook_event_name": "agentSpawn",
  "cwd": "/current/working/directory"
}

```

**Exit Code Behavior:**

- 0: Hook succeeded, STDOUT is added to agent's context
- Other: Show STDERR warning to user

### UserPromptSubmit

Runs when user submits a prompt. Output is added to conversation context.

**Hook Event**

```json
{
  "hook_event_name": "userPromptSubmit",
  "cwd": "/current/working/directory",
  "prompt": "user's input prompt"
}

```

**Exit Code Behavior:**

- 0: Hook succeeded, STDOUT is added to agent's context
- Other: Show STDERR warning to user

### PreToolUse

Runs before tool execution. Can validate and block tool usage.

**Hook Event**

```json
{
  "hook_event_name": "preToolUse",
  "cwd": "/current/working/directory",
  "tool_name": "read",
  "tool_input": {
    "operations": [
      {
        "mode": "Line",
        "path": "/current/working/directory/docs/hooks.md"
      }
    ]
  }
}

```

**Exit Code Behavior:**

- 0: Allow tool execution.
- 2: Block tool execution, return STDERR to LLM.
- Other: Show STDERR warning to user, allow tool execution.

### PostToolUse

Runs after tool execution with access to tool results.

**Hook Event**

```json
{
  "hook_event_name": "postToolUse",
  "cwd": "/current/working/directory",
  "tool_name": "read",
  "tool_input": {
    "operations": [
      {
        "mode": "Line",
        "path": "/current/working/directory/docs/hooks.md"
      }
    ]
  },
  "tool_response": {
    "success": true,
    "result": ["# Hooks\n\nHooks allow you to execute..."]
  }
}

```

**Exit Code Behavior:**

- 0: Hook succeeded.
- Other: Show STDERR warning to user. Tool already ran.

### Stop

Runs when the assistant finishes responding to the user (at the end of each turn).
This is useful for running post-processing tasks like code compilation, testing, formatting,
or cleanup after the assistant's response.

**Hook Event**

```json
{
  "hook_event_name": "stop",
  "cwd": "/current/working/directory"
}

```

**Exit Code Behavior:**

- 0: Hook succeeded.
- Other: Show STDERR warning to user.

**Note**: Stop hooks do not use matchers since they don't relate to specific tools.

### MCP Example

For MCP tools, the tool name includes the full namespaced format including the MCP Server name:

**Hook Event**

```json
{
  "hook_event_name": "preToolUse",
  "cwd": "/current/working/directory",
  "tool_name": "@postgres/query",
  "tool_input": {
    "sql": "SELECT * FROM orders LIMIT 10;"
  }
}

```

## Timeout

Default timeout is 30 seconds (30,000ms). Configure with `timeout_ms` field.

## Caching

Successful hook results are cached based on `cache_ttl_seconds`:

- 0: No caching (default)
- > 0: Cache successful results for specified seconds
- AgentSpawn hooks are never cached

### How Kiro works with identity and access management (IAM) - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# How Kiro works with identity and access management (IAM)

---

To access the Kiro console and perform tasks related to your Kiro subscription, you need permissions provisioned through AWS Identity and Access Management (IAM). AWS IAM is an AWS service that helps an administrator securely control access to AWS resources and is available at no additional charge.

To enable access, you can create an identity-based policy with the necessary permissions and attach it to the IAM identity that is configuring Kiro subscriptions. For more information, see [Identity-based policies for Kiro](#identity-based-policies-for-kiro).

In addition, Kiro uses AWS IAM service-linked roles. A service-linked role is a unique type of IAM role that is linked directly to Kiro, rather than to an identity, and they are automatically created for you when you subscribe. For more information, see [Service-linked roles for Kiro](#service-linked-roles-for-kiro).

## Identity-based policies for Kiro

Identity-based policies are JSON permissions policy documents that you can attach to an identity, such as an IAM user, group of users, or role. These policies control what actions users and roles can perform, on which resources, and under what conditions.

To subscribe users and configure your subscription, you need the permissions defined in Allow administrators to configure and subscribe to Kiro in the console.

To learn how to create an identity-based policy, see [Define custom IAM permissions with customer managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_create.html) in the *AWS IAM User Guide*.

### Policy: allow administrators to configure Kiro and subscribe users

The following example policy grants permissions to perform actions in the Kiro console. The Kiro console is where you subscribe users to Kiro, configure Kiro’s integration with AWS IAM Identity Center and AWS Organizations, and manage subscription settings. This policy also includes permissions to create and configure customer managed KMS keys.

## Service-linked roles for Kiro

A service-linked role is a unique type of IAM role that is linked directly to Kiro. Service-linked roles are predefined by AWS and include all the permissions that Kiro requires to call other AWS services on your behalf.

A service-linked role makes setting up Kiro easier because you don’t have to manually add the necessary permissions. Kiro defines the permissions of its service-linked roles, and unless defined otherwise, only Kiro can assume its roles. The defined permissions include the trust policy and the permissions policy, and that permissions policy cannot be attached to any other IAM entity.

You can delete a service-linked role only after first deleting their related resources. This protects your Kiro resources because you can't inadvertently remove permission to access the resources. For more information about service-linked roles, see the [AWS IAM User Guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html#id_roles_terms-and-concepts).

There are two service-linked roles that will be created for you when you subscribe with Kiro enterprise:

- AWSServiceRoleForUserSubscriptions
- AWSServiceRoleForAmazonQDeveloper

### Service-linked role: AWSServiceRoleForUserSubscriptions

Kiro uses the service-linked role named **AWSServiceRoleForUserSubscriptions**. This role grants permissions for Kiro to access your IAM Identity Center resources in order to automatically update your subscriptions.

The AWSServiceRoleForUserSubscriptions service-linked role trusts the following services to assume the role:

- user-subscriptions.amazonaws.com

The role permissions policy named AWSServiceRoleForUserSubscriptions allows Kiro to complete the following actions on the specified resources:

- Action: identitystore:DescribeGroup on *
- Action: identitystore:DescribeUser on *
- Action: identitystore:IsMemberInGroups on *
- Action: identitystore:ListGroupMemberships on *
- Action: organizations:DescribeOrganization on *
- Action: sso:DescribeApplication on *
- Action: sso:DescribeInstance on *
- Action: sso:ListInstances on *
- Action: sso-directory:DescribeUser on *

You must configure permissions to allow your users, groups, or roles to create, edit, or delete a service-linked role. For more information, see [Service-linked role permissions](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create-service-linked-role.html#service-linked-role-permissions) in the *AWS IAM User Guide*.

### Service-linked role: AWSServiceRoleForAmazonQDeveloper

Kiro uses the service-linked role named **AWSServiceRoleForAmazonQDeveloper**. This role grants permissions for Kiro to access data in your account to calculate billing, provides access to create and access security reports in Amazon CodeGuru, and emit data to CloudWatch.

The AWSServiceRoleForAmazonQDeveloper service-linked role trusts the following services to assume the role:

- q.amazonaws.com

The role permissions policy named AWSServiceRoleForAmazonQDeveloper allows Kiro to complete the following actions on the specified resources:

- Action: cloudwatch:PutMetricData on AWS/Q CloudWatch namespace

You must configure permissions to allow your users, groups, or roles to create, edit, or delete a service-linked role. For more information, see [Service-linked role permissions](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create-service-linked-role.html#service-linked-role-permissions) in the *AWS IAM User Guide*.

### Managing service-linked roles

You don't need to manually create a service-linked role. When you create a profile for Kiro in the AWS Management Console, Kiro creates the service-linked role for you. If you delete this service-linked role, and then need to create it again, you can use the same process to recreate the role in your account.

You can also use the IAM console or AWS CLI to create a service-linked role with the `q.amazonaws.com` service name. For more information, see [Creating a service-linked role](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html#create-service-linked-role) in the *AWS IAM User Guide*. If you delete this service-linked role, you can use the same process to create the role again.

Kiro does not allow you to edit the AWSServiceRoleForUserSubscriptions or AWSServiceRoleForAmazonQDeveloper service-linked roles. After you create a service-linked role, you cannot change the name of the role because various entities might reference the role. However, you can edit the description of the role using IAM. For more information, see [Editing a service-linked role](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html#edit-service-linked-role) in the *AWS IAM User Guide*.

If you no longer need to use a feature or service that requires a service-linked role, we recommend that you delete that role. That way you don’t have an unused entity that is not actively monitored or maintained. However, you must clean up the resources for your service-linked role before you can manually delete it. Use the IAM console, the AWS CLI, or the AWS API to delete the service-linked roles. For more information, see [Deleting a service-linked role](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html#delete-service-linked-role) in the *AWS IAM User Guide*.

Note: If Kiro is using the role when you try to delete the resources, then the deletion might fail. If that happens, wait for a few minutes and try the operation again.

### Supported regions for Kiro service-linked roles

You can use the AWSServiceRoleForUserSubscriptions and AWSServiceRoleForAmazonQDeveloper roles in the following AWS Regions. For more information on Regions, see [AWS Regions and endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the *AWS General Reference*.

| Region name | Region identity |
| --- | --- |
| US East (N. Virginia) | us-east-1 |
| Europe (Frankfurt) | eu-central-1 |

### Working with images - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Working with images

---

Kiro can analyze and discuss images directly in your chat session. You can share images with Kiro by dragging and dropping them into your terminal window or by using the `read` tool with the Image mode.

## Drag and drop images

The simplest way to share images with Kiro is to drag and drop them directly into your terminal window. When you drag an image into the terminal:

1. The image path is automatically inserted into your prompt
2. You can then add text to provide context about what you want Kiro to do with the image
3. Kiro will process the image and respond based on its content

Example:

```
Kiro> /path/to/architecture-diagram.png Can you explain this architecture and generate sample code for implementing it?

```

## Using fs_read with images

You can also explicitly use the `read` tool to share images:

```
Kiro> Can you analyze this screenshot at /path/to/screenshot.png?

```

Kiro will automatically suggest using fs_read with Image mode when you mention image files.

## Pasting images from your clipboard

You can paste an image from your system clipboard with:

```
/paste

```

## Image use cases

Common use cases for sharing images with Kiro include:

- Analyzing screenshots of error messages for troubleshooting
- Converting architecture diagrams into code implementations
- Discussing UI/UX designs and generating corresponding HTML/CSS
- Understanding flowcharts and translating them into algorithms
- Reviewing code snippets shared as images
- Interpreting technical diagrams for documentation

## Supported formats and limitations

Supported image formats include JPEG/JPG, PNG, GIF, and WebP. Images must be under 10MB in size, and you can share up to 10 images in a single request.

For best results:

- Use high-resolution images with clear text
- Provide specific instructions about what you want Kiro to do with the image
- For complex diagrams, consider providing additional context

### Infrastructure security in Kiro - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Infrastructure security in Kiro

As a managed service, Kiro is protected by AWS global network security. For information about AWS security services and how AWS protects infrastructure, see [AWS Cloud Security](https://aws.amazon.com/security/). To design your AWS environment using the best practices for infrastructure security, see [Infrastructure Protection](https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/infrastructure-protection.html) in *Security Pillar AWS Well‐Architected Framework*.
You use AWS published API calls to access Kiro through the network. Clients must support the following:

- Transport Layer Security (TLS). We require TLS 1.2 and recommend TLS 1.3.
- Cipher suites with perfect forward secrecy (PFS) such as DHE (Ephemeral Diffie-Hellman) or ECDHE (Elliptic Curve Ephemeral Diffie-Hellman). Most modern systems such as Java 7 and later support these modes.

Additionally, requests must be signed by using an access key ID and a secret access key that is associated with an IAM principal. Or you can use the [AWS Security Token Service](https://docs.aws.amazon.com/STS/latest/APIReference/welcome.html) (AWS STS) to generate temporary security credentials to sign requests.

---

### Installation - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Installation

---

## macOS

You can natively install Kiro CLI for macOS at the command line.

Kiro will direct you to open your web browser, where you will follow the steps under [Authentication](../authentication).

## Linux AppImage

You can install Kiro CLI for Linux using the AppImage format, which is a portable format that works on most Linux distributions without requiring installation.

To install Kiro CLI for Linux using AppImage, complete the following procedure.

1. Download Kiro CLI for Linux AppImage:

1. Make the AppImage executable:
bashchmod +x kiro-cli.appimage
2. Run the AppImage:
bash./kiro-cli.appimage
3. Kiro will direct you to open your web browser, where you will follow the steps under Authentication.

## With a zip file

The setup for Linux integration with the Kiro CLI requires installing the appropriate file for your system, verifying the file, and installing the program.

### Install and update requirements

- You must be able to extract or "unzip" the downloaded package. If your operating system doesn't have the built-in unzip command, use an equivalent.
- Kiro for command line requires glibc 2.34 or newer, which is included by default in most major Linux distributions released since 2021.
- For older distributions with glibc versions earlier than 2.34, use the special musl-based version (indicated by -musl.zip in the filename).
- Kiro for command line is supported on 64-bit x86_64 and ARM aarch64 versions of recent distributions of Fedora, Ubuntu, and Amazon Linux 2023.

### Checking your glibc version

To determine which version you need, check your glibc version:

```
ldd --version

```

If the version is 2.34 or newer, use the standard version. If it's older, use the musl version.

### To download the installation file

Choose the appropriate download command based on your system architecture and glibc version:

#### Standard version (glibc 2.34+)

##### Linux x86-64

##### Linux ARM (aarch64)

#### Musl version (for glibc < 2.34)

##### Linux x86-64 with musl

##### Linux ARM (aarch64) with musl

### To install Kiro CLI

1. Unzip the installer:
unzip kirocli.zip
2. Run the install program:
./kirocli/install.sh

By default, the files are installed to ~/.local/bin.

## Ubuntu

You can install Kiro CLI for Ubuntu using the .deb package.

To install Kiro CLI for Ubuntu, complete the following procedure.

1. Download Kiro CLI for Ubuntu.

1. Install the package:
bashsudo dpkg -i kiro-cli.deb
sudo apt-get install -f
2. Launch Kiro CLI:
bashkiro-cli
3. Kiro will direct you to open your web browser, where you will follow the steps under Authentication.

## Proxy configuration

Kiro CLI (v1.8.0 and later) supports proxy servers commonly used in enterprise environments. The CLI automatically respects standard proxy environment variables.

### Setting proxy environment variables

Configure proxy settings by setting these environment variables in your shell:

```bash
# HTTP proxy for non-SSL traffic
export HTTP_PROXY=http://proxy.company.com:8080

# HTTPS proxy for SSL traffic  
export HTTPS_PROXY=http://proxy.company.com:8080

# Bypass proxy for specific domains
export NO_PROXY=localhost,127.0.0.1,.company.com

```

### Proxy with authentication

For proxies requiring authentication:

```bash
export HTTP_PROXY=http://username:password@proxy.company.com:8080
export HTTPS_PROXY=http://username:password@proxy.company.com:8080

```

### Troubleshooting proxy issues

If you encounter proxy-related connection issues:

- Verify proxy server accessibility and credentials
- Ensure your corporate firewall allows connections to AWS endpoints
- Contact your IT administrator if SSL certificate validation fails
- Check that the proxy server supports the required protocols

## Uninstalling Kiro CLI

You can uninstall Kiro CLI if you no longer need it.

To uninstall Kiro CLI on macOS, run:

```bash
kiro-cli uninstall

```

To uninstall Kiro CLI on Ubuntu, complete the following procedure.

1. Use the apt package manager to remove the package:
bashsudo apt-get remove kiro-cli
2. Remove any remaining configuration files:
bashsudo apt-get purge kiro-cli

## Debugging Kiro CLI

If you're having a problem with Kiro CLI, run `kiro-cli doctor` to identify and fix common issues.

### Expected output

```bash
$ kiro-cli doctor

✔ Everything looks good!

Kiro CLI still not working? Run kiro-cli issue to let us know!

```

If your output doesn't look like the expected output, follow the prompts to resolve your issue. If it's still not working, use `kiro-cli issue` to report the bug.

### Common issues

Here are some common issues you might encounter when using Kiro CLI:

Authentication failures
:   If you're having trouble authenticating, try running `kiro-cli login` to re-authenticate.

Autocomplete not working
:   Ensure your shell integration is properly installed by running `kiro-cli doctor`.

SSH integration issues
:   Verify that your SSH server is properly configured to accept the required environment variables.

### Troubleshooting steps

Follow these steps to troubleshoot issues with Kiro CLI:

1. Run kiro-cli doctor to identify and fix common issues.
2. Check your internet connection.
3. Verify that you're using a supported environment. For more information, see Supported command line environments.
4. Try reinstalling Kiro CLI.
5. If the issue persists, report it using kiro-cli issue.

### Knowledge management - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Knowledge management

---

The `/knowledge` command provides persistent knowledge base functionality for Kiro CLI, allowing you to store, search, and manage contextual information that persists across chat sessions.

## Getting started

### Enable knowledge feature

Knowledge management is experimental and must be enabled before use:

```bash
kiro-cli settings chat.enableKnowledge true

```

### Basic usage

Once enabled, use `/knowledge` commands within your chat session:

```bash
/knowledge add --name myproject --path /path/to/project
/knowledge show

```

## Commands

### /knowledge show

Display all entries in your knowledge base with detailed information including creation dates, item counts, and persistence status. Also shows any active background indexing operations with progress and ETA.

This unified command provides a complete view of both your stored knowledge and ongoing operations.

```bash
/knowledge show

```

### /knowledge add

Add files or directories to your knowledge base. The system recursively indexes all supported files in directories.

**Syntax:**

```bash
/knowledge add --name <name> --path <path> [--include pattern] [--exclude pattern] [--index-type Fast|Best]

```

**Required Parameters:**

- --name or -n: Descriptive name for the knowledge entry
- --path or -p: Path to file or directory to index

**Examples:**

```bash
/knowledge add --name "project-docs" --path /path/to/documentation
/knowledge add -n "config-files" -p /path/to/config.json
/knowledge add --name "fast-search" --path /path/to/logs --index-type Fast
/knowledge add -n "semantic-search" -p /path/to/docs --index-type Best

```

### Index types

Choose the indexing approach that best fits your needs:

#### Fast (Lexical - bm25)

**Advantages:**

- ✅ Lightning-fast indexing - processes files quickly
- ✅ Instant search - keyword-based with immediate results
- ✅ Low resource usage - minimal CPU and memory
- ✅ Perfect for logs, configs, and large codebases

**Disadvantages:**

- ❌ Less intelligent - requires exact keyword matches

#### Best (Semantic - all-minilm-l6-v2)

**Advantages:**

- ✅ Intelligent search - understands context and meaning
- ✅ Natural language queries - search with full sentences
- ✅ Finds related concepts - even without exact keywords
- ✅ Perfect for documentation and research

**Disadvantages:**

- ❌ Slower indexing - requires AI model processing
- ❌ Higher resource usage - more CPU and memory intensive

### When to use each type

| Use Case | Recommended Type | Why |
| --- | --- | --- |
| Log files, error messages | Fast | Quick keyword searches, large volumes |
| Configuration files | Fast | Exact parameter/value lookups |
| Large codebases | Fast | Fast symbol and function searches |
| Documentation | Best | Natural language understanding |
| Research papers | Best | Concept-based searching |
| Mixed content | Best | Better overall search experience |

### Default behavior

If you don't specify `--index-type`, the system uses your configured default:

```bash
# Set your preferred default
kiro-cli settings knowledge.indexType Fast   # or Best

# This will use your default setting
/knowledge add "my-project" /path/to/project

```

### Pattern filtering

Control which files are indexed using include and exclude patterns:

```bash
/knowledge add "rust-code" /path/to/project --include "*.rs" --exclude "target/**"
/knowledge add "docs" /path/to/project --include "**/*.md" --include "**/*.txt" --exclude "node_modules/**"

```

**Pattern Examples:**

- *.rs - All Rust files recursively (equivalent to **/*.rs)
- **/*.py - All Python files recursively
- target/** - Everything in target directory
- node_modules/** - Everything in node_modules

**Default Pattern Behavior:**

When you don't specify patterns, the system uses configured defaults:

```bash
kiro-cli settings knowledge.defaultIncludePatterns '["**/*.rs", "**/*.py"]'
kiro-cli settings knowledge.defaultExcludePatterns '["target/**", "__pycache__/**"]'

# Uses default patterns
/knowledge add "my-project" /path/to/project

# Overrides defaults
/knowledge add "docs-only" /path/to/project --include "**/*.md"

```

### Supported file types

**Text files:** .txt, .log, .rtf, .tex, .rst

**Markdown:** .md, .markdown, .mdx

**JSON:** .json (treated as text for searchability)

**Configuration:** .ini, .conf, .cfg, .properties, .env

**Data files:** .csv, .tsv

**Web formats:** .svg (text-based)

**Code files:** .rs, .py, .js, .jsx, .ts, .tsx, .java, .c, .cpp, .h, .hpp, .go, .rb, .php, .swift, .kt, .kts, .cs, .sh, .bash, .zsh, .html, .htm, .xml, .css, .scss, .sass, .less, .sql, .yaml, .yml, .toml

**Special files:** Dockerfile, Makefile, LICENSE, CHANGELOG, README (files without extensions)

**Note:** Unsupported files are indexed without text content extraction.

### /knowledge remove

Remove entries from your knowledge base by name, path, or context ID.

```bash
/knowledge remove "project-docs"  # Remove by name
/knowledge remove /path/to/old/project  # Remove by path

```

### /knowledge update

Update an existing knowledge base entry with new content. Original include/exclude patterns are preserved.

```bash
/knowledge update /path/to/updated/project

```

### /knowledge clear

Remove all entries from your knowledge base. Requires confirmation and cannot be undone.

```bash
/knowledge clear

```

You'll be prompted:

```
⚠️ This will remove ALL knowledge base entries. Are you sure? (y/N):

```

### /knowledge cancel

Cancel background operations. Cancel specific operation by ID or all operations.

```bash
/knowledge cancel abc12345  # Cancel specific operation
/knowledge cancel all       # Cancel all operations

```

## Configuration

Configure knowledge base behavior:

```bash
# Maximum files per knowledge base
kiro-cli settings knowledge.maxFiles 10000

# Text chunk size for processing
kiro-cli settings knowledge.chunkSize 1024

# Overlap between chunks
kiro-cli settings knowledge.chunkOverlap 256

# Default index type
kiro-cli settings knowledge.indexType Fast

# Default include patterns
kiro-cli settings knowledge.defaultIncludePatterns '["**/*.rs", "**/*.md"]'

# Default exclude patterns
kiro-cli settings knowledge.defaultExcludePatterns '["target/**", "node_modules/**"]'

```

## Agent-specific knowledge bases

### Isolated knowledge storage

Each agent maintains its own isolated knowledge base, ensuring knowledge contexts are scoped to the specific agent you're working with. This provides better organization and prevents knowledge conflicts.

### Folder structure

Knowledge bases are stored in:

```
~/.kiro/knowledge_bases/
├── kiro_cli_default/          # Default agent
│   ├── contexts.json
│   ├── context-id-1/
│   │   ├── data.json
│   │   └── bm25_data.json
│   └── context-id-2/
│       └── data.json
├── my-custom-agent_<code>/    # Custom agent
│   ├── contexts.json
│   └── context-id-3/
│       └── data.json
└── another-agent_<code>/      # Another agent
    ├── contexts.json
    └── context-id-4/
        └── data.json

```

### How agent isolation works

- Automatic Scoping: /knowledge commands operate on current agent's knowledge base
- No Cross-Agent Access: Agent A cannot access Agent B's knowledge
- Independent Configuration: Each agent has different settings and contexts
- Migration Support: Legacy knowledge bases migrate to default agent

### Agent switching

When you switch agents, knowledge commands automatically work with that agent's knowledge base:

```bash
# Working with default agent
/knowledge add /path/to/docs

# Switch to custom agent
kiro chat --agent my-custom-agent

# Creates separate knowledge base for my-custom-agent
/knowledge add /path/to/agent/docs

# Switch back to default
kiro chat

# Only sees original docs, not agent-specific docs
/knowledge show

```

## How it works

### Indexing process

1. Pattern Filtering: Files filtered by include/exclude patterns
2. File Discovery: Recursive scan for supported file types
3. Content Extraction: Text extracted from each file
4. Chunking: Large files split into searchable chunks
5. Background Processing: Asynchronous indexing
6. Semantic Embedding: Content processed for semantic search

### Search capabilities

Knowledge bases use semantic search:

- Natural language queries
- Results ranked by relevance, not just keywords
- Related concepts found even without exact word matches

### Persistence

- Contexts survive across chat sessions and CLI restarts
- Persistence determined automatically by usage patterns
- Include/exclude patterns stored and reused during updates

## Best practices

### Organizing your knowledge base

- Use descriptive names: "api-documentation" not "docs"
- Group related files in directories before adding
- Use include/exclude patterns to focus on relevant files
- Regularly review and update outdated contexts

### Effective searching

- Use natural language: "how to handle authentication errors using the knowledge tool"
- Be specific: "database connection configuration"
- Try different phrasings if initial searches don't work
- Prompt Kiro to use the tool: "find database connection configuration using your knowledge bases"

### Managing large projects

- Add project directories rather than individual files
- Use patterns to avoid build artifacts: --exclude "target/**" --exclude "node_modules/**"
- Use /knowledge show to monitor indexing progress
- Consider breaking large projects into logical sub-directories

### Pattern filtering best practices

- Be specific: Use precise patterns to avoid over-inclusion
- Exclude build artifacts: Always exclude target/**, node_modules/**, .git/**
- Include relevant extensions: Focus on file types you need
- Test patterns: Verify patterns match expected files before large operations

## Limitations

### File type support

- Binary files ignored during indexing
- Very large files may be chunked, potentially splitting related content
- Some specialized formats may not extract content optimally

### Performance considerations

- Large directories may take significant time to index
- Background operations limited by concurrent processing
- Search performance varies by knowledge base size
- Pattern filtering improves performance for large directories

### Storage and persistence

- No explicit storage size limits, but practical limits apply
- No automatic cleanup of old or unused contexts
- Clear operations are irreversible with no backup

## Troubleshooting

### Files not being indexed

1. Check patterns: Ensure include patterns match your files
2. Verify exclude patterns: Make sure they're not filtering desired files
3. Check file types: Ensure files have supported extensions
4. Monitor progress: Use /knowledge show to check indexing status
5. Verify paths: Ensure paths exist and are accessible
6. Check for errors: Look for error messages in CLI output

### Search not finding expected results

1. Wait for indexing: Use /knowledge show to ensure completion
2. Try different queries: Use various phrasings and keywords
3. Verify content: Confirm content was added with /knowledge show
4. Check file types: Unsupported types won't have searchable content

### Performance issues

1. Check operations: Use /knowledge show for progress
2. Cancel if needed: Use /knowledge cancel for problematic operations
3. Add smaller chunks: Consider subdirectories instead of entire projects
4. Use better patterns: Exclude unnecessary files
5. Adjust settings: Lower maxFiles or chunkSize for better performance

### Pattern issues

1. Test patterns: Start simple, then add complexity
2. Check syntax: Ensure glob patterns use correct syntax (** for recursive)
3. Verify paths: Make sure patterns match actual file paths
4. Use absolute patterns: Consider full paths for precision

## Next steps

- Context Management
- Custom Agents
- Settings Configuration
- Experimental Features

### Manage prompts - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Manage prompts

---

The Kiro CLI provides comprehensive prompt management capabilities for both local prompts and Model Context Protocol (MCP) prompts. This system allows you to create, edit, organize, and use reusable prompts across your development workflow.

## About prompt types

The prompt system supports three types of prompts:

- Local prompts: Project-specific prompts stored in your workspace
- Global prompts: User-wide prompts available across all projects
- MCP prompts: Prompts provided by MCP servers with enhanced functionality

## Commands

All prompt management is accessed through the `/prompts` command with various subcommands.

### List prompts

```
/prompts list

```

Displays all available prompts in a three-column layout showing names, descriptions, and sources. Shows prompt counts and indicates which prompts come from local storage, global storage, or MCP servers.

### Create prompts

```
/prompts create --name name [--content content]

```

Creates a new local prompt in the current workspace.

###### Parameters

`name` (required)
:   Prompt name (maximum 50 characters)

`--content content` (optional)
:   Direct content specification

**Behavior:**

- If --content is provided, creates prompt with specified content
- If no content provided, opens your default editor for content creation
- Prompts are saved to .kiro/prompts/ in the current workspace

### Edit prompts

```
/prompts edit name

```

Opens an existing prompt in your default editor for modification.

**Supported prompts:**

- Local workspace prompts
- Global user prompts
- MCP prompts (where supported by the server)

### View prompt details

```
/prompts details name

```

Shows comprehensive information about a prompt including:

- Metadata and argument details
- Complete prompt content before AI processing
- Parameter requirements and examples
- Source information (local, global, or MCP server)

## Using prompts

Once you've created prompts, invoke them in chat using the @ prefix:

```
@prompt-name

```

### Examples

```
@code-review
# Uses your local code-review prompt

```

```
@team-standup
# Uses your team-standup prompt

```

## Passing arguments to MCP prompts

MCP server prompts can accept arguments to customize their behavior. File-based prompts (local and global) do not support arguments.

### MCP prompt argument syntax

```
@server-name/prompt-name <required-arg> [optional-arg]

```

Use `/prompts details prompt-name` to discover what arguments an MCP prompt accepts.

```
# Example: Using MCP prompt with arguments
@dev-tools/analyze "performance issue" "detailed"
@security-tools/scan "web-app" "high-severity"

```

## Storage locations

### Local prompts (workspace-specific)

- Location: project/.kiro/prompts/
- Scope: Available only within the current project
- Priority: Highest (overrides global and MCP prompts with same name)

### Global prompts (user-wide)

- Location: ~/.kiro/prompts/
- Scope: Available across all projects
- Priority: Medium (overrides MCP prompts with same name)

### MCP prompts

- Source: Provided by configured MCP servers
- Scope: Depends on server configuration
- Priority: Lowest (overridden by local and global prompts)

## Priority system

When multiple prompts have the same name, the system uses this priority order:

1. Local prompts (highest priority)
2. Global prompts
3. MCP prompts (lowest priority)

This allows you to override MCP or global prompts with project-specific versions when needed.

## Enhanced features

### Content preview

The system displays the complete prompt content before sending it to the AI model, eliminating confusion about what information was actually processed.

### Improved error handling

- MCP server errors are converted to user-friendly messages
- Helpful usage examples are generated from prompt metadata
- Clear guidance for invalid parameters or missing requirements

### Visual formatting

- Consistent terminal styling across all prompt operations
- Proper content display for all prompt message types
- Three-column layout for improved readability in listings

## MCP integration

The prompt system seamlessly integrates with MCP servers:

- Automatic discovery: MCP prompts are automatically discovered from configured servers
- Enhanced UX: Improved user experience for MCP prompt management
- Error translation: Raw JSON errors are converted to actionable messages
- Content preview: Full content preview for MCP prompts before execution

## Examples

These examples demonstrate file-based prompt creation and MCP prompt usage.

### Basic file-based prompt creation and usage

```
# Create a simple prompt without arguments
/prompts create --name code-review --content "Please review this code for best practices, security issues, and potential improvements:"

# Use the prompt (no arguments supported for file-based prompts)
@code-review

```

### MCP prompt usage with arguments

```
# Using MCP prompts with arguments
@dev-tools/analyze "performance bottleneck" "cpu usage"
@security-tools/scan "web-app" "high-severity"
@aws-tools/deploy "my-service" "production" "us-west-2"

```

### Managing your taxes - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Managing your taxes

---

This section provides answers to tax collection, VAT, and billing address questions for Kiro.

## Why do I see information for Amazon web services, inc. For my Kiro purchase?

Amazon Web Services, Inc. is the service provider for Kiro. Amazon Web Services, Inc. ("AWSI") is established and operates in the United States. AWSI is registered for Sales Tax in the states shown [here](https://aws.amazon.com/tax-help/united-states/). AWSI is also registered for VAT in countries where indirect tax laws require foreign providers of Electronically Supplied Services ("ESS") to register and collect local VAT. AWSI treats Kiro as Downloaded Software in the USA and as ESS outside of the USA. If required by your country's Indirect Tax laws, AWS will collect Indirect Taxes from you, issue a tax invoice, and remit it to the tax authority in AWS's name. In some countries, AWS is not required to collect Indirect Taxes from you and remit it to the tax authority in AWS's name if you have a valid tax registration number ("TRN") in that country. You need to add your TRN to your Stripe Account Customer Profile, and you may be required to self-assess VAT depending on local regulations.

Please see below jurisdictions where tax will be charged on Kiro purchases:

| Country Name | Tax Collected From | Tax Rate |
| --- | --- | --- |
| AUSTRALIA | B2C | 10% |
| AUSTRIA | B2B/B2C | 20% |
| BANGLADESH | B2B | 15% |
| BELGIUM | B2B/B2C | 21% |
| BULGARIA | B2C | 20% |
| CANADA | B2B/B2C | Varies by Province |
| CHILE | B2C | 19% |
| CZECH REPUBLIC | B2B/B2C | 21% |
| FRANCE | B2C | 20% |
| GERMANY | B2C | 19% |
| INDIA | B2C | 18% |
| INDONESIA | B2B/B2C | 11% |
| ISRAEL | N/A | 18% |
| ITALY | B2C | 22% |
| JAPAN | B2B/B2C | 10% |
| KOREA (REPUBLIC OF KOREA) | B2C | 10% |
| MALAYSIA | B2B/B2C | 8% |
| NEPAL | B2B | 13% |
| NETHERLANDS | B2C | 21% |
| NEW ZEALAND | B2C | 15% |
| NORWAY | B2B/B2C | 25% |
| POLAND | B2C | 23% |
| PORTUGAL | B2B/B2C | 23% |
| ROMANIA | B2C | 19% |
| SINGAPORE | B2C | 9% |
| SOUTH AFRICA | B2B/B2C | 15% |
| SPAIN | B2C | 21% |
| SWEDEN | B2B/B2C | 25% |
| SWITZERLAND | B2B/B2C | 8.1% |
| TAIWAN | B2C | 5% |
| THAILAND | B2C | 7% |
| UK | B2C | 20% |
| UNITED ARAB EMIRATES | B2B/B2C | 5% |
| UNITED STATES (US) | B2B/B2C | Varies by state |

## How does AWS determine my location to determine the applicable taxes for my account(s)?

AWS will use your customer billing address you provide when purchasing Kiro. If the billing address entered is invalid, you will get a customer_tax_location_invalid error.

## I am a B2B (business) customer, my company's tax registration number (TRN) is on our stripe/AWS accounts, so why are we being charged VAT rather than using reverse charge and self-assessing VAT?

Kiro is billed using a different platform (not the AWS Console). If you are a B2B customer who has provided its TRN in your AWS Account, you will need to also include for your Kiro account through your customer portal. In addition, certain jurisdictions require AWS to charge and collect tax on both B2B and B2C purchases, in these jurisdictions AWS is responsible, and you will not be able to Self-Assess.

## If I update my tax, account, or billing address mid-month, how is VAT calculated?

AWS will use your billing address at the time of your purchase, or changes to your subscription such as upgrades or renewals.

## I receive special status/relief from paying VAT. How do I check that I am not charged VAT?

Special status/relief status from paying VAT is coming soon.

## What payment currencies and payment methods are supported by AWS inc. For Kiro purchases?

We accept all major credit cards. Kiro usage is invoiced in USD.

## My VAT invoice, and/or AWS seller appears incorrectly.

Please contact [Kiro billing support](https://support.aws.amazon.com/#/contacts/kiro).

## What tax registration numbers (trns) and formats are accepted?

Kiro will accept TRNs based on the requirements set forth by the country in which the customer is located. When a customer adds a TRN, Kiro will check that the formatting is correct.

### Model Context Protocol (MCP) - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Model Context Protocol (MCP)

---

Model Context Protocol (MCP) extends Kiro's capabilities by connecting to specialized servers that provide additional tools and context. This guide helps you set up, configure, and use MCP servers with Kiro CLI.

Within an interactive chat session, you can use the `/mcp` slash command to see which MCP servers are currently loaded. See [Slash Commands](/docs/cli/reference/slash-commands) for more details.

## What is MCP?

MCP is a protocol that allows Kiro to communicate with external servers to access specialized tools and information. For example, the AWS Documentation MCP server provides tools to search, read, and get recommendations from AWS documentation directly within Kiro.

With MCP, you can:

- Access specialized knowledge bases and documentation
- Integrate with external services and APIs
- Extend Kiro's capabilities with domain-specific tools
- Create custom tools for your specific workflows

## Setting up MCP

Before using MCP, make sure you have any specific prerequisites for the MCP servers you want to use (listed in each server's documentation)

There are two ways of configuring MCP servers in Kiro CLI:

### Command line

```bash
# Add new MCP server
kiro-cli mcp add \
  --name "awslabs.aws-documentation-mcp-server" \
  --scope global \
  --command "uvx" \
  --args "awslabs.aws-documentation-mcp-server@latest" \
  --env "FASTMCP_LOG_LEVEL=ERROR" \
  --env "AWS_DOCUMENTATION_PARTITION=aws"

```

### mcp.json file

MCP servers can be loaded from the MCP configuration file in your workspace (`<project-root>/.kiro/settings/mcp.json`) or from user level settings (`~/.kiro/settings/mcp.json`)

```json
{
  "mcpServers": {
    "local-server-name": {
      "command": "command-to-run-server",
      "args": ["arg1", "arg2"],
      "env": {
        "ENV_VAR1": "value1",
        "ENV_VAR2": "value2"
      },
      "disabled": false
    }
  }  
}

```

### Agent configuration

The `mcpServers` field specifies which MCP servers the agent has access to. Each server is defined with a command and optional arguments.

```json
{
  "name": "myagent",
  "description": "My special agent",
  "mcpServers": {
    "fetch": {
      "command": "fetch3.1",
      "args": []
    }
  },
  "includeMcpJson": false
}

```

The `includeMcpJson` field determines whether to include MCP servers defined in the workspace and user level MCP configuration files. When set to `true`, the agent will have access to all MCP servers defined in the user and workspace level configurations in addition to those defined in the agent's `mcpServers` field.

## Troubleshooting

### Common issues and solutions

| Issue | Solution |
| --- | --- |
| Connection failures | Verify prerequisites are installed correctly |
| Permission errors | Check that tokens and API keys are valid |
| Tool not responding | Review MCP logs for specific error messages |
| Configuration not loading | Validate JSON syntax and save the config file |

## Additional resources

- Official MCP Documentation

## Next steps

Now that you understand MCP basics, explore these resources:

- Examples - Practical examples of using MCP servers with Kiro CLI
- Security Best Practices - Best practices for secure MCP usage

### Upgrading from Amazon Q Developer CLI - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Upgrading from Amazon Q Developer CLI

---

## Overview

Kiro CLI is the next update of the Q CLI. Your existing Q Developer CLI workflows, subscription, and authentication continue to work without any changes.

Kiro CLI leverages the Auto agent to deliver the best results at the best price, and supports advanced agent functionality and technology similar to what customers are familiar with in the Q Developer CLI (including agent mode, MCP, steering, and custom agents). Existing Q Developer CLI users will find onboarding straightforward, with additional options for logging in via social accounts and GitHub.

Kiro CLI will be available starting **November 17th, 2025**. If you had auto-update enabled, then on **November 24th 2025** Q Developer CLI will be automatically updated to Kiro CLI. If you had disabled auto-update, then you have to manually update Q Developer CLI using `q update` or select "Check for updates" in the Amazon Q application.

If you're familiar with Amazon Q CLI, upgrading to Kiro CLI will feel natural. This guide highlights the key differences and helps you get started quickly.

## Key differences

Here is the side-by-side comparison of Kiro CLI and Amazon Q Developer

| Area | Kiro CLI | Q Developer CLI |
| --- | --- | --- |
| Installation | native install | dmg and zip based install |
| Authentication | GitHub, Gmail, BuilderId, IAM Identity Center | BuilderId, IAM Identity Center |
| Entry point | kiro-cli | q / q chat |
| Rules | Kiro steering | Amazon Q rules |
| Subscriptions | Q Developer and Kiro | Q Developer and Kiro |
| Features | MCP, Custom agents, hooks | MCP, Custom agents, hooks |
| License | AWS Intellectual Property License | Apache |

See the [Authentication guide](/docs/cli/authentication) for details.

## Frequently asked questions

**1. What is Kiro, and how does it relate to Q Developer?**

Kiro is a standalone agentic development experience that helps you go from concept to production with spec-driven development. From simple to complex tasks, Kiro works alongside you to turn prompts into detailed specs, then into working code, docs, and tests—so what you build is exactly what you want and ready to share with your team. Kiro leverages some of the advanced Q Developer functionality and technology (agent mode, MCP, steering, CLI) and adds a streamlined but opinionated developer experience for working with AI which feels familiar because it's based on Q Developer CLI.

**2. How will I upgrade from Q Developer CLI to the Kiro CLI?**

You can simply do `q update` or enable auto-update to switch to Kiro CLI.

**3. What if I don’t want to upgrade to the Kiro CLI? Can I keep my Q Developer CLI access?**

Yes, you can continue to use Amazon Q Developer CLI. However, new features and fixes will only be available for Kiro CLI, which leverages some of the underlying agentic CLI features of Q CLI in a streamlined developer experience. Existing Q Developer CLI users will find the experience familiar, and onboarding straightforward, so we strongly recommend they should consider switching.

**4. What terms will apply to Kiro CLI?**

Just like with Q Developer CLI, your use of the underlying agentic capabilities in Kiro CLI is subject to the AWS Customer Agreement (or other agreement with us governing your use of AWS services) and Service Terms. However, the Kiro CLI software is licensed under the AWS Intellectual Property License, while the Q Developer CLI software was licensed under Apache 2.0.

**5. What is the impact to my current usage of Amazon Q Developer CLI? Do I have to change my automation and configuration files?**

Kiro CLI is backwards compatible with Amazon Q Developer CLI. You can still continue using the `q` and `q chat` entry points. All the functionality in Amazon Q Developer CLI is available in Kiro CLI. You can continue using Amazon Q rules and configuration with Kiro CLI.

**6. What will change when I switch to Kiro CLI?**

We are making it easy for your team to work with Kiro regardless of whether developers prefer Kiro IDE or Kiro CLI. To learn more about the changes, review the [changes in detail](#kiro-cli-changes).

**7. Will Kiro CLI work with my Q Developer Pro subscription?**

Yes, you can use Kiro CLI with your Q Developer Pro subscription. Kiro CLI will also support a Kiro subscription.

**8. How does Kiro pricing work?**

Kiro offers flexible pricing tiers designed around how developers use Kiro. For more on pricing, see [https://kiro.dev/pricing/](https://kiro.dev/pricing/).

**9. As a current Q Developer Pro subscription user, why should I consider upgrading to a paid Kiro subscription plan?**

Kiro offers 3 different pricing tiers that better map to developer needs, and each pricing tier supports overages. Overages are not supported with the Q Developer Pro subscription plan.

**10: As a current Q Developer Pro user, what is the process for upgrading to a Kiro subscription plan?**

The Kiro dashboard will show the subscriptions for both Kiro and Q Developer separately. For every group or user, an admin can go to their Q subscriptions, select them and upgrade to a Kiro subscription. Changes in subscription will move groups and users from the subscription tab under Q Developer to the subscription tab in Kiro. Customers can migrate users as they see fit, across an entire profile from a member account, or across groups or individual users from the same profile. Upgrades happen at a user level, so customers have fine-grained control over the migration process.

**11. Do you provide an output indemnity for Kiro subscribers? If I’m a Q Developer Pro tier user and I upgrade to a paid Kiro subscription, does the output indemnity apply to me?**

Yes, just like we do for Q Developer Pro users, we provide an output indemnity for paid Kiro subscribers. See Section 50.10 of the Service Terms for more details.

**12. Does Kiro use my content to train any models?**

We do not use content from Kiro Pro, Pro+, or Power users that access Kiro through AWS IAM Identity Center. If you have an Amazon Q Developer Pro subscription and access Kiro through your AWS account with the Amazon Q Developer Pro subscription, then Kiro will not use your content for service improvement. We may use certain content from Kiro Free Tier and Kiro individual subscribers (those that access Kiro through a social login provider or AWS Builder ID) for service improvement.

**13. Can I control telemetry sharing (usage data, performance metrics) for Kiro at the Org level?**

We do not collect telemetry from Kiro Pro, Pro+, or Power users that access Kiro through AWS IAM Identity Center. However, enterprise admins can configure Kiro to collect user activity reports for the users in your org.

**14. Can I go back to Amazon Q Developer CLI?**

To install Amazon Q Developer CLI, download the binary for your platform/OS. Uninstall Kiro CLI using `kiro-cli uninstall` and install the Amazon Q Developer CLI.

You can download Amazon Q Developer CLI v1.19.7 for the specific platform:

- MacOS
- Linux x86-64
- Linux ARM

Any new prompts, agents and steering files you created using Kiro CLI will not be available in Amazon Q Developer CLI. Refer to the configuration file path section to copy files.

## Kiro CLI Changes

### One-time migration during Kiro CLI installation

Here's what happens during the one-time migration when you install Kiro CLI:

1. Prompts, agents from ~/.aws/amazonq folder are copied to ~/.kiro folder with the same names
2. MCP configuration from ~/.aws/amazonq/mcp.json is copied to ~/.kiro/settings/mcp.json. If there are conflicts, skip copying those MCP servers
3. Files from rules folder in ~/.aws/amazonq folder are copied to ~/.kiro/steering folder with the same names
4. A cli.json file is created with settings from Amazon Q Developer CLI
5. Kiro CLI will continue to read .amazonq folder in your project. So your existing rules, agents, and MCP settings in your project will continue to work as-is
  - If you save a new prompt or agent configurations, they will be saved to .kiro folder in your projeect.
  - If both folders exist in your project, we'll read from .kiro folder

When you add new project level prompts or agents, they will be saved to the `.kiro` folder in the project and not `.amazonq` folder

1. q and q chat will continue to work, although we recommend using kiro-cli (both kiro-cli and kiro-cli chat will work)
2. Tools names have been simplified, but existing tool names will continue to work:
  - Changes -> fs_read to read, fs_write to write , use_aws to aws, execute_bash to shell, report_issue to report

### Configuration file paths

Kiro CLI uses different configuration paths than Amazon Q Developer CLI, but maintains backward compatibility:

| Configuration | Scope | Kiro CLI | Q Developer CLI |
| --- | --- | --- | --- |
| MCP servers | User | ~/.kiro/settings/mcp.json | ~/.aws/amazonq/mcp.json |
|  | Workspace | .kiro/settings/mcp.json | .amazonq/mcp.json |
| Prompts | User | ~/.kiro/prompts | ~/.aws/amazonq/prompts |
|  | Workspace | .kiro/prompts | .amazonq/prompts |
| Custom agents | User | ~/.kiro/agents | ~/.aws/amazonq/cli-agents |
|  | Workspace | .kiro/agents | .amazonq/cli-agents |
| Rules / Steering | User | ~/.kiro/steering | ~/.aws/amazonq/rules |
|  | Workspace | .kiro/steering | .amazonq/rules |
| Settings | Global | ~/.kiro/settings/cli.json | - |

### Important changes

- Kiro CLI will not modify your existing .amazonq folders
- Authentication and subscription management will use Kiro web portal
- MCP servers, agents, rules, and prompts automatically copied from ~/.aws/amazonq folder to the appropriate folders (refer above) in ~/.kiro during installation
- Logs will be written to $TMPDIR/kiro-log
- Tool names are different, but are backwards compatible so that your existing custom agents will continue to work
- Default agent name changed to kiro_default. Default agent includes paths for both Amazon Q and Kiro.
  - /agent list will list kiro_default as an agent with "No path found", because the agent configuration is in memory.
- UI with updated colors and names
- Default agent will support both Amazon Q rules and Kiro steering
- Kiro CLI supports Gmail and GitHub authentication alongside Builder ID and IAM Identity Center

If your project has both `.kiro` and `.amazonq` folders, configuration will be loaded from the `.kiro` folder. You will see a warning about this when you start a new session.

### Getting help

If you encounter issues during migration:

1. Check the CLI Commands Reference
2. Review Chat documentation
3. Contact support through the Kiro dashboard

### Next steps

- Explore Chat features
- Learn about Custom Agents
- Try MCP integration
- Set up Agent Hooks

### Model selection - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Model selection

---

Kiro provides multiple powerful AI agent options to handle your development tasks: **Auto**, **Claude Sonnet 4.0**, **Claude Sonnet 4.5**, **Claude Haiku 4.5**, and **Claude Opus 4.5**. Each offers distinct advantages depending on your needs and usage patterns.

## Available models

### Auto (recommended)

Auto is Kiro's default intelligent model router that combines multiple frontier models with advanced optimization techniques.

**Key benefits:**

- Cost-effective – Approximately 23% less expensive than direct Sonnet 4 usage
- Smart routing – Automatically chooses the optimal model for each task
- Consistent quality – Delivers Sonnet 4-level results across different task types
- Plan efficiency – Makes your usage limits go further

#### What model does Auto use?

Auto uses best in class LLM models (Claude Sonnet 4 and alike) to provide you the best quality for the type of tasks assigned to the agent. We maintain a very high bar to ensure that the quality of what is offered under Auto compares to or exceeds the quality of separate models made available to our users.

### Claude Sonnet 4.0

Direct access to Anthropic's Claude Sonnet 4.0 model for users who prefer consistent model selection or have specific requirements for using this particular model.

**Key benefits:**

- Predictable behavior – Same model for all interactions
- Direct access – No routing or optimization layers
- Full control – Complete transparency in model selection

### Claude Sonnet 4.5

Anthropic's best model for complex agents and coding, with the highest intelligence across most tasks.

**Key benefits:**

- Coding excellence – Advanced state-of-the-art on SWE-bench Verified
- Agent capabilities – Extended autonomous operation for hours with effective tool usage
- Enhanced reasoning – Improved planning, system design, and security engineering

### Claude Opus 4.5

Anthropic's most intelligent model combining maximum capability with practical performance. Ideal for complex specialized tasks, professional software engineering, and advanced agents.

Claude Opus 4.5 is available exclusively to Pro, Pro+, and Power tier subscribers.

**Key benefits:**

- Maximum intelligence – Step-change improvements in reasoning, coding, and problem-solving
- Practical performance – More accessible price point than previous Opus models
- Complex reasoning – Better balance of tradeoffs and ambiguity across multiple systems

### Claude Haiku 4.5

Anthropic's fastest and most intelligent Haiku model with near-frontier performance. Delivers intelligence matching Sonnet 4 at significantly lower cost and faster speed.

**Key benefits:**

- Near-frontier intelligence – Matches Sonnet 4 performance across reasoning and coding
- Blazing speed – More than twice the speed of Sonnet 4
- Cost-effective – Near-frontier intelligence at one-third the cost
- Extended thinking – First Haiku model with advanced reasoning capabilities

## Cost comparison

Understanding the credit consumption differences:

| Model | Credit Usage | Example Task Cost |
| --- | --- | --- |
| Claude Haiku 4.5 | 0.4x | 4 credits |
| Auto | 1.0x | 10 credits |
| Claude Sonnet 4.0 | 1.3x | 13 credits |
| Claude Sonnet 4.5 | 1.3x | 13 credits |
| Claude Opus 4.5 | 2.2x | 22 credits |

## Choosing the right model

### Claude Haiku 4.5

Consider using Haiku 4.5 when:

- Speed is critical – You need fast responses for interactive experiences
- Cost efficiency matters – Near-frontier intelligence at one-third the cost
- High-volume processing – Cost-effective intelligence for large-scale deployments
- Real-time applications – Fast turnaround for user-facing features

### Auto

Consider using Auto when:

- Cost efficiency matters – You want to maximize your plan's value
- General development work – Most coding, debugging, and planning tasks
- Variable task types – Working on diverse projects with different requirements
- Plan optimization – You want your limits to stretch further

### Sonnet 4.0 & Sonnet 4.5

Consider using Sonnet 4.0 or Sonnet 4.5 when:

- Consistency is critical – You need predictable model behavior
- Specific requirements – Your workflow depends on Sonnet 4's particular capabilities
- Model transparency – You prefer knowing exactly which model handles each request
- Budget flexibility – Higher costs aren't a primary concern

### Claude Opus 4.5

Consider using Opus 4.5 when:

- Maximum intelligence needed – Most complex specialized tasks requiring top-tier reasoning
- Professional software engineering – Sophisticated production development challenges
- Advanced agents – Long-running autonomous tasks with complex decision-making
- Critical implementations – High-stakes features where quality is paramount

## How to switch models

### In the chat interface

### Kiro CLI setting

```bash
kiro-cli settings chat.defaultModel claude-sonnet4

```

### Persisting your model selection

To save your current model as the default for all future sessions:

```bash
> /model set-current-as-default

```

This stores your preference in `~/.kiro/settings/cli.json`. New sessions will automatically use this model.

## Best practices

### Maximizing efficiency

- Start with Auto – Use it as your default for most tasks
- Use Haiku for speed – Near-frontier intelligence with fast responses and lower cost
- Use Sonnet for agents – Best for complex coding and autonomous workflows
- Reserve Opus for maximum intelligence – Use for the most complex specialized tasks
- Monitor usage – Track how different models affect your plan consumption
- Experiment – Try different models for similar tasks to compare results

### Cost management

- Plan accordingly – Factor model choice into your tier selection
- Track patterns – Understand which tasks benefit most from each model
- Optimize workflows – Adjust development practices based on model strengths
- Consider overages – Enable if you need flexibility beyond plan limits

### Monitoring and tracking - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Monitoring and tracking

Monitoring is an important part of maintaining the reliability, availability, and performance of Kiro and your other AWS solutions. Kiro includes the following features to help you track and record user activity:

- A dashboard shows you aggregate user activity metrics of Kiro subscribers. For more information, see Viewing Kiro usage on the dashboard.
- User activity reports show you what individual users are up to in Kiro. For more information, see Viewing per-user activity.
- Prompt logs provide you with a record of all the prompts that users enter into the Kiro chat in their integrated development environment (IDE). For more information, see Logging users' prompts.

AWS also provides the following tools and features to monitor and record Kiro activity:

- AWS CloudTrail captures API calls and related events made by or on behalf of your AWS account and delivers the log files to an Amazon Simple Storage Service (Amazon S3) bucket that you specify. You can identify which users and accounts called AWS, the source IP address from which the calls were made, and when the calls occurred.
- Amazon CloudWatch monitors your AWS resources and the applications you run on AWS in real time. You can collect and track metrics, create customized dashboards, and set alarms that notify you or take actions when a specified metric reaches a threshold that you specify. For example, you can have CloudWatch track the number of times that Kiro has been invoked on your account, or the number of daily active users.

---

### Managing tool permissions - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Managing tool permissions

---

You can use the `/tools` command to manage permissions for tools that
Kiro uses to perform actions on your system. This provides granular control over what
actions Kiro can perform.

Tools commands

| Command | Description |
| --- | --- |
| help | Shows help related to tools. |
| trust | Trusts a specific tool for the session. |
| untrust | Reverts a tool to per-request confirmation. |
| trust-all | Trusts all tools (equivalent to deprecated /acceptall). |
| reset | Resets all tools to default permission levels. |

To view the current permission settings for all tools:

```
$ kiro-cli chat
Kiro> /tools

```

This displays a list of all available tools and their current permission status
(trusted or per-request).

Tool permissions have two possible states:

- Trusted: Kiro can use the tool without asking for confirmation each time.
- Per-request: Kiro must ask for your confirmation each time before using the tool.

To trust or untrust a specific tool for the current session:

```
Kiro> /tools trust read
Kiro> /tools untrust shell

```

You can also trust all tools at once with `/tools trust-all`(equivalent to
the deprecated `/acceptall` command):

```
Kiro> /tools trust-all

```

###### Warning

Using `/tools trust-all` carries risks. For more information, see [Using /tools trust-all safely](/docs/cli/chat/security/#using-tools-trust-all-safely)
.

The following image shows the status of the CLI tools when they are all in their default trust
status.

The following tools are natively available for Kiro to use:

Available tools

| Tool | Description |
| --- | --- |
| read | Reads files and directories on your system. |
| write | Creates and modifies files on your system. |
| shell | Executes bash commands on your system. |
| aws | Makes AWS CLI calls to interact with AWS services. |
| report | Opens a browser to report an issue with the chat to AWS. |

When Kiro attempts to use a tool that doesn't have explicit permission, it will ask
for your approval before proceeding. You can choose to allow or deny the action, or
trust the tool for the remainder of your session.

Each tool has a default trust behavior. `read` is the only tool that is
trusted by default.

Here are some examples of when to use different permission levels:

- Trust fs_read: When you want Kiro to read files without confirmation, such as when exploring a codebase.
- Trust fs_write: When you're actively working on a project and want Kiro to help you create or modify files.
- Untrust execute_bash: When working in sensitive environments where you want to review all commands before execution.
- Untrust use_aws: When working with production AWS resources to prevent unintended changes.

When Kiro uses a tool, it shows you the trust permission being used.

You can also specify trust permissions as part of starting a `kiro-cli chat`
session.

### Plan agent - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Plan agent

---

The Plan agent is a specialized built-in agent that helps transform ideas into structured implementation plans. It guides you through requirements gathering, research, and creates detailed task breakdowns before switching to execution mode.

## Getting started

### Keyboard shortcut

Press `Shift + Tab` to toggle between plan and execution modes.

### Slash command

```bash
> /plan

Switched to the Kiro [plan] agent. Transform any idea into fully working code.
What do you want to build today?

[plan] >

```

### With immediate prompt

```bash
> /plan Build a REST API for user authentication

```

When active, you'll see:

- [plan] indicator in your prompt
- Welcome message when switching modes

## Plan workflow

### 1. Requirements gathering

The planner guides you through structured questions to refine your initial idea.

```bash
[plan] > I want to build a todo app

I understand you want to build a todo app. Let me help you plan this
implementation.

**My Understanding:** You want to create a todo application for managing tasks.

Let me gather some requirements to create a detailed plan:

[1]: What platform should this todo app target?
a. **Web Application** - Browser-based with HTML/CSS/JavaScript
b. **Mobile App** - Native iOS/Android or cross-platform
c. **Desktop App** - Electron, Tauri, or native desktop
d. **CLI Tool** - Command-line interface
e. **Other** - Provide your own answer

[2]: What's the primary use case for this todo app?
a. **Personal Task Management** - Individual productivity
b. **Team Collaboration** - Shared tasks and assignments
c. **Project Management** - Complex workflows with dependencies
d. **Other** - Describe your specific needs

(Use the chat to answer any subset: eg., "1=a, 2=b" or provide your own answers)

```

| Feature | Description |
| --- | --- |
| Structured questions | Clear, numbered questions with multiple choice options |
| Flexible responses | Answer individual questions or provide custom responses |
| Iterative process | Builds understanding through multiple rounds of questions |
| Context awareness | Adapts follow-up questions based on your answers |

### 2. Research and analysis

The planner explores your codebase and researches relevant technologies.

| Capability | Description |
| --- | --- |
| Code exploration | Uses code, grep, and glob tools to understand existing code |
| Technology research | Identifies relevant frameworks, libraries, and patterns |
| Architecture analysis | Reviews existing project structure and conventions |

### 3. Implementation plan

Creates a detailed, step-by-step implementation plan with clear objectives.

```bash
**Implementation Plan - Todo CLI Command**

**Problem Statement:** Add todo management to existing Kiro CLI for task tracking.

**Requirements:**
- CLI commands for CRUD operations
- Local SQLite storage
- Priority and due date support

**Task Breakdown:**

Task 1: Create database schema and models
- Define Todo struct with required fields
- Create database migration for todos table
- Demo: Can create and query todos in database

Task 2: Implement CLI command structure
- Add todo subcommand with add/list/complete operations
- Demo: CLI accepts todo commands and shows help

Task 3: Add advanced features
- Implement due dates and priority sorting
- Demo: Complete todo system with all features

```

Each task includes:

- Clear objectives - Specific, measurable goals
- Implementation guidance - General approach and key considerations
- Demo description - Working functionality that can be demonstrated

### 4. Plan approval and handoff

Before switching to execution, the planner seeks your approval.

```bash
[plan] > Does this plan look good, or would you like me to adjust anything?

> The plan looks great! Let's implement it.

*Planning complete!* Ready to exit [plan] agent to start your implementation? [y/n]:

> y

```

The handoff process:

1. You approve the implementation plan
2. Interactive prompt confirms switching to execution
3. Automatically transitions back to previous agent
4. Complete plan is passed to the execution agent

## Read-only design

The Plan agent operates in read-only mode to keep focus on planning.

| Operation | Status |
| --- | --- |
| File reading | ✓ Full access to explore codebase |
| Code intelligence | ✓ LSP operations for understanding code structure |
| Search (grep, glob) | ✓ Code exploration |
| Web search | ✓ Documentation and research access |
| File writing | ✗ Cannot create or modify files |
| Command execution | ✗ Limited to read-only bash commands |
| MCP tools | ✗ Cannot use MCP tools |

## Best practices

1. Use for complex tasks - Most valuable for multi-step implementations
2. Engage with questions - Answer structured questions thoughtfully
3. Let it explore - Allow planner to analyze your existing codebase
4. Review plans - Ensure plan matches expectations before handoff
5. Iterate as needed - Continue refining until plan is clear

## Troubleshooting

| Issue | Solution |
| --- | --- |
| How to exit plan agent? | Use Shift + Tab to return to your previous agent. |
| Planning session interrupted | Use /plan to re-enter planning and continue where you left off. |
| Plan not transferring to execution agent | Make sure to respond "y" when prompted with "Ready to exit [plan] agent to start your implementation? [y/n]". |

## Example workflow

```bash
> /plan Add user authentication to my web app

[plan] > I understand you want to add user authentication to your web application.

**My Understanding:** You want to implement user authentication functionality
for an existing web application.

[1]: What authentication method do you prefer?
a. **Email/Password** - Traditional username and password
b. **OAuth** - Google, GitHub, or other OAuth providers
c. **Magic Links** - Passwordless email-based authentication
d. **Multi-factor** - Combination of methods with 2FA

> 1=a

[plan] > Great! Email/password authentication it is.

[2]: What's your current tech stack?
a. **React + Node.js** - JavaScript full-stack
b. **Next.js** - React with server-side rendering
c. **Django/Flask** - Python web framework
d. **Other** - Please specify

> 2=d, I'm using Rust with Axum framework

[plan] > Perfect! Rust with Axum is an excellent choice for secure authentication.

*Researching Axum authentication patterns...*
*Exploring your existing codebase structure...*

**Implementation Plan - User Authentication System**
[Detailed plan follows...]

Does this plan look good, or would you like me to adjust anything?

> Looks perfect!

Ready to exit [plan] agent to start your implementation? [y/n]: y

[default] > Implement this plan: [Plan content transferred to execution agent]

```

### Privacy and security - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Privacy and security

---

Kiro is an AWS application that works as a standalone agentic IDE. Kiro's security framework is built around AWS's security infrastructure and follows practices to protect your development environment and data. Cloud security at AWS is the highest priority. As an AWS customer, you benefit from a data center and network architecture that is built to meet the requirements of the most security-sensitive organizations.

Security is a shared responsibility between AWS and you. The [shared responsibility model](https://aws.amazon.com/compliance/shared-responsibility-model/) describes this as security of the cloud and security in the cloud:

- Security of the cloud – AWS is responsible for protecting the infrastructure that runs AWS services in the AWS Cloud. AWS also provides you with services that you can use securely. Third-party auditors regularly test and verify the effectiveness of our security as part of the AWS Compliance Programs. To learn about the compliance programs that apply to Kiro, see AWS Services in Scope by Compliance Program.
- Security in the cloud – Your responsibility is determined by the AWS service that you use. You are also responsible for other factors including the sensitivity of your data, your company’s requirements, and applicable laws and regulations

This documentation helps you understand how to apply the shared responsibility model when using Kiro. It shows you how to configure Kiro to meet your security and compliance objectives. You also learn how to use other AWS services that help you to monitor and secure your Kiro resources.

## URL fetching

In the Kiro chat module, you can paste a specific URL for your device to fetch and use it as context to help Kiro answer your query or solve your task. You are responsible for the URL content that you fetch and ensuring that your use complies with any applicable third-party terms and laws.

## Autopilot versus supervised mode

In Kiro, Autopilot is enabled by default. You can toggle between Autopilot and Supervised mode at any time. Autopilot mode enables the agent to execute code changes, such as creating, modifying, searching, and deleting files in your codebase and run commands that impact the filesystem.

### Autopilot mode

In Autopilot mode, Kiro works autonomously:

- Kiro executes multiple steps without requiring approval for each one
- Kiro makes decisions based on its understanding of your requirements
- You can toggle autopilot on/off in the chat interface
- You can interrupt autopilot at any time to regain manual control

### Supervised mode

In supervised mode, Kiro works interactively with the user, requiring their approval and guidance at each step:

- Kiro suggests actions such as file creation, modification and deletion, but waits for user confirmation before proceeding
- Kiro asks clarifying questions when needed
- You can review and approve each generated document or code change, thus maintaining full control over the development process

When operating in either of these modes, you can view individual or all file changes made by the agent by selecting **View all changes** in the **Chat** module. Additionally, you can also select **Revert all changes** or revert to a [checkpoint](/docs/chat/checkpoints) to restore your files to their previous state in the filesystem locally.

## Trusted commands

By default, Kiro requires approval before running any command. You can create your own trusted commands list by searching for **Kiro Agent: Trusted Commands** in your settings.

Kiro uses simple string prefix matching to determine if a command should be automatically trusted:

- Exact matching: Commands must match exactly (e.g., npm install)
- Wildcard matching: Use * to trust command variations (e.g., npm * trusts all npm commands)
- Universal trust: Use * alone to trust all commands (use with extreme caution)

The system treats entire commands as single strings and only checks if they start with trusted patterns. It does not analyze command structure, chains, or special characters, putting full responsibility on you to carefully configure trusted patterns.

## Best practices

Kiro provides a number of security features to consider as you develop and implement your own security policies. The following best practices are general guidelines and don’t represent a complete security solution. Because these best practices might not be appropriate or sufficient for your environment, treat them as helpful considerations rather than prescriptions.

### Protecting your resources

When using GitHub or Google authentication with Kiro, be aware that the Kiro agent operates within your local environment and may access:

- Local files and repositories
- Environment variables
- AWS credentials stored in your environment
- Other configuration files with sensitive information

### Recommendations

1. Workspace Isolation
  - Keep sensitive projects in separate workspaces
  - Use .gitignore to prevent access to sensitive files
  - Consider using workspace trust features in your IDE
2. Use a Clean Environment
  - Consider creating a dedicated user account or container environment for Kiro
  - Limit access to only the repositories and resources needed for your current project
3. Manage AWS Credentials Carefully
  - Use temporary credentials with appropriate permissions
  - Consider using AWS named profiles to isolate Kiro's access
  - For sensitive work, remove AWS credentials from your environment when not needed
4. Repository Access Control
  - When using GitHub authentication, review which repositories Kiro can access
  - Use repository-specific access tokens when possible
  - Regularly audit access permissions

## Remote extensions security

**Security Note**: Using remote extensions opens a connection between your local machine and the remote machine. Only connect to secure remote machines that you trust and that are owned by a party whom you trust. A compromised remote could use the connection to execute code on your local machine.
Third-party extensions including remote extensions are not developed, maintained, or managed by Kiro. We are not responsible for third-party extensions and cannot guarantee their stability, compatibility, or ongoing support.

Kiro supports Open VSX extensions, including remote SSH extensions (the community-maintained [Open Remote - SSH](https://open-vsx.org/extension/jeanp413/open-remote-ssh) extension on Open VSX is a popular choice), to provide a familiar development experience. For comprehensive information about extension compatibility and support in Kiro, see our [extension compatibility guide](/docs/guides/migrating-from-vscode/#extension-compatibility).

By following these practices, you can enjoy Kiro's capabilities while maintaining appropriate security boundaries for your development environment.

### Logging user prompts - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Logging user prompts

---

Kiro admins can enable the logging of all inline suggestions and chat conversations that users have in the Kiro IDE. These logs can help with auditing, debugging, analytics, and ensuring compliance.

## About prompt logs

With prompt logging enabled, Kiro will log both the user prompts and Kiro's responses. Kiro stores the logs in an Amazon S3 bucket of your choice in your own account. For examples and explanations of log file contents, see [prompt log examples](#prompt-log-examples).

There is no charge for the prompt logging feature other than the storage cost of the Amazon S3 bucket used to hold the logs, and a small fee for the optional KMS key used to encrypt the bucket.

## Enabling prompt logging

### Prerequisites

- Create an Amazon S3 bucket to hold the prompt logs. The bucket must:
  - Be in the AWS Region where the Kiro profile was installed. This profile was installed when you subscribed users to Kiro Pro for the first time. For more information about this profile and the Regions where it's supported, see Concepts and Supported Regions.
  - Be in the AWS account where users are subscribed.
  - Have a bucket policy like the one that follows. Replace bucketName, Region, accountId, and prefix with your own information.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "KiroLogsWrite",
      "Effect": "Allow",
      "Principal": {
        "Service": "q.amazonaws.com"
      },
      "Action": [
        "s3:PutObject"
      ],
      "Resource": [
        "arn:aws:s3:::bucketName/prefix/*"
      ],
      "Condition": {
        "StringEquals": {
          "aws:SourceAccount": "111122223333"
        },
        "ArnLike": {
          "aws:SourceArn": "arn:aws:codewhisperer:us-east-1:111122223333:*"
        }
      }
    }
  ]
}

```

To learn about protecting the data in your Amazon S3 bucket, see [Protecting data with encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingEncryption.html) in the *Amazon Simple Storage Service User Guide*.

### To enable prompt logging

1. Open the Kiro console.
2. Choose Settings.
3. Look for Kiro Settings > Logging.
4. Toggle the switch for Log Kiro prompts with metadata.
5. Under Amazon S3 location, enter the Amazon S3 URI that you will use to receive the logs. Example: s3://amzn-s3-demo-bucket/kiro-prompt-logs/

## Prompt log examples

This section provides examples of prompt logs generated by Kiro.

Following each example is a table that describes the log file's fields.

### Inline suggestions log example

The following example shows a log file that is generated when a user accepts an inline suggestion.

```json
{
  "records": [
    {
      "generateCompletionsEventRequest": {
        "leftContext": "import * cdk from 'aws-cdk-lib';\r\nimport * s3 from 'aws-cdk-lib/aws-s3';\r\nimport { Stack, StackProps } from 'constructs';\r\nexport class MyStack extends Stack {\r\n  constructor(scope: cdk.App, id: string, props?: StackProps) {\r\n    super(scope, id, props);\r\n\r\n    new s3.Bucket(this, 'XXXXXXXX', {\r\n      versioned: true\r\n    });\r\n  }\r\n ",
        "rightContext": "",
        "fileName": "cdk-modified.ts",
        "customizationArn": null,
        "userId": "d-92675051d5.b8f1f340-9081-70ad-5fc5-0f37151937a6",
        "timeStamp": "2025-01-06T15:09:16.412719Z"
      },
      "generateCompletionsEventResponse": {
        "completions": ["synth() {\n    return cdk.App.prototype.synth.apply(this, arguments);\n  }"],
        "requestId": "797c70ee-abc9-4cc7-a148-b9df17f6ce48"
      }
    }
  ]
}

```

The following table describes the fields in the log file for inline suggestions.

| Field name | Description |
| --- | --- |
| records | Top-level field that contains a set of inline suggestions, also known as inline completions. |
| generateCompletionsEventRequest | Describes the request for an inline code suggestion. The request is made by Kiro, on behalf of the user. |
| leftContext | Indicates the code before the cursor that Kiro is using for context to generate an inline suggestion. |
| rightContext | Indicates the code after the cursor that Kiro is using for context to generate an inline suggestion. |
| fileName | Indicates the name of the file in which an inline suggestion was requested. |
| userId | Indicates the user ID of the user who requested an inline suggestion. |
| timeStamp | Indicates the date and time that the inline suggestion was requested. The timestamp is in Coordinated Universal Time (UTC). |
| generateCompletionsEventResponse | Describes the inline suggestion generated by Kiro. |
| completions | Indicates the inline suggestion that Kiro provided and that the user accepted. |
| requestId | The ID of the inline request that uniquely identifies the event. |

### Chat log example

The following example shows a log file that is generated when a user chats using Kiro in their IDE.

```json
{
  "records": [
    {
      "generateAssistantResponseEventRequest": {
        "prompt": "Can you explain how to set up object-level access control in an S3 bucket using AWS CDK?",
        "chatTriggerType": "MANUAL",
        "customizationArn": null,
        "userId": "d-92675051d5.b8f1f340-9081-70ad-5fc5-0f37151937a6",
        "timeStamp": "2025-01-06T15:05:56.313070Z"
      },
      "generateAssistantResponseEventResponse": {
        "assistantResponse": "I'll explain how to set up object-level access control for an S3 bucket using AWS CDK...",
        "followupPrompts": "How can you implement multi-factor authentication for S3 bucket access using AWS CDK?",
        "messageMetadata": {
          "conversationId": "491bd3cd-d70d-40c0-a452-5ef3f0878422",
          "utteranceId": null
        },
        "codeReferenceEvents": [],
        "supplementaryWebLinksEvent": [
          {
            "uri": "https://docs.aws.amazon.com/AmazonS3/latest/API/s3_example_s3_Scenario_ManageACLs_section.html",
            "title": "[1] Manage access control lists (ACLs) for Amazon S3 buckets using an AWS SDK",
            "snippet": "The following code example shows how to manage access control lists (ACLs) for Amazon S3 buckets..."
          }
        ],
        "requestId": "dad38fc0-815c-45f7-970a-db916cb7f131"
      }
    }
  ]
}

```

| Field name | Description |
| --- | --- |
| records | Top-level field that contains a set of prompts and responses. |
| generateAssistantResponseEventRequest | Describes the prompt entered by the user in the chat window in their IDE. |
| prompt | Indicates the prompt the user entered into the chat window. |
| chatTriggerType | MANUAL indicates that the user entered a prompt into the chat window, or clicked on one of the suggested questions in the chat window. INLINE_CHAT indicates that the user entered a prompt into the small input screen in the main coding window. |
| userId | Indicates the user ID of the user who entered the prompt. |
| timeStamp | Indicates the date and time that the user entered the prompt. The timestamp is in universal time (UTC). |
| generateAssistantResponseEventResponse | Describes the response generated by Kiro. |
| assistantResponse | Indicates the response that Kiro provided to the user's prompt. |
| followupPrompts | Indicates the follow-up example prompts that were displayed to the user at the end of the response. |
| messageMetadata | Describes metadata associated with the response. |
| conversationId | Indicates the conversation ID of the response. The conversation ID groups together messages in a chat session. |
| utteranceId | Indicates the utterance ID of the response. An utterance ID is a label that distinguishes one prompt from another within a dialogue or data set. |
| codeReferenceEvents | Describes links to code references included in the response. |
| supplementaryWebLinksEvent | Indicates the links that were displayed to the user at the end of the response. |
| requestId | The ID of the response that uniquely identifies the event. |

### MCP Registry - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# MCP Registry

---

Enterprise MCP server governance allowing administrators to control which servers users can access.

If you're an administrator setting up the MCP registry, see [MCP Governance](/docs/cli/mcp/governance) for configuration instructions.

## Overview

Pro-tier customers using IAM Identity Center can have MCP server access controlled through an MCP registry. When configured by administrators, users can only use MCP servers explicitly allowed in the registry. Provides centralized governance for enterprise deployments.

## How it works

**Without Registry** (default):

- Users can add any MCP server
- Servers configured in agent files or via CLI
- No central control

**With Registry** (enterprise):

- Administrator configures allowed servers
- Users select from registry list
- Cannot add custom servers
- Centralized governance and security

## Adding servers

### In chat

```
/mcp add

```

Shows interactive list of servers from organization's registry.

### From command line

```bash
# Add specific server
kiro-cli mcp add --name myserver

# Add to workspace
kiro-cli mcp add --scope workspace

# Add to specific agent
kiro-cli mcp add --agent myagent

# Interactive selection
kiro-cli mcp add

```

Server name must match registry. Cannot add custom servers in registry mode.

## Removing servers

### In chat

```
/mcp remove

```

Interactive menu to select server to remove.

### From command line

```bash
kiro-cli mcp remove --name <server-name>

```

## Viewing available servers

### In chat

```
/mcp list

```

Shows:

- All locally configured MCP servers
- Server status and configuration
- Available tools from each server

## Customization

Even with registry mode enabled, you can customize:

### Local (stdio) servers

- Environment variables (API keys, paths)
- Request timeout
- Server scope (Global/Workspace/Agent)
- Tool trust settings

### Remote (HTTP) servers

- HTTP headers (authentication tokens)
- Request timeout
- Server scope
- Tool trust settings

Custom values override registry defaults, allowing personal credentials and configuration.

## Examples

### Add registry server

```
/mcp add

```

**Output**:

```
Select MCP server from registry:
  git-server (Git operations)
  github-server (GitHub integration)
  aws-tools (AWS operations)

```

### Add to specific agent

```bash
kiro-cli mcp add --name git-server --agent rust-dev

```

Adds git-server to rust-dev agent configuration.

### Customize with environment variables

```json
{
  "mcpServers": {
    "github": {
      "command": "mcp-server-github",
      "args": ["--stdio"],
      "env": {
        "GITHUB_TOKEN": "$GITHUB_TOKEN"
      }
    }
  }
}

```

Your token overrides registry defaults.

## Troubleshooting

### MCP functionality disabled

**Symptom**: Cannot use MCP at all

**Cause**: Organization disabled MCP entirely

**Solution**: Contact administrator for MCP access

### Failed to retrieve MCP settings

**Symptom**: Error fetching MCP configuration

**Cause**: Network issue or server error

**Solution**: Temporary issue - retry later or contact administrator

### Cannot add custom server

**Symptom**: Server not in list

**Cause**: Registry mode only allows registry servers

**Solution**: Request administrator add server to registry

### Server not in registry

**Symptom**: Needed server not available

**Cause**: Not added to organization's registry

**Solution**: Contact administrator to request server addition

## Limitations

- Registry mode only for Pro-tier with IAM Identity Center
- Cannot add servers not in registry
- Administrator controls available servers
- Custom servers not allowed in registry mode

## Technical details

**Registry source**: Configured by administrator at organization level

**Scope options**:

- Global: ~/.kiro/mcp.json
- Workspace: .kiro/mcp.json
- Agent-specific: In agent configuration

**Customization**: Environment variables and HTTP headers can be customized even in registry mode

**Fallback**: If registry unavailable, MCP functionality disabled

## Next steps

- Learn about MCP Configuration
- Review MCP Governance for administrators
- See MCP Examples
- Understand MCP Security

### Related questions - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Related questions

---

This section provides answers to billing, subscriptions, and payment questions for Kiro.

## Which countries or regions are supported for paid plans?

Currently, you can purchase a Kiro paid plan with a billing address in Afghanistan, Algeria, Angola, Antigua and Barbuda, Argentina, Armenia, Aruba, Australia, Austria, Azerbaijan, Bangladesh, Belgium, Belize, Bermuda, Bhutan, Bolivia, Bosnia and Herzegovina, Botswana, Brazil, Brunei, Bulgaria, Burkina Faso, Burundi, Cambodia, Canada, Cape Verde, Cayman Islands, Central African Republic, Chad, Chile, China, Colombia, Comoros, Congo, Cook Islands, Costa Rica, Croatia, Curacao, Cyprus, Czech Republic, Democratic Republic of the Congo, Denmark, Djibouti, Dominica, Dominican Republic, East Timor, Ecuador, El Salvador, Equatorial Guinea, Eritrea, Estonia, Ethiopia, Falkland Islands, Fiji, Finland, France, French Guiana, Gabon, Gambia, Germany, Gibraltar, Greece, Greenland, Grenada, Guatemala, Guinea, Guinea-Bissau, Guyana, Haiti, Honduras, Hong Kong SAR, Hungary, India, Indonesia, Iraq, Ireland, Israel, Italy, Jamaica, Japan, Jordan, Kiribati, Kosovo, Latvia, Lebanon, Lesotho, Liberia, Libya, Lithuania, Luxembourg, Macao, Macedonia, Madagascar, Malawi, Malaysia, Maldives, Mali, Malta, Mauritania, Mexico, Mongolia, Montenegro, Morocco, Mozambique, Myanmar, Namibia, Nauru, Nepal, Netherlands, New Zealand, Nicaragua, Niger, Norway, Palestinian Territories, Panama, Papua New Guinea, Paraguay, Philippines, Poland, Portugal, Qatar, Romania, Rwanda, Saint Kitts and Nevis, Saint Lucia, Saint Vincent and the Grenadines, Samoa, San Marino, Seychelles, Sierra Leone, Singapore, Slovakia, Slovenia, Solomon Islands, Somalia, South Africa, South Korea, South Sudan, Spain, Sri Lanka, Swaziland, Sweden, Switzerland, Tajikistan, Tanzania, Thailand, Togo, Tonga, Trinidad and Tobago, Tunisia, Turkmenistan, Tuvalu, United Arab Emirates, United Kingdom, United States of America, Uruguay, Uzbekistan, Vanuatu, Vatican City State, Venezuela, and Yemen. More countries or regions will be added soon.

## What is a credit?

A credit is a unit of work in response to user prompts. Simple prompts can consume less than 1 credit. More complex prompts, such as executing a spec task, typically cost more than 1 credit. Additionally, different models consume credits at different rates, with a prompt executed via Sonnet 4 costing more credits than executing it with Auto. For example, a given task that consumes X credits to execute in Auto, will cost you 1.3X credits to execute via Sonnet 4. Credits are metered to the second decimal point, so the least number of credits a task can consume is 0.01 credits.

## What paid plan should I choose if I'm not sure about my future usage?

Many customers are still exploring agentic development, and we expect that learning curve to continue beyond the first month. We don’t want you to have to predict your future usage or “time” upgrades to get a fair deal—we want you focused on building. A good path is to start on Pro and, if needed, enable overage so you can continue working without friction. If you later decide you need more, upgrade when you’re ready. In your first paid month we’ll discount for what you already paid and charge a single prorated amount for the higher plan back to the day you first became paid, so you won’t pay more than if you had upgraded earlier. For example, in a 30-day month if you start Pro on day 15 ($10 for the rest of the month) and later switch to Pro+ the same month, we discount for the $10 and charge $20—net $10—so you finish the month on Pro+ with one prorated allowance. From Month 2 onward, upgrades charge the full price difference and we re-rate the whole month under the higher plan’s limits, which also prevents overpaying.

## What paid plan should I choose once my Kiro usage is stable?

Our intent with Kiro’s pricing is to let most developers work comfortably without micromanaging usage or worrying about surprises. Once your usage settles into a pattern, choose the smallest subscription plan that reliably covers a typical month, with a little headroom. That reflects our goal of making your default experience predictable: if you prefer a fixed bill, leave overage off and your usage will pause at the cap; if you prefer continuity during occasional spikes, keep overage on. If those spikes become frequent, or your month-end overage spend starts to approach the price difference to the next tier, moving up will usually lower your total cost while keeping things simple.

## What happens when I reach the monthly limit of my plan?

If you hit the limit, requests pause until your limits reset at the start of the next
month.

The **Kiro Free** tier has fixed monthly limits and does not allow overage. If you hit a Free limit, you can upgrade to a paid plan
for immediate additional capacity.

On paid plans, you can enable overage to continue working uninterrupted beyond your included limits. You can also upgrade
to a higher plan at any time, and the higher usage limits immediately apply.

## I'm near month-end. Should I upgrade now or rely on overage?

If you're on a paid plan and only have a few days left, turning on overage is often the simplest way to finish the month
unless your month-to-date overage cost is approaching the price difference to the next tier. When that "breakeven" point
is reached, upgrading will usually lower your total bill and raise your limits immediately. In your first paid month, if
you do upgrade late, we apply a discount for what you've already paid and charge a single prorated amount for the higher
plan back to the day you first became paid, so you don't overpay for waiting a bit. From Month 2 onward, mid-month
upgrades charge the full price difference and we re-rate the whole month under the higher plan.

## What happens to my bonus credits if I upgrade early?

If you are within the 30 day trial period for the bonus credits, those credits will carry over for the remainder of the 30 day trial period, independent of the plan you upgrade to.

## How does proration work during the initial month that I upgrade from the free trial or Kiro free tier to paying?

During the month that you first upgrade to a paid plan, the plan charges are pro-rated by days remaining in the month. For example, in a 30-day month, if you upgrade to Pro ($20) with 10 days left (i.e., on day 21), you pay $6.67 (10/30 of $20) and receive access to Pro credit limits immediately. Informally, because you’re on Pro for one-third of the month, you pay one-third of the price, but get the full monthly quota of your new plan immediately.

If you later upgrade to Pro+ ($40) in that same first paid month, we discount the $6.67 you already paid for Pro and charge $13.33 (10⁄30 of $40), so your net extra payment is $6.66 at the time of upgrade. On your invoice, this appears as a discount line for the earlier Pro charge and a prorated charge line for Pro+.

## How does proration work after the first upgrade?

Prorated pay only applies to the first upgrade. After the first upgrade, any future upgrade, at any day of the month, will be charged in full and users will receive full plan limits.

## What happens to my existing overage if I upgrade during the middle of the month?

Our intent is that you shouldn’t have to “time” an upgrade or pay twice for the same usage. When you upgrade to a higher subscription plan mid-month, we re-evaluate your month-to-date usage under the higher plan, so you get the benefit of its larger limits.

## When does Kiro bill me?

Kiro bills on a calendar month. Your billing month starts at 12:00 a.m. (UTC) on the first day of the month and ends at 11:59 p.m. (UTC) on the last day. The exact timing of your monthly charge will depend on your local timezone. If you upgrade mid-month, we will bill you immediately for the cost of the new plan discounted by the cost of the prior plan. Overage is included as separate line items on your month’s bill.

## Why might a single action span more than one credit?

Some actions require much more context or generate more output than average, such as working across a large codebase or executing a highly complex build. When that happens, the total token usage can exceed the limit for a single request, and Kiro will count it as more than one credit. You’ll see the count right after the interaction finishes.

## How does Kiro help optimize my costs?

Kiro is engineered to minimize redundant LLM work. We reuse context where possible and apply provider‑level efficiencies, such as token‑efficient tool use and prompt caching when available, to cut underlying token spend without adding friction to your workflow. You pay by request, not by token, and we pass efficiency gains through Kiro's pricing plan design rather than asking you to micromanage prompts.

### Responding to messages - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Responding to messages

---

## Overview

Kiro CLI provides a convenient way to respond to specific parts of Kiro's previous message through the `/reply` command. It opens an editor with Kiro's last response quoted with > prefixes, allowing you to easily address individual points or provide structured feedback.
The command uses your system's default editor, and falls back to `vi` if no editor is configured

### How it works

- Retrieves last response: Finds the most recent assistant message from the conversation
- Formats with quotes: Each line is prefixed with > for clear attribution
- Opens editor: Your default editor opens with the quoted content
- Edit and respond: Add your responses below or interspersed with the quoted text
- Submit: When you save and close the editor, your response is submitted

### Editor behavior

- Pre-populated content: Editor opens with Kiro's response already quoted
- Quote format: Each line prefixed with > for clear visual distinction
- Flexible editing: Add content anywhere - below quotes, between lines, or interspersed
- Auto-submission: Content is automatically submitted when editor closes successfully

### Use cases

#### Responding to multiple questions

When Kiro asks several clarifying questions, use `/reply` to address each one:

```
> What programming language are you using?
Python

> What framework are you working with?
Django

> What specific error are you encountering?
I'm getting a 404 error when trying to access my API endpoints.


```

#### Addressing specific points

When Kiro provides a detailed explanation, respond to specific parts:

```
> Here are three approaches you could take:
> 1. Use a database migration
> 2. Update the model directly
> 3. Create a custom management command

I'd like to go with option 1. Can you show me how to create the migration?

> Make sure to backup your data first.
Already done - I have a full backup from this morning.

```

#### Providing structured feedback

When Kiro suggests multiple changes, organize your responses clearly:

```
> I recommend these improvements:
> - Add error handling for network requests
> - Implement input validation
> - Add logging for debugging

Agreed on all points. For the error handling:
- Should I use try/catch blocks or a decorator pattern?

For logging:
- What level of detail do you recommend?

```

### Status messages

The command provides clear feedback about its operation:

- Success: "Content loaded from editor. Submitting prompt..."
- No changes: "No changes made in editor, not submitting."
- No message: "No assistant message found to reply to."
- Editor error: "Error opening editor: [specific error details]"

### Error handling

- No assistant message: Shows warning if no previous Kiro response is found
- Editor failures: Reports editor process failures with specific error details
- Empty content: Detects when no changes are made and skips submission
- Unchanged content: Compares with initial text to avoid submitting unmodified quotes

### Best practices

- Use /reply when Kiro's response contains multiple points that need individual attention
- Keep your responses clear and organized when addressing quoted sections
- Focus on sections that need clarification rather than responding to every quoted line
- Use the quote structure to maintain context in longer conversations

1. You can delete quote lines you don't need to respond to
2. Add blank lines between your responses for better readability
3. Use the quoted structure to break down complex topics into manageable parts
4. The command works best when Kiro's previous response was substantial and detailed

View related pages

## Next steps

- Learn about Context Management for better responses
- Explore Slash Commands for quick actions
- Check Conversations to save and manage chats
- Review Prompts for effective questioning

### Security - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Security

---

Security is critical when integrating external MCP servers with your development workflow. The MCP security model in Kiro CLI is designed with these principles:

1. Explicit Permission: Tools require explicit user permission before execution
2. Local Execution: MCP servers run locally on your machine
3. Isolation: Each MCP server runs as a separate process
4. Transparency: Users can see what tools are available and what they do

## Security considerations

When using MCP servers with Kiro CLI, keep these security principles in mind:

### Trust and verification

- Only install MCP servers from trusted sources
- Review tool descriptions and documentation before installation
- Check for security advisories and updates

### Access control

- Use least-privilege principles for server permissions
- Limit file system access to necessary directories only
- Restrict network access where possible
- Use environment variables for sensitive credentials

### Credential management

- Never hardcode API keys or tokens in configuration files
- Use environment variables for sensitive data
- Rotate credentials regularly
- Store credentials securely using system keychains

### Network security

- Use HTTPS for remote MCP servers
- Verify SSL/TLS certificates
- Be cautious with servers that require broad network access
- Monitor network traffic for unusual activity

### Monitoring and auditing

- Review MCP server logs regularly
- Monitor for unexpected behavior
- Keep track of installed servers and their permissions
- Remove unused or untrusted servers promptly

## Best practices

### Configuration security

```bash
# Use environment variables for sensitive data
export MCP_API_KEY="your-secure-key"
export DATABASE_URL="your-connection-string"

# Configure MCP server with environment variables
kiro-cli mcp add my-server --env MCP_API_KEY --env DATABASE_URL

```

## Next steps

- Explore Examples
- Return to MCP Overview

### Session Management - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Session Management

---

Kiro CLI automatically saves all chat sessions on every conversation turn. Sessions are stored per-directory in the database, allowing you to resume from any previous session, export to files, or integrate with custom storage solutions.

## Auto-save

**Automatic**: Every conversation turn saved to database

**Scope**: Per-directory (each project has own sessions)

**Storage**: Local database (`~/.kiro/`)

**Session ID**: UUID for each session

## Managing sessions

### From command line

```bash
# Resume most recent session
kiro-cli chat --resume

# Interactive picker
kiro-cli chat --resume-picker

# List all sessions
kiro-cli chat --list-sessions

# Delete session
kiro-cli chat --delete-session <SESSION_ID>

```

### From chat

```bash
# Resume session (interactive)
/chat resume

# Save to file
/chat save <path>

# Load from file
/chat load <path>

```

The `.json` extension is optional when loading sessions.

## Custom storage via scripts

Use custom scripts to save/load sessions from version control, cloud storage, or databases.

### Save via script

```bash
/chat save-via-script <script-path>

```

Script receives session JSON via stdin.

**Example: Save to Git Notes**

```bash
#!/bin/bash
COMMIT=$(git rev-parse HEAD)
TEMP=$(mktemp)
cat > "$TEMP"
git notes --ref=kiro/notes add -F "$TEMP" "$COMMIT" --force
rm "$TEMP"
echo "Saved to commit ${COMMIT:0:8}" >&2

```

### Load via script

```bash
/chat load-via-script <script-path>

```

Script outputs session JSON to stdout.

**Example: Load from Git Notes**

```bash
#!/bin/bash
COMMIT=$(git rev-parse HEAD)
git notes --ref=kiro/notes show "$COMMIT"

```

## Session storage

**Database**: Sessions auto-saved per-directory

**Files**: Manual export via `/chat save`

**Custom**: Script-based integration

**Session ID**: UUID format (e.g., `f2946a26-3735-4b08-8d05-c928010302d5`)

## Examples

### Resume last session

```bash
kiro-cli chat --resume

```

Continues most recent conversation.

### Pick session interactively

```bash
kiro-cli chat --resume-picker

```

Shows list of sessions to choose from.

### Export to file

```
/chat save backup.json

```

Exports current session to file.

### Version control integration

```bash
# Save to git notes
/chat save-via-script ./scripts/save-to-git.sh

# Load from git notes
/chat load-via-script ./scripts/load-from-git.sh

```

## Troubleshooting

### No sessions to resume

**Symptom**: "No saved chat sessions"

**Cause**: No sessions in current directory

**Solution**: Sessions are per-directory. Navigate to correct directory.

### Script save fails

**Symptom**: Script exits with error

**Cause**: Script returned non-zero exit code

**Solution**: Test script manually. Ensure it exits 0 on success.

### Script load fails

**Symptom**: Can't load session

**Cause**: Script didn't output valid JSON

**Solution**: Test script outputs valid session JSON to stdout.

## Limitations

- Sessions stored per-directory
- Auto-save to database only (not files)
- Session IDs are UUIDs (not human-readable)
- No cloud sync (use scripts for custom storage)
- No session search by content

## Technical details

**Storage**: SQLite database in `~/.kiro/`

**Scope**: Sessions keyed by directory path

**Auto-save**: After every conversation turn

**Script interface**:

- Save: JSON via stdin, exit 0 on success
- Load: JSON via stdout, exit 0 on success

## Next steps

- Learn about Chat Commands
- See Interactive Chat Mode
- Review Context Management

### Settings - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Settings

---

Kiro CLI provides extensive customization through settings. You can configure everything from telemetry to chat behavior, key bindings, and feature toggles.

## Accessing settings

Manage settings directly from the command line:

```bash
# List all configured settings
kiro-cli settings list

# List all available settings with descriptions
kiro-cli settings list --all

# View a specific setting
kiro-cli settings telemetry.enabled

# Set a setting
kiro-cli settings telemetry.enabled true

# Delete a setting
kiro-cli settings --delete chat.defaultModel

# Open settings file in editor
kiro-cli settings open

```

### Output formats

```bash
# Plain text (default)
kiro-cli settings list

# JSON
kiro-cli settings list --format json

# Formatted JSON
kiro-cli settings list --format json-pretty

```

## Settings reference

### Telemetry and privacy

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| telemetry.enabled | boolean | Enable/disable telemetry collection | kiro-cli settings telemetry.enabled true |
| telemetryClientId | string | Client identifier for telemetry | kiro-cli settings telemetryClientId "client-123" |

### Chat interface

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| chat.defaultModel | string | Default AI model for conversations | kiro-cli settings chat.defaultModel "claude-3-sonnet" |
| chat.defaultAgent | string | Default agent configuration | kiro-cli settings chat.defaultAgent "my-agent" |
| chat.diffTool | string | External diff tool for viewing code changes | kiro-cli settings chat.diffTool "delta" |
| chat.greeting.enabled | boolean | Show greeting message on chat start | kiro-cli settings chat.greeting.enabled false |
| chat.editMode | boolean | Enable edit mode for chat interface | kiro-cli settings chat.editMode true |
| chat.enableNotifications | boolean | Enable desktop notifications | kiro-cli settings chat.enableNotifications true |
| chat.disableMarkdownRendering | boolean | Disable markdown formatting | kiro-cli settings chat.disableMarkdownRendering false |
| chat.disableAutoCompaction | boolean | Disable automatic conversation summarization | kiro-cli settings chat.disableAutoCompaction true |
| compaction.excludeMessages | number | Minimum message pairs to retain during compaction | kiro-cli settings compaction.excludeMessages 2 |
| compaction.excludeContextWindowPercent | number | Minimum % of context window to retain during compaction | kiro-cli settings compaction.excludeContextWindowPercent 2 |
| chat.enableHistoryHints | boolean | Show conversation history hints | kiro-cli settings chat.enableHistoryHints true |
| chat.uiMode | string | UI variant to use | kiro-cli settings chat.uiMode "compact" |
| chat.enableContextUsageIndicator | boolean | Show context usage percentage in prompt | kiro-cli settings chat.enableContextUsageIndicator true |

### Knowledge base

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| chat.enableKnowledge | boolean | Enable knowledge base functionality | kiro-cli settings chat.enableKnowledge true |
| knowledge.defaultIncludePatterns | array | Default file patterns to include | kiro-cli settings knowledge.defaultIncludePatterns '["*.py", "*.js"]' |
| knowledge.defaultExcludePatterns | array | Default file patterns to exclude | kiro-cli settings knowledge.defaultExcludePatterns '["*.log", "node_modules"]' |
| knowledge.maxFiles | number | Maximum files for indexing | kiro-cli settings knowledge.maxFiles 1000 |
| knowledge.chunkSize | number | Text chunk size for processing | kiro-cli settings knowledge.chunkSize 512 |
| knowledge.chunkOverlap | number | Overlap between text chunks | kiro-cli settings knowledge.chunkOverlap 50 |
| knowledge.indexType | string | Type of knowledge index | kiro-cli settings knowledge.indexType "fast" |

### Key bindings

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| chat.skimCommandKey | char | Key for fuzzy search command | kiro-cli settings chat.skimCommandKey "f" |
| chat.autocompletionKey | char | Key for autocompletion hint acceptance | kiro-cli settings chat.autocompletionKey "Tab" |
| chat.tangentModeKey | char | Key for tangent mode toggle | kiro-cli settings chat.tangentModeKey "t" |
| chat.delegateModeKey | char | Key for delegate command | kiro-cli settings chat.delegateModeKey "d" |

### Feature toggles

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| chat.enableThinking | boolean | Enable thinking tool for complex reasoning | kiro-cli settings chat.enableThinking true |
| chat.enableTangentMode | boolean | Enable tangent mode feature | kiro-cli settings chat.enableTangentMode true |
| introspect.tangentMode | boolean | Auto-enter tangent mode for introspect | kiro-cli settings introspect.tangentMode true |
| chat.enableTodoList | boolean | Enable todo list feature | kiro-cli settings chat.enableTodoList true |
| chat.enableCheckpoint | boolean | Enable checkpoint feature | kiro-cli settings chat.enableCheckpoint true |
| chat.enableDelegate | boolean | Enable delegate tool | kiro-cli settings chat.enableDelegate true |

### API and service

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| api.timeout | number | API request timeout in seconds | kiro-cli settings api.timeout 30 |

### Model context protocol (MCP)

| Setting | Type | Description | Example |
| --- | --- | --- | --- |
| mcp.initTimeout | number | MCP server initialization timeout | kiro-cli settings mcp.initTimeout 10 |
| mcp.noInteractiveTimeout | number | Non-interactive MCP timeout | kiro-cli settings mcp.noInteractiveTimeout 5 |
| mcp.loadedBefore | boolean | Track previously loaded MCP servers | kiro-cli settings mcp.loadedBefore true |

## Common configuration examples

### Basic setup

```bash
# Enable telemetry
kiro-cli settings telemetry.enabled true

# Set default chat model
kiro-cli settings chat.defaultModel "claude-3-sonnet"

# Disable greeting message
kiro-cli settings chat.greeting.enabled false

```

### Knowledge base configuration

```bash
# Enable knowledge base
kiro-cli settings chat.enableKnowledge true

# Set file patterns to include
kiro-cli settings knowledge.defaultIncludePatterns '["*.py", "*.js", "*.md", "*.txt"]'

# Set file patterns to exclude
kiro-cli settings knowledge.defaultExcludePatterns '["*.log", "node_modules", ".git", "*.pyc"]'

# Set maximum files to index
kiro-cli settings knowledge.maxFiles 2000

```

### Enable experimental features

```bash
# Enable thinking tool
kiro-cli settings chat.enableThinking true

# Enable tangent mode
kiro-cli settings chat.enableTangentMode true

# Enable todo lists
kiro-cli settings chat.enableTodoList true

# Enable checkpoints
kiro-cli settings chat.enableCheckpoint true

# Configure key bindings
kiro-cli settings chat.tangentModeKey "t"
kiro-cli settings chat.delegateModeKey "d"

```

### Performance tuning

```bash
# Increase API timeout for slow connections
kiro-cli settings api.timeout 60

# Adjust knowledge base chunk size
kiro-cli settings knowledge.chunkSize 1024

# Disable auto-compaction for long conversations
kiro-cli settings chat.disableAutoCompaction true

```

## Troubleshooting settings

### Invalid setting values

**Boolean values:** Use `true` or `false` (lowercase)

```bash
kiro-cli settings telemetry.enabled true  # ✓ Correct
kiro-cli settings telemetry.enabled True  # ✗ Wrong

```

**Array values:** Use JSON format with single quotes

```bash
kiro-cli settings knowledge.defaultIncludePatterns '["*.py", "*.js"]'  # ✓ Correct

```

**String values:** Use quotes for strings with spaces

```bash
kiro-cli settings chat.defaultModel "claude-3-sonnet"  # ✓ Correct

```

### Resetting settings

Delete individual settings:

```bash
kiro-cli settings --delete setting.name

```

Open settings file for manual editing:

```bash
kiro-cli settings open

```

View current settings to identify issues:

```bash
kiro-cli settings list --all

```

### Settings file issues

If the settings file becomes corrupted:

1. Back up current settings:
bashkiro-cli settings list --format json > backup.json
2. Open the settings file:
bashkiro-cli settings open
3. Verify JSON syntax or restore from backup

## Settings file location

Settings are stored in:

- macOS: ~/.kiro/settings.json
- Linux: ~/.config/kiro/settings.json

You can edit this file directly, but using `kiro-cli settings` commands is recommended for validation.

## Next steps

- Configure custom agents
- Set up MCP servers
- Configure custom diff tools
- Enable experimental features
- CLI Commands Reference

### Slash commands - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Slash commands

---

## Overview

Slash commands are special commands you can use within an interactive chat session to quickly perform actions without leaving the conversation. They start with a forward slash (`/`) and provide shortcuts for common tasks.

## Using slash commands

Slash commands are only available in interactive chat mode:

```bash
kiro chat
> /help

```

## Available commands

### /help

Switch to the Help Agent to ask questions about Kiro CLI features, or display classic help text.

```bash
# Switch to Help Agent
> /help

# Ask a question directly
> /help How do I configure MCP servers?

# Show classic help text
> /help --legacy

```

See [Help Agent](/docs/cli/chat/help-agent) for more details.

### /quit

Exit the interactive chat session.

```bash
> /quit

```

Aliases: /exit, /q

### /clear

Clear the current conversation history.

```bash
> /clear

```

Note: This only clears the display, not the saved conversation.

### /context

Manage context files and view context window usage. Context rules determine which files are included in your Kiro session and are derived from the current active agent.

```bash
# Display context rule configuration and matched files
> /context show

# Add context rules (filenames or glob patterns)
> /context add src/app.js
> /context add "*.py"
> /context add "src/**/*.js"

# Remove specified rules
> /context remove src/app.js

# Remove all rules
> /context clear

```

**Available subcommands:**

- show - Display the context rule configuration and matched files
- add - Add context rules (filenames or glob patterns)
- remove - Remove specified rules

**Notes:**

- You can add specific files or use glob patterns (e.g., *.py, src/**/*.js)
- Agent rules apply only to the current agent
- Context changes are NOT preserved between chat sessions. To make changes permanent, edit the agent config file.
- The files matched by these rules provide Kiro with additional information about your project or environment

See [Context Management](/docs/cli/chat/context) for detailed documentation.

### /model

Switch to a different AI model or set your default model preference.

```bash
# Show current model
> /model

# Save current model as default for future sessions
> /model set-current-as-default

```

**Available subcommands:**

- set-current-as-default - Persist your current model selection as the default for all future sessions

**Note:** The `set-current-as-default` command saves your current model preference to `~/.kiro/settings/cli.json`, so it will be used automatically in all future chat sessions.

### /agent

Manage agents and switch between different agent configurations.

```bash
# List all available agents
> /agent list

# Create a new agent
> /agent create my-agent

# Edit an existing agent configuration
> /agent edit my-agent

# Generate an agent configuration using AI
> /agent generate

# Show agent config schema
> /agent schema

# Set default agent for new chat sessions
> /agent set-default my-agent

# Swap to a different agent at runtime
> /agent swap code-reviewer

```

**Available subcommands:**

- list - List all available agents with their descriptions
- create - Create a new agent with the specified name
- edit - Edit an existing agent configuration
- generate - Generate an agent configuration using AI
- schema - Show agent config schema
- set-default - Define a default agent to use when kiro-cli chat launches
- swap - Swap to a new agent at runtime (shows agent descriptions for selection)

**Notes:**

- Agents can be stored globally in ~/.kiro/agents/ or per-workspace in .kiro/agents/
- Launch kiro-cli chat with a specific agent using kiro-cli chat --agent agent_name
- Set default agent with kiro-cli settings chat.defaultAgent agent_name

See [Custom Agents](/docs/cli/custom-agents) for detailed documentation.

### /chat

Manage chat sessions, including saving, loading, and switching between sessions. Kiro CLI automatically saves all chat sessions on every conversation turn.

```bash
# Open interactive session picker to resume a previous session
> /chat resume

# Save current session to a file
> /chat save /myproject/codereview.json

# Load a session from a file
> /chat load /myproject/codereview.json

```

**Available subcommands:**

- resume - Open interactive session picker to choose a session to resume
- save - Save current session to a file
- load - Load a session from a file (.json extension is optional)
- save-via-script - Save session using a custom script (receives JSON via stdin)
- load-via-script - Load session using a custom script (outputs JSON to stdout)

**Notes:**

- Sessions are automatically saved on every conversation turn
- Sessions are stored per directory, so each project has its own set of sessions
- The session picker shows session name, last activity, and message preview
- Use keyboard shortcuts in the picker: ↑/↓ to navigate, Enter to select, / to filter

#### Custom session storage

You can use custom scripts to control where chat sessions are saved to and loaded from. This allows you to store sessions in version control systems, cloud storage, databases, or any custom location.

**Save via script:**

```bash
> /chat save-via-script ./scripts/save-to-git.sh

```

Your script receives the chat session JSON via stdin. Example script to save to Git notes:

```bash
#!/bin/bash
set -ex
COMMIT=$(git rev-parse HEAD)
TEMP=$(mktemp)
cat > "$TEMP"
git notes --ref=kiro/notes add -F "$TEMP" "$COMMIT" --force
rm "$TEMP"
echo "Saved to commit ${COMMIT:0:8}" >&2

```

**Load via script:**

```bash
> /chat load-via-script ./scripts/load-from-git.sh

```

Your script should output the chat session JSON to stdout. Example script to load from Git notes:

```bash
#!/bin/bash
set -ex
COMMIT=$(git rev-parse HEAD)
git notes --ref=kiro/notes show "$COMMIT"

```

### /save

Save the current conversation to a file.

```bash
# Save <PATH>
> /chat save /myproject/codereview.json

```

### /load

Load a previously saved conversation.

```bash
# List available conversations
> /chat load /myproject/codereview.json

```

### /editor

Open your default editor (defaults to vi) to compose a prompt.

```bash
> /editor

```

Opens `$EDITOR` to compose a longer message.

### /reply

Open your editor with the most recent assistant message quoted for reply.

```bash
> /reply

```

Useful for referencing and responding to specific parts of the AI's response.

### /compact

Summarize the conversation to free up context space.

```bash
> /compact

```

Condenses the conversation history while preserving key information, useful when approaching context limits.

### /paste

Paste an image from clipboard.

```bash
> /paste

```

Adds an image from your system clipboard to the conversation.

### /tools

View tools and permissions. By default, Kiro will ask for your permission to use certain tools. You can control which tools you trust so that no confirmation is required.

```bash
# View all tools and their permissions
> /tools

# Show the input schema for all available tools
> /tools schema

# Trust a specific tool for the session
> /tools trust write

# Revert a tool to per-request confirmation
> /tools untrust write

# Trust all tools (equivalent to deprecated /acceptall)
> /tools trust-all

# Reset all tools to default permission levels
> /tools reset

```

**Available subcommands:**

- schema - Show the input schema for all available tools
- trust - Trust a specific tool or tools for the session
- untrust - Revert a tool or tools to per-request confirmation
- trust-all - Trust all tools (equivalent to deprecated /acceptall)
- reset - Reset all tools to default permission levels

**Note:** For permanent tool configuration, see [Agent Configuration Reference](/docs/cli/custom-agents/configuration-reference/#tools-field).

### /prompts

View and retrieve prompts. Prompts are reusable templates that help you quickly access common workflows and tasks. These templates are provided by the MCP servers you have installed and configured.

```bash
# List available prompts from a tool or show all available prompts
> /prompts list

# Show detailed information about a specific prompt
> /prompts details code-review

# Get a specific prompt by name
> /prompts get code-review [arg]

# Quick retrieval (without /prompts prefix)
> @code-review [arg]

# Create a new local prompt
> /prompts create my-prompt

# Edit an existing local prompt
> /prompts edit my-prompt

# Remove an existing local prompt
> /prompts remove my-prompt

```

**Available subcommands:**

- list - List available prompts from a tool or show all available prompts
- details - Show detailed information about a specific prompt
- get - Get a specific prompt by name
- create - Create a new local prompt
- edit - Edit an existing local prompt
- remove - Remove an existing local prompt

**Quick tip:** To retrieve a prompt directly, use `@<prompt name> [arg]` without the `/prompts get` prefix.

See [Manage Prompts](/docs/cli/chat/manage-prompts) for detailed documentation.

### /hooks

View context hooks.

```bash
> /hooks

```

Display active context hooks for the current session.

### /usage

Show billing and credits information.

```bash
> /usage

```

View your current usage statistics and remaining credits.

### /mcp

See MCP servers loaded.

```bash
> /mcp

```

Display Model Context Protocol servers currently active.

### /code

Manage code intelligence configuration and get feedback.

```bash
# Initialize LSP-powered code intelligence in the current directory
> /code init

# Force reinitialization in the current directory - restarts LSP servers
> /code init -f

# Get a complete overview of the workspace
> /code overview

# Get overview with cleaner output
> /code overview --silent

# Get workspace status and LSP server statuses
> /code status

# View LSP logs for troubleshooting
> /code logs # Show last 20 ERROR logs

> /code logs -l INFO            # Show INFO level and above

> /code logs -n 50              # Show last 50 entries

> /code logs -l DEBUG -n 100    # Show last 100 DEBUG+ logs

> /code logs -p ./lsp-logs.json # Export logs to JSON file


```

**Available subcommands:**

- init - Initialize LSP servers for enhanced code intelligence
- overview - Get a complete overview of the workspace structure
- status - Show the detailed status of the LSP servers and workspace status
- logs - View logs

### /experiment

Toggle experimental features.

```bash
> /experiment

```

Enable or disable experimental CLI features.

### /tangent

Create conversation checkpoints to explore side topics.

```bash
> /tangent

```

Enter or exit [tangent mode](/docs/cli/experimental/tangent-mode) to explore tangential topics without disrupting your main conversation. Use `Ctrl+T` as a keyboard shortcut (when tangent mode is enabled).

### /todos

View, manage, and resume to-do lists.

```bash
# View todo
> /todo

# Add todo
> /todo add "Fix authentication bug"

# Complete todo
> /todo complete 1

```

### /issue

Create a new GitHub issue or make a feature request.

```bash
> /issue

```

Opens a workflow to submit issues or feature requests to the Kiro team.

### /logdump

Create a zip file with logs for support investigation.

```bash
> /logdump

```

Generates a diagnostic log bundle for troubleshooting with support.

### /changelog

View changelog for Kiro CLI.

```bash
> /changelog

```

Display recent updates and changes to the CLI.

### Keyboard shortcuts

In interactive mode, you can also use:

- Ctrl+C - Cancel current input
- Ctrl+J - To insert new-line for multi-line prompt
- Ctrl+S - Fuzzy search commands and context files, use tab to select multiple items
- Ctrl+T - Toggle tangent mode for isolated conversations (if Tangent mode is enabled)
- Up/Down arrows - Navigate command history

## Next steps

- Learn about CLI Commands for terminal usage
- Explore Interactive Chat Mode
- Check Context Management for advanced context handling

### Steering - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Steering

---

## What is steering?

Steering gives Kiro persistent knowledge about your project through markdown files in `.kiro/steering/`. Instead of explaining your conventions in every chat, steering files ensure Kiro consistently follows your established patterns, libraries, and standards.

## Key benefits

**Consistent Code Generation** - Every component, API endpoint, or test follows your team's established patterns and conventions.

**Reduced Repetition** - No need to explain project standards in each conversation. Kiro remembers your preferences.

**Team Alignment** - All developers work with the same standards, whether they're new to the project or seasoned contributors.

**Scalable Project Knowledge** - Documentation that grows with your codebase, capturing decisions and patterns as your project evolves.

## Steering file scope

Steering files can be created with a workspace scope or a global scope.

### Workspace steering

Workspace steering files reside in your workspace root folder under `.kiro/steering/`, and apply only to that specific workspace. Workspace steering files can be used to inform Kiro of patterns, libraries, and standards that apply to an individual workspace.

### Global steering

Global steering files reside in your home directory under `~/.kiro/steering/`, and apply to all workspaces. Global steering files can be used to inform Kiro of conventions that apply to *all* your workspaces.

In case of conflicting instructions between global and workspace steering, Kiro will prioritize the workspace steering instructions. This allows you to specify global directives that generally apply to all your workspaces, while preserving the ability to override those directives for specific workspaces.

### Team steering

The global steering feature can be used to define centralized steering files that apply to entire teams. Team steering files can be pushed to user's PCs via MDM solutions or Group Policies, or downloaded by users to their PCs from a central repository, and placed into the `~/.kiro/steering` folder.

## Foundational steering files

Create foundational steering files to establish core project context.

1. Create a .kiro/steering/ folder in your project root for workspace scope or ~/.kiro/steering folder for global scope.
2. Add markdown files for your project standards
3. Kiro will automatically load these files in chat sessions

Foundational steering files are:

**Product Overview** (`product.md`) - Defines your product's purpose, target users, key features, and business objectives. This helps Kiro understand the "why" behind technical decisions and suggest solutions aligned with your product goals.

**Technology Stack** (`tech.md`) - Documents your chosen frameworks, libraries, development tools, and technical constraints. When Kiro suggests implementations, it will prefer your established stack over alternatives.

**Project Structure** (`structure.md`) - Outlines file organization, naming conventions, import patterns, and architectural decisions. This ensures generated code fits seamlessly into your existing codebase.

These foundation files are included in every interaction by default, forming the baseline of Kiro's project understanding.

## Creating custom steering files

Extend Kiro's understanding with specialized guidance tailored to your project's unique needs:

1. Create a new .md file in .kiro/steering/
2. Choose a descriptive filename (e.g., api-standards.md)
3. Write your guidance using standard markdown syntax
4. Use natural language to describe your requirements

## Steering with custom agents

When using [custom agents](/docs/cli/custom-agents/creating), steering files are not automatically included. You must explicitly add them to the agent's `resources` configuration to load steering context.

To include all steering files in a custom agent, add the following to your agent configuration:

```json
{
  "resources": ["file://.kiro/steering/**/*.md"]
}

```

This glob pattern ensures all markdown files in your steering directory are loaded when using the agent. See the [custom agents documentation](/docs/cli/custom-agents/creating/#agent-configuration-file) for a complete configuration example.

## Agents.md

Kiro supports providing steering directives via the [AGENTS.md](https://agents.md/) standard. AGENTS.md files are in markdown format, similar to Kiro steering files; however, AGENTS.md files are always included.

You can add AGENTS.md files to the global steering file location (`~/.kiro/steering/`), or to the root folder of your workspace, and they will get picked up by Kiro automatically.

## Best practices

**Keep Files Focused**
One domain per file - API design, testing, or deployment procedures.

**Use Clear Names**

- api-rest-conventions.md - REST API standards
- testing-unit-patterns.md - Unit testing approaches
- components-form-validation.md - Form component standards

**Include Context**
Explain why decisions were made, not just what the standards are.

**Provide Examples**
Use code snippets and before/after comparisons to demonstrate standards.

**Security First**
Never include API keys, passwords, or sensitive data. Steering files are part of your codebase.

**Maintain Regularly**

- Review during sprint planning and architecture changes
- Test file references after restructuring
- Treat steering changes like code changes - require reviews

## Common steering file strategies

**API Standards** (`api-standards.md`) - Define REST conventions, error response formats, authentication flows, and versioning strategies. Include endpoint naming patterns, HTTP status code usage, and request/response examples.

**Testing Approach** (`testing-standards.md`) - Establish unit test patterns, integration test strategies, mocking approaches, and coverage expectations. Document preferred testing libraries, assertion styles, and test file organization.

**Code Style** (`code-conventions.md`) - Specify naming patterns, file organization, import ordering, and architectural decisions. Include examples of preferred code structures, component patterns, and anti-patterns to avoid.

**Security Guidelines** (`security-policies.md`) - Document authentication requirements, data validation rules, input sanitization standards, and vulnerability prevention measures. Include secure coding practices specific to your application.

**Deployment Process** (`deployment-workflow.md`) - Outline build procedures, environment configurations, deployment steps, and rollback strategies. Include CI/CD pipeline details and environment-specific requirements.

Custom steering files are stored in `.kiro/steering/` and become immediately available across all Kiro CLI chat sessions.

### Subagents - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Subagents

---

Subagents are specialized agents that can autonomously execute complex tasks on your behalf. They have their own context, tool access, and decision-making capabilities, making them ideal for sophisticated multi-step operations.

## Key capabilities

- Autonomous execution - Run independently with their own context, with the level of autonomy depending on agent configuration
- Live progress tracking - Monitor real-time status updates as subagents work through tasks
- Core tool access - Read files, execute commands, write files, and use MCP tools
- Parallel execution - Run multiple subagents simultaneously for efficient task execution
- Result aggregation - Results automatically returned to the main agent when complete

## Default subagent

Kiro includes a default subagent that can handle general-purpose tasks. When you assign a task to a subagent, the default subagent is used unless you specify a custom agent configuration.

## Custom subagents

You can spawn subagents using your own agent configurations. This allows you to create specialized subagents tailored to specific workflows:

```bash
> Use the backend agent to refactor the payment module

```

To use a custom agent as a subagent, reference it by name when assigning tasks. The subagent will inherit the tool access and settings from that agent's configuration.

## How subagents work

1. Task assignment - You describe a task, and Kiro determines if a subagent is appropriate
2. Subagent initialization - The subagent is created with its own context and tool access based on its agent configuration
3. Autonomous execution - The subagent works through the task independently, though it may pause to request user approval for certain tool permissions
4. Progress updates - You receive live progress updates showing current work
5. Result return - When complete, results are returned to the main agent

## Tool availability

Subagents run in a separate runtime environment. Some tools available in normal chat are not yet implemented in subagents.

**Available tools:**

- read - Read files and directories
- write - Create and edit files
- shell - Execute bash commands
- MCP tools

**Not available:**

- web_search - Web research
- web_fetch - Fetch URLs
- introspect - CLI info
- thinking - Reasoning tool
- todo_list - Task tracking
- use_aws - AWS commands
- grep - Search file contents
- glob - Find files by pattern

If your custom agent configuration includes tools that aren't available in subagents, those tools will simply be unavailable when the agent runs as a subagent. The agent will still function with the available tools.

## Configuring subagent access

You can control which agents are available as subagents and which can run without permission prompts.

### Restricting available agents

Use `availableAgents` to limit which agents can be spawned as subagents:

```json
{
  "toolsSettings": {
    "subagent": {
      "availableAgents": ["reviewer", "tester", "docs-*"]
    }
  }
}

```

With this configuration, only the `reviewer`, `tester`, and agents matching `docs-*` can be used as subagents. Glob patterns are supported.

### Trusting specific agents

Use `trustedAgents` to allow specific agents to run without permission prompts:

```json
{
  "name": "orchestrator",
  "description": "Agent that coordinates multiple specialized subagents",
  "tools": ["fs_read", "subagent"],
  "toolsSettings": {
    "subagent": {
      "trustedAgents": ["reviewer", "tester", "analyzer"]
    }
  }
}

```

With this configuration, the orchestrator agent can spawn the `reviewer`, `tester`, and `analyzer` subagents without requiring user approval each time. Glob patterns like `test-*` are supported.

### Combining both settings

You can use both settings together for fine-grained control:

```json
{
  "toolsSettings": {
    "subagent": {
      "availableAgents": ["reviewer", "tester", "analyzer", "docs-*"],
      "trustedAgents": ["reviewer", "tester"]
    }
  }
}

```

This allows four agents to be spawned as subagents, but only `reviewer` and `tester` run without prompts.

## Best practices

1. Use for complex tasks - Most valuable for multi-step operations that benefit from isolation
2. Provide clear instructions - Specific task descriptions lead to better results
3. Monitor progress - Check on long-running subagents periodically
4. Review results - Verify subagent output before acting on recommendations

## Troubleshooting

| Issue | Solution |
| --- | --- |
| Subagent not starting | Verify the task description is clear and actionable |
| Missing tool access | Check if the required tool is available in subagent runtime (see table above) |
| Incomplete results | Provide more specific instructions or break into smaller tasks |

### Subscribing your team to Kiro - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Subscribing your team to Kiro

---

## Prerequisites

Before you begin, make sure you have the following:

- An AWS account - You can create an AWS account if you do not have one already.
- AWS permissions - As a Kiro admin, you must have the permissions to access the Kiro console in AWS in order to subscribe and manage Kiro users. The minimum permissions you'll need are described in Policy: Allow administrators to configure Kiro and subscribe users.
- AWS IAM Identity Center - You must have an instance of IAM Identity Center set up in your AWS account, with the identities of the users you want to subscribe to Kiro. Your IAM Identity Center instance must be in a supported AWS Region.
- Users and groups - You can add users and groups to IAM Identity Center's built-in directory, or to an external identity provider (IdP) that is connected to IAM Identity Center. For more information, see Getting started with IAM Identity Center.

## Create the Kiro profile

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console.
3. Make sure you are in your preferred supported AWS Region to create the Kiro profile and store user data.
4. Choose the Sign up for Kiro button.
5. Review the contents of the Create Kiro profile dialog box then choose Enable. The Kiro profile is created.
6. (Optional) Edit the profile with a different name or description as needed in the Settings page.

## Subscribe your team to Kiro

1. Switch to the Kiro console if you're not there yet.
2. Make sure you're in the AWS Region where you created the Kiro profile.
3. In the Users & Groups page, choose the Users or Groups tab.
4. Choose the Add user or Add group button. A dialog box appears where you can select the Kiro subscription tier (Pro, Pro+, Power) with details about each tier.
5. Choose the desired subscription tier and choose Continue.
6. In the search bar, search for a group or a user you want to subscribe to the selected tier, or select one from the drop down.
7. The group or user will auto-populate with what is available in the IAM Identity Center.
8. Select them and choose Assign. Users or groups are now subscribed.

### Managing Kiro subscriptions - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Managing Kiro subscriptions

---

## Change Kiro subscription plans

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console. If you don't see it, you might be in the wrong AWS Region.
3. In the Users & Groups page, choose the Users or Groups tab.
4. Choose the user or group whose subscriptions you want to upgrade or downgrade.
5. Choose Change plan then choose the new plan. Select Continue to finish.
6. If it is a higher tier plan, changes will happen immediately. If it is a lower tier plan, changes happen at the beginning of the following month.

To learn about what's offered at each subscription tier, see [Enterprise billing](../billing).

## Unsubscribe Kiro users

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console. If you don't see it, you might be in the wrong AWS Region.
3. In the Users & Groups page, choose the Users or Groups tab.
4. Choose the user or group whose subscriptions you want to cancel.
5. Choose Deactivate plan. Review the contents of the Unsubscribee dialog box then choose Unsubscribe.

After users unsubscribe, their subscriptions are marked as **Canceled**. They will lose access
immediately and can no longer access paid Kiro features.

## Enable overages for Kiro users

You might want to enable overages to give users the ability to continue working when they exceed their plan limits. Enabling overages has the following advantages:

- Uninterrupted productivity – When a user exceeds their plan's quota, they can continue working without disruption. The productivity benefits of continued access might outweigh the additional costs.
- Better usage pattern insights – Users get more accurate data about their actual usage, which helps in right-sizing future subscription needs.

By default, overages are *disabled*. Once enabled, overages become available to all users and groups in the profile. To enable overages:

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console. If you don't see it, you might be in the wrong AWS Region.
3. Choose Settings.
4. Find the Kiro settings section.
5. Turn on Overages.

Setting custom caps for overages is not yet supported (coming soon).

## Subscription statuses

You can view the status of your users' subscriptions on the **Subscriptions** page of the Kiro console. The statuses on the **User** tab are:

- Active – The user is subscribed to Kiro. You will be charged for active user subscriptions in the group.
- Canceled – The user subscription was canceled by an administrator. Unsubscribed users in the group can no longer access paid Kiro features. For more information, see Unsubscribe Kiro users.
- Pending – The user is subscribed but has not activated their subscription. You are not being charged for this subscription and there will be no data under Last active column.

There are no statuses on the **Groups** tab since subscriptions are assigned to users, not groups.

### Managing Your Kiro Subscription - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Managing Your Kiro Subscription

---

Your Kiro subscription gives you access to powerful AI-powered development tools. You can manage your subscription, view usage, and update billing information through the subscription portal.

## Accessing the subscription portal

Follow [this link](https://app.kiro.dev/account/usage) to the portal.

You can also use the `/usage` command to remind you of the URL.

## What you can do in the portal

Once you're in the subscription portal, you can:

- View current plan and usage statistics
- Upgrade or downgrade your subscription
- Update payment methods and billing information
- Download invoices and billing history
- Manage team members (for team plans)
- Cancel your subscription if needed

Loading image...

## Need help?

If you need assistance with your subscription, you can:

- Visit our billing support page
- Email us at billing@kiro.dev
- Use the help chat in the subscription portal

### Supported regions - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Supported regions

---

There are two AWS Regions relevant to Kiro administrators:

- The Region where your IAM Identity Center instance is enabled. This is where user identities are managed, and where subscriptions are stored.
- The Region where your Kiro profile is created. This is where data is stored and inference is done, and might be different from your IAM Identity Center instance's Region.

## Supported Kiro console and Kiro profile regions

The **Kiro** **console** and **Kiro profile** are supported in the following Regions:

- US East (N. Virginia)
- Europe (Frankfurt)

## IAM identity center regions supported by Kiro

The users that you want to subscribe to Kiro must have identities in an IAM Identity Center instance (or a connected identity provider) in one of the following Regions:

- US East (Ohio)
- US East (N. Virginia)
- US West (N. California)
- US West (Oregon)
- Asia Pacific (Mumbai)
- Asia Pacific (Osaka)
- Asia Pacific (Seoul)
- Asia Pacific (Singapore)
- Asia Pacific (Sydney)
- Asia Pacific (Tokyo)
- Canada (Central)
- Europe (Frankfurt)
- Europe (Ireland)
- Europe (London)
- Europe (Paris)
- Europe (Stockholm)
- South America (São Paulo)

### Tangent mode - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Tangent mode

---

Tangent mode creates conversation checkpoints, allowing you to explore side topics without disrupting your main conversation flow. Enter tangent mode, ask questions or explore ideas, then return to your original conversation exactly where you left off.

## Enabling tangent mode

Tangent mode is experimental and must be enabled:

**Via Experiment Command:**

```bash
/experiment
# Select tangent mode from the list

```

**Via Settings:**

```bash
kiro-cli settings chat.enableTangentMode true

```

## Basic usage

### Enter tangent mode

Use `/tangent` or **Ctrl+T**:

```
> /tangent
Created a conversation checkpoint (↯). Use ctrl + t or /tangent to restore the conversation later.

```

### In tangent mode

You'll see a yellow `↯` symbol in your prompt:

```
↯ > What is the difference between async and sync functions?

```

### Exit tangent mode

Use `/tangent` or **Ctrl+T** again:

```
↯ > /tangent
Restored conversation from checkpoint (↯). - Returned to main conversation.

```

### Exit with tail

Use `/tangent tail` to preserve the last conversation entry (question + answer):

```
↯ > /tangent tail
Restored conversation from checkpoint (↯) with last conversation entry preserved.

```

## Usage examples

### Example 1: Exploring alternatives

```
> I need to process a large CSV file in Python. What's the best approach?

I recommend using pandas for CSV processing...

> /tangent
Created a conversation checkpoint (↯).

↯ > What about using the csv module instead of pandas?

The csv module is lighter weight...

↯ > /tangent
Restored conversation from checkpoint (↯).

> Thanks! I'll go with pandas. Can you show me error handling?

```

### Example 2: Getting Kiro CLI help

```
> Help me write a deployment script

I can help you create a deployment script...

> /tangent
Created a conversation checkpoint (↯).

↯ > What Kiro CLI commands are available for file operations?

Kiro CLI provides read, write, shell...

↯ > /tangent
Restored conversation from checkpoint (↯).

> It's a Node.js application for AWS

```

### Example 3: Clarifying requirements

```
> I need to optimize this SQL query

Could you share the query you'd like to optimize?

> /tangent
Created a conversation checkpoint (↯).

↯ > What information do you need to help optimize a query?

To optimize SQL queries effectively, I need:
1. The current query
2. Table schemas and indexes...

↯ > /tangent
Restored conversation from checkpoint (↯).

> Here's my query: SELECT * FROM orders...

```

### Example 4: Keeping useful information

```
> Help me debug this Python error

I can help you debug that. Could you share the error message?

> /tangent
Created a conversation checkpoint (↯).

↯ > What are the most common Python debugging techniques?

Here are the most effective Python debugging techniques:
1. Use print statements strategically
2. Leverage the Python debugger (pdb)...

↯ > /tangent tail
Restored conversation from checkpoint (↯) with last conversation entry preserved.

> Here's my error: TypeError: unsupported operand type(s)...

# The preserved entry about debugging techniques is now part of main conversation

```

## Configuration

### Keyboard shortcut

Change the shortcut key (default: t):

```bash
kiro-cli settings chat.tangentModeKey y

```

### Auto-tangent for introspect

Automatically enter tangent mode for Kiro CLI help questions:

```bash
kiro-cli settings introspect.tangentMode true

```

## Visual indicators

- Normal mode: >  (magenta)
- Tangent mode: ↯ >  (yellow ↯ + magenta)
- With agent: [dev] ↯ >  (cyan + yellow ↯ + magenta)

## When to use tangent mode

### Good use cases

- Asking clarifying questions about the current topic
- Exploring alternative approaches before deciding
- Getting help with Kiro CLI commands or features
- Testing understanding of concepts
- Quick side questions that don't need to be in main context

### When not to use

- Completely unrelated topics - Start a new conversation instead
- Long, complex discussions - Use regular conversation flow
- When you want the side discussion in main context - Don't use tangent mode

## Tips

1. Keep tangents focused: Brief explorations, not extended discussions
2. Return promptly: Don't forget you're in tangent mode
3. Use for clarification: Perfect for "wait, what does X mean?" questions
4. Experiment safely: Test ideas without affecting main conversation
5. Use /tangent tail: When both the tangent question and answer are useful for main conversation

## How it works

### Checkpoint creation

When you enter tangent mode:

1. Current conversation state is saved as a checkpoint
2. You can continue the conversation in tangent mode
3. All tangent conversation is separate from main thread

### Restoration

When you exit tangent mode:

1. Conversation returns to the checkpoint state
2. Tangent conversation is discarded (unless using tail)
3. Main conversation continues as if tangent never happened

### Tail mode

Using `/tangent tail`:

1. Returns to checkpoint like normal exit
2. Preserves the last Q&A pair from tangent
3. Adds that Q&A to main conversation context
4. Useful when tangent provided valuable information

## Limitations

- Tangent conversations are discarded when you exit (unless using tail)
- Only one level of tangent supported (no nested tangents)
- Experimental feature that may change or be removed
- Must be explicitly enabled before use

## Troubleshooting

### Tangent mode not working

Enable via experiment:

```bash
/experiment
# Select tangent mode from the list

```

Or enable via settings:

```bash
kiro-cli settings chat.enableTangentMode true

```

### Keyboard shortcut not working

Check or reset the shortcut key:

```bash
kiro-cli settings chat.tangentModeKey t

```

Ensure you're using Ctrl+T (not just T).

### Lost in tangent mode

Look for the `↯` symbol in your prompt. Use `/tangent` to exit and return to main conversation.

### Accidentally discarded important information

If you exit tangent mode without using `tail` and lose important information:

1. Unfortunately, tangent conversations are not recoverable
2. You'll need to ask the question again in the main conversation
3. Consider using /tangent tail in the future to preserve important Q&A pairs

## Related features

- Introspect: Kiro CLI help (auto-enters tangent if configured)
- Experiments: Manage experimental features with /experiment
- Checkpointing: Similar concept but for file changes

## Best practices

### Workflow integration

1. Start main task: Begin your primary conversation
2. Hit tangent: When a side question arises, use /tangent
3. Explore freely: Ask clarifying questions without worry
4. Decide on tail: If the tangent was useful, use /tangent tail
5. Continue main: Return to your primary task

### Example workflow

```
> Help me refactor this React component

# Main conversation starts...

> /tangent
↯ > What's the difference between useMemo and useCallback?

# Get clarification...

↯ > /tangent tail  # This was useful, keep it

> Now I understand. Let's use useMemo for the expensive calculation...

```

## Next steps

- Experimental Features Overview
- Checkpointing
- Settings Configuration

### Thinking tool - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Thinking tool

---

The thinking tool enables Kiro to show its reasoning process when working through complex problems, providing transparency into how conclusions are reached.

## Overview

When enabled, the thinking tool allows Kiro to break down complex reasoning into visible steps, helping you understand the decision-making process and learn from the AI's approach to problem-solving.

## Enabling thinking tool

```bash
kiro-cli settings chat.enableThinking true

```

Or use the experiment command:

```bash
/experiment
# Select "Thinking" from the list

```

## How it works

When Kiro encounters a complex problem that requires multi-step reasoning, it will:

1. Show its thought process as it works through the problem
2. Break down the reasoning into logical steps
3. Explain intermediate conclusions before reaching the final answer
4. Make the decision-making transparent so you can follow along

## When thinking appears

The thinking tool is automatically invoked by Kiro when:

- Complex problem-solving requires multiple logical steps
- Analyzing trade-offs between different approaches
- Planning multi-step implementations with dependencies
- Debugging complex issues that need systematic analysis
- Making architectural decisions with multiple considerations

## Example usage

### Without thinking tool

```
> What's the best way to implement caching for our API?

I recommend using Redis for caching your API responses...

```

### With thinking tool

```
> What's the best way to implement caching for our API?

🧠 Thinking...

Let me think through the caching requirements:

1. First, I need to consider the type of data being cached
   - API responses suggest read-heavy workload
   - Need to handle cache invalidation

2. Evaluating caching solutions:
   - In-memory (fast but limited by RAM)
   - Redis (distributed, persistent, feature-rich)
   - Memcached (simple, fast, but less features)

3. Considering your use case:
   - API responses benefit from distributed cache
   - Need TTL support for automatic expiration
   - May need cache invalidation on updates

4. Redis appears best because:
   - Supports complex data structures
   - Built-in TTL and eviction policies
   - Can be distributed across nodes
   - Persistent if needed

Based on this analysis, I recommend using Redis for caching your API responses...

```

## Benefits

### For learning

- Understand reasoning patterns: See how complex problems are broken down
- Learn problem-solving approaches: Observe systematic analysis
- Identify gaps in logic: Spot where reasoning might be flawed

### For debugging

- Trace decision paths: Understand why certain recommendations were made
- Verify assumptions: Check if the AI's assumptions match your context
- Catch errors early: Spot logical errors before implementation

### For complex tasks

- Follow multi-step plans: See how complex tasks are decomposed
- Understand dependencies: Identify relationships between steps
- Validate approach: Confirm the reasoning aligns with your goals

## Use cases

### Architectural decisions

```
> Should we use microservices or a monolith for our new project?

🧠 Thinking...

Let me analyze this architectural decision:

1. Project characteristics to consider:
   - Team size and structure
   - Expected scale and growth
   - Deployment requirements
   - Development velocity needs

2. Microservices advantages:
   - Independent scaling
   - Technology flexibility
   - Isolated failures
   - But: increased complexity, operational overhead

3. Monolith advantages:
   - Simpler deployment
   - Easier debugging
   - Lower operational cost
   - But: scaling limitations, tight coupling

4. Decision factors:
   - Small team → Monolith likely better
   - Unclear requirements → Start with monolith
   - Need rapid iteration → Monolith faster initially
   - Can refactor to microservices later if needed

Based on this analysis...

```

### Algorithm selection

```
> What sorting algorithm should I use for this data?

🧠 Thinking...

Let me think through the sorting requirements:

1. Data characteristics:
   - Size of dataset
   - Is data partially sorted?
   - Memory constraints
   - Stability requirements

2. Algorithm options:
   - Quick Sort: O(n log n) average, O(n²) worst
   - Merge Sort: O(n log n) guaranteed, stable
   - Heap Sort: O(n log n), in-place
   - Tim Sort: Optimized for real-world data

3. Trade-offs:
   - If data is partially sorted → Tim Sort excels
   - If memory is limited → Heap Sort (in-place)
   - If stability matters → Merge Sort or Tim Sort
   - For general case → Quick Sort often fastest

4. Recommendation depends on...

```

### Debugging complex issues

```
> My application is slow but I don't know why

🧠 Thinking...

Let me systematically analyze potential performance issues:

1. Common performance bottlenecks:
   - Database queries (N+1 problem, missing indexes)
   - Network latency (API calls, external services)
   - Memory issues (leaks, excessive allocation)
   - CPU-bound operations (complex calculations)

2. Diagnostic approach:
   - First, profile to identify hotspots
   - Check database query patterns
   - Monitor network requests
   - Analyze memory usage patterns

3. Most likely culprits based on typical patterns:
   - Database queries often account for 60-80% of slowness
   - Should start there before optimizing code

4. Recommended investigation order...

```

## Configuration

### Enable/disable

```bash
# Enable
kiro-cli settings chat.enableThinking true

# Disable
kiro-cli settings chat.enableThinking false

# Check status
kiro-cli settings chat.enableThinking

```

## Limitations

### Performance impact

- Slower responses: Thinking adds time to generate responses
- More tokens used: Thinking process consumes additional tokens
- Longer output: Responses are more verbose

### When not to use

- Simple questions: Thinking overhead not needed for straightforward queries
- Quick iterations: May slow down rapid back-and-forth
- Well-defined tasks: When you just need the answer, not the reasoning

## Best practices

### When to enable

- Learning new concepts: Understand the reasoning behind recommendations
- Complex decisions: Need to validate the decision-making process
- Debugging: Want to see systematic problem analysis
- Code reviews: Understand why certain approaches are suggested

### When to disable

- Simple tasks: Straightforward questions don't need reasoning
- Speed priority: Need quick responses without explanation
- Familiar territory: Already understand the reasoning patterns

### Workflow integration

1. Enable for complex tasks: Turn on when starting difficult problems
2. Learn from reasoning: Observe how problems are broken down
3. Disable for execution: Turn off when implementing known solutions
4. Re-enable for review: Turn back on when validating approaches

## Troubleshooting

### Thinking not appearing

1. Verify it's enabled:
bashkiro-cli settings chat.enableThinking
2. Try a complex question: Simple questions may not trigger thinking
3. Restart chat session: Changes may require new session

### Too much thinking

If thinking output is overwhelming:

1. Disable for simpler tasks:
bashkiro-cli settings chat.enableThinking false
2. Ask for concise answers: Request brief responses explicitly
3. Use for specific questions: Enable only when needed

## Related features

- Experimental Features
- Tangent Mode - Explore reasoning without affecting main conversation
- TODO Lists - Break down complex tasks

## Next steps

- Enable other experimental features
- Configure settings
- Learn about custom agents

### TODO lists - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# TODO lists

---

The TODO list feature enables Kiro to automatically create and modify task lists, while providing you with commands to view and manage existing TODO lists.

## Getting started

TODO lists are automatically created when Kiro breaks down complex tasks. You can then manage these lists using the `/todo` command.

### Enable TODO lists

```bash
kiro-cli settings chat.enableTodoList true

```

### Basic usage

```bash
/todo view      # View existing TODO lists
/todo resume    # Resume a TODO list

```

## How it works

### Automatic creation

Kiro automatically creates TODO lists when:

- You ask for help with multi-step tasks
- A complex problem needs to be broken down
- You explicitly request a TODO list

**Example:**

```
> Make a todo list with 3 read-only tasks.

I'll create a todo list with 3 read-only tasks for you.

🛠️  Using tool: todo_list (trusted)
 ⋮ 
 ● TODO:
[ ] Review project documentation
[ ] Check system status
[ ] Read latest updates
 ⋮ 
 ● Completed in 0.4s

```

### Task management

Kiro can:

- Create TODO lists
- Mark tasks as complete
- Add/remove tasks
- Load TODO lists by ID
- Search for existing TODO lists

You can:

- View TODO lists
- Resume TODO lists
- Delete TODO lists

## Commands

### /todo view

Display and select a TODO list to view its contents, showing task descriptions and completion status.

```bash
/todo view

```

**Interactive selection shows:**

- ✓ Completed lists (green checkmark)
- ✗ In-progress lists with completion count (red X with progress)

**Example:**

```
> /todo view

? Select a to-do list to view: ›
❯ ✗ Unfinished todo list (0/3)
  ✔ Completed todo list (3/3)

```

### /todo resume

Show an interactive menu of available TODO lists with their current progress status. Selecting a list loads it back into your chat session, allowing Kiro to continue where it left off.

```bash
/todo resume

```

**Example:**

```
> /todo resume

⟳ Resuming: Read-only tasks for information gathering

🛠️  Using tool: todo (trusted)
 ⋮ 
 ● TODO:
[x] Review project documentation
[ ] Check system status
[ ] Read latest updates
 ⋮ 
 ● Completed in 0.1s

```

### /todo clear-finished

Remove all completed TODO lists from storage. This helps clean up your workspace by removing lists where all tasks have been completed.

```bash
/todo clear-finished

```

### /todo delete

Delete specific TODO lists or all lists at once.

```bash
/todo delete           # Interactive selection to delete one list
/todo delete --all     # Delete all TODO lists

```

**Options:**

- --all - Delete all TODO lists without interactive selection

## Storage

TODO lists are persisted across sessions

Each list is saved as a JSON file with:

- Unique timestamp-based ID
- Task descriptions and completion status
- Context updates from completed tasks
- Modified file paths
- Overall list description

### Directory structure

```
my-project/
├── .kiro/
│   └── cli-todo-lists/
│       ├── 1234567890-task-list.json
│       └── 1234567891-another-list.json
└── src/
    └── main.py

```

## Interactive selection

All commands use interactive selection allowing you to:

- Navigate with arrow keys
- Press Enter to select
- Press Esc to cancel

## Use cases

### Breaking down complex tasks

```
> I need to migrate our database from MySQL to PostgreSQL

Let me create a TODO list for this migration:

🛠️  Using tool: todo
 ● TODO: Database Migration
[ ] Backup current MySQL database
[ ] Set up PostgreSQL instance
[ ] Create schema migration scripts
[ ] Test migration on staging
[ ] Perform production migration
[ ] Verify data integrity

```

### Tracking multi-step implementations

```
> Help me implement user authentication

I'll break this down into manageable steps:

🛠️  Using tool: todo
 ● TODO: User Authentication Implementation
[ ] Set up authentication library
[ ] Create user model and database schema
[ ] Implement registration endpoint
[ ] Implement login endpoint
[ ] Add password hashing
[ ] Create JWT token generation
[ ] Add authentication middleware
[ ] Write tests for auth flow

```

### Resuming previous work

```
> /todo resume

? Select a to-do list to resume: ›
❯ ✗ User Authentication Implementation (3/8)
  ✗ Database Migration (1/6)
  ✔ Code Refactoring (5/5)

# Select "User Authentication Implementation"

⟳ Resuming: User Authentication Implementation

Let's continue with the authentication implementation. 
We've completed the first 3 tasks. Next up is implementing the login endpoint...

```

## Best practices

### Managing lists

- Use clear-finished regularly to remove completed lists
- Resume lists to continue complex multi-step tasks
- Check view to see progress without resuming

### Workflow integration

- Let Kiro create TODO lists for complex tasks automatically
- Use resume to pick up where you left off in previous sessions
- Check view to see what tasks remain before resuming work

### Organization

- Work in project directories where TODO lists are relevant
- Complete tasks in order for better context
- Delete old lists when no longer needed

## Limitations

### Functionality

- Cannot manually edit TODO list files
- Cannot merge or split TODO lists
- Cannot reorder tasks after creation

## Troubleshooting

### Tasks not updating

If task completion isn't being tracked:

1. Ensure TODO list is active: Resume the list first
2. Let Kiro mark tasks: Don't manually edit JSON files
3. Check for errors: Look for error messages in chat

## Tool vs command

### todo tool

The `todo` tool is for Kiro to call. Kiro can:

- Create TODO lists
- Mark tasks as complete
- Add/remove tasks
- Load TODO lists with given ID
- Search for existing TODO lists

### /todo command

The `/todo` command is for you to manage existing TODO lists. You can:

- View TODO lists
- Resume TODO lists
- Delete TODO lists
- Clear finished lists

## Example workflow

### 1. Start complex task

```
> I need to set up CI/CD for our project

```

### 2. Kiro creates TODO list

```
🛠️  Using tool: todo_list
 ● TODO: CI/CD Setup
[ ] Choose CI/CD platform
[ ] Create pipeline configuration
[ ] Set up build stage
[ ] Add test stage
[ ] Configure deployment stage
[ ] Set up environment variables
[ ] Test pipeline

```

### 3. Work through tasks

Kiro works through tasks, marking them complete as you go.

### 4. Resume later

```
> /todo resume

? Select a to-do list to resume: ›
❯ ✗ CI/CD Setup (4/7)

# Continue where you left off

```

### 5. Clean up when done

```
> /todo clear-finished

```

## Next steps

- Experimental Features Overview
- Checkpointing
- Custom Agents

### Troubleshooting custom agents - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Troubleshooting custom agents

---

## Overview

This guide helps you diagnose and resolve common issues when creating and using custom agents in Kiro CLI.

### Configuration errors

#### Invalid JSON syntax

**Problem** : Custom agent fails to load with JSON parsing errors.

**Symptoms**:

- Error messages mentioning "invalid JSON" or "syntax error"
- Custom agent not appearing in /agent list
- Fallback to default agent behavior

**Solutions**:

- Validate your JSON using a JSON validator or linter
- Check for common JSON errors:
  - Missing commas between array elements or object properties
  - Trailing commas after the last element
  - Unmatched brackets or braces
  - Unescaped quotes in string values
- Use /agent schema to verify your configuration structure

#### Schema validation errors

**Problem**: Custom agent configuration doesn't match the expected schema.

**Symptoms**:

- Warnings about unknown configuration fields
- Custom agent behavior not matching configuration
- Missing required fields errors

**Solutions**:

- Compare your configuration against the schema using /agent schema
- Check field names for typos (e.g., allowedTools vs allowedTool)
- Verify data types match schema requirements (arrays vs strings, booleans vs strings)

### Custom agent loading issues

#### Custom agent not found

**Problem**: Custom agent doesn't appear in the list or can't be used.

**Symptoms**:

- /agent list doesn't show your custom agent
- Fallback to default agent without warning

**Solutions**:

- Verify the custom agent file is in the correct location:
  - Global: ~/.kiro/agents/[name].json
  - Workspace: .kiro/agents/[name].json
- Check file permissions - ensure the file is readable
- Verify the filename matches the custom agent name you're trying to use
- Ensure the file has a .json extension

#### Wrong custom agent version loading

**Problem**: A different version of your custom agent is loading than expected.

**Symptoms**:

- Custom agent behavior doesn't match your recent configuration changes
- Warning message about custom agent conflicts
- Unexpected tool availability or permissions

**Solutions**:

- Check for custom agent name conflicts between local and global directories
- Remember that local custom agents take precedence over global custom agents
- Use /agent list to see which version is being loaded
- Remove or rename conflicting custom agent files if necessary

### Tool permission problems

### Tool not available

**Problem**: Custom agent can't access a tool you've configured.

**Symptoms**:

- Error messages about unknown or unavailable tools
- Custom agent asking for permission for tools in allowedTools
- MCP server tools not working

**Solutions**:

- Verify tool names are spelled correctly in the tools array
- For MCP tools, ensure the server is properly configured in mcpServers
- Check that MCP servers are running and accessible
- Use correct syntax for MCP tools: @server_name/tool_name
- Verify built-in tool names against the built-in tools documentation

#### /tools command returns empty list

**Problem**: The /tools command shows no available tools or fewer tools than expected.

**Symptoms**:

- /tools returns an empty list
- Expected tools are missing from the tools list
- Custom agent appears to have no capabilities

**Common causes**:

- Empty tools array in the custom agent configuration
- Typos in tool names within the tools array
- Incorrect MCP server tool names (missing server prefix)
- MCP server configuration issues preventing tool loading

**Solutions**:

- Check that your custom agent configuration includes a tools array with valid tool names
- Verify tool names are spelled correctly (case-sensitive)
- For MCP tools, ensure you're using the correct server-prefixed format: @server-name___tool-name
- Test with the default agent to confirm tools are available /tools
- Check MCP server status if using external tools

#### Unexpected permission prompts

**Problem**: Custom agent prompts for permission for tools you thought were pre-approved.

**Symptoms**:

- Permission prompts for tools listed in allowedTools
- Workflow interruptions despite custom agent configuration

**Solutions**:

- Ensure tools are listed in both tools and allowedTools arrays
- Check for typos in tool names between the two arrays
- For MCP tools, use the full server-prefixed name inallowedTools
- Verify that toolAliases are correctly applied

### Debugging custom agent behavior

#### Missing context or resources

**Problem**: Custom agent doesn't seem to have access to expected files or context.

**Solutions**:

- Verify file paths in the resources array are correct and files exist
- Check that glob patterns in resources are matching the intended files
- Ensure hook commands are executing successfully and producing output
- Test hook commands manually to verify they work in your environment
- Check hook timeout settings if commands are being cut off

#### MCP server issues

**Problem**: MCP servers aren't working or tools aren't available.

**Solutions**:

- Verify MCP server commands are correct and executables are in your PATH
- Check that required environment variables are set
- Test MCP servers independently to ensure they're working
- Review MCP server logs for error messages
- Increase timeout values if servers are slow to start

#### Testing custom agent configurations

To systematically test your custom agent configuration:

- Validate JSON syntax using a JSON validator
- Check configuration against schema using /agent schema
- Test custom agent loading with /agent list
- Switch to the custom agent with /agent swap [name]
- Test each tool individually to verify access and permissions
- Verify that resources and hooks are providing expected context
- Test common workflows to ensure the custom agent behaves as expected

## Next steps

- Review the Configuration reference for detailed options
- Check Examples for working configurations
- Learn about Creating custom agents

### Viewing per-user activity - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Viewing per-user activity

---

You can configure Kiro to collect user activity telemetry of individual Kiro subscribers in your organization and present that information in a report. The report gives you insights into how specific users are using Kiro.

## About the report

Kiro generates the user activity report every day at midnight (00:00) Coordinated Universal Time (UTC), and saves it in a CSV file at the following path:

`s3://bucketName/prefix/AWSLogs/accountId/KiroLogs/  by_user_analytic/Region/year/month/day/00/accountId_by_user_analytic_timestamp.csv`
The CSV file is laid out as follows:

- Each row shows a user who interacted with Kiro that day.
- Each column shows a metric, as described in User activity report metrics. Metrics are calculated based on the user telemetry collected over the course of the day.

If more than 1,000 users interact with Kiro during the day, Kiro splits the data into several CSV files containing 1,000 users each. Files are suffixed with `part_1`, `part_2`, and so on.

When you enable user activity reports, Kiro collects user telemetry and stores it in the S3 bucket in your account. This is controlled at the administrator level and can't be configured by users.

## Enable user activity reports

Use the following instructions to enable user activity reports.

#### Prerequisite

Create an Amazon S3 bucket to hold the user activity report CSV file. The bucket must:

- Be in the AWS Region where the Kiro profile was installed. This profile was installed when you subscribed IAM Identity Center workforce users to Kiro Pro for the first time. For more information about this profile and the Regions where it's supported, see Kiro profile and Supported Regions.
- Be in the AWS account where users are subscribed. If users are subscribed in multiple AWS accounts, then you must create buckets in each of those accounts. Cross-account buckets are not supported.
- (Optional but recommended) Be different from the bucket you might be using for logging users' prompts.
- Include a prefix, also known as a subfolder, where Kiro will save the CSV file. The CSV file cannot be saved in the root of the bucket.
- Have a bucket policy like the one that follows. Replace bucketName, Region, accountId, and prefix with your own information.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "KiroLogsWrite",
      "Effect": "Allow",
      "Principal": {
        "Service": "q.amazonaws.com"
      },
      "Action": [
        "s3:PutObject"
      ],
      "Resource": [
        "arn:aws:s3:::bucketName/prefix/*"
      ],
      "Condition": {
        "StringEquals": {
          "aws:SourceAccount": "111122223333"
        },
        "ArnLike": {
          "aws:SourceArn": "arn:aws:codewhisperer:us-east-1:111122223333:*"
        }
      }
    }
  ]
}

```

To learn about protecting the data in your Amazon S3 bucket, see [Protecting data with encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingEncryption.html) in the *Amazon Simple Storage Service User Guide*.

#### To enable user activity reports

1. Sign in to the AWS console.
2. Switch to the Kiro console. To use the Kiro console, you must have the permissions defined in Policy: Allow administrators to configure Kiro and subscribe users.
3. Choose Settings.
4. Under Kiro user activity reports, choose Edit.
5. Toggle Collect granular metrics per user.
6. Under S3 location, enter the Amazon S3 URI that you will use to hold the CSV reports. Example: s3://amzn-s3-demo-bucket/user-activity-reports/

## User activity report metrics

The following table describes the metrics that are included in the user activity reports generated by Kiro.

| Metric name | Description |
| --- | --- |
| Chat_AICodeLines | Lines of code suggested by Kiro and accepted by the user. This metric includes code that was generated through the Kiro chat (not inline chat) and inserted into the IDE. |
| Chat_MessagesInteracted | Number of chat messages where the user has interacted positively with Kiro. Examples of positive interactions: clicking a link, inserting a suggestion, and upvoting a response from Kiro. This metric includes messages that were generated by Kiro chat (not inline chat). |
| Chat_MessagesSent | Number of messages sent to and from Kiro. This metric includes the user prompts and Kiro responses in the Kiro chat (not inline chat). |
| CodeFix_AcceptanceEventCount | Number of code fixes suggested by Kiro and accepted by the user. This metric applies to code fixes generated through the code review feature. |
| CodeFix_AcceptedLines | Lines of code suggested by Kiro and accepted by the user. This metric applies to lines of code generated through the code review feature. |
| CodeFix_GeneratedLines | Lines of code suggested by Kiro. This metric applies to lines of code generated through the code review feature. |
| CodeFix_GenerationEventCount | Number of code fixes suggested by Kiro. This metric applies to code fixes generated through the code review feature. |
| CodeReview_FailedEventCount | Number of code issues that were found but for which Kiro could not suggest a code fix. This metric applies to code issues generated using the code review feature. |
| CodeReview_FindingsCount | Number of code issues found by Kiro. This metric applies to code issues found using the code review feature. |
| CodeReview_SucceededEventCount | Number of code issues that were found and for which Kiro was able to generate a suggested code fix. This metric applies to code issues found using the code review feature. |
| Dev_AcceptanceEventCount | Number of code features suggested by Kiro and accepted by the user. This metric applies to code features generated through the /dev command. |
| Dev_AcceptedLines | Lines of code suggested by Kiro and accepted by the user. This metric applies to lines of code generated through the /dev command. |
| Dev_GeneratedLines | Lines of code suggested by Kiro. This metric applies to lines of code generated through the /dev command. |
| Dev_GenerationEventCount | Number of code features suggested by Kiro. This metric applies to code features generated through the /dev command. |
| DocGeneration_AcceptedFileUpdates | Number of file updates suggested by Kiro and accepted by the user. This metric applies to file updates generated through the /doc command. |
| DocGeneration_AcceptedFilesCreations | Number of file creations suggested by Kiro and accepted by the user. This metric applies to file creations generated through the /doc command. |
| DocGeneration_AcceptedLineAdditions | Lines of documentation additions suggested by Kiro and accepted by the user. This metric applies to documentation generated through the /doc command. |
| DocGeneration_AcceptedLineUpdates | Lines of documentation updates suggested by Kiro and accepted by the user. This metric applies to documentation generated using the /doc command. |
| DocGeneration_EventCount | Number of times the user engaged with Kiro using the /doc command. |
| DocGeneration_RejectedFileCreations | Number of file creations suggested by Kiro and rejected by the user. This metric applies to file creations generated through the /doc command. |
| DocGeneration_RejectedFileUpdates | Number of file updates suggested by Kiro and rejected by the user. This metric applies to file updates generated through the /doc command. |
| DocGeneration_RejectedLineAdditions | Lines of documentation additions suggested by Kiro and rejected by the user. This metric applies to documentation generated through the /doc command. |
| DocGeneration_RejectedLineUpdates | Lines of documentation updates suggested by Kiro and rejected by the user. This metric applies to documentation generated using the /doc command. |
| InlineChat_AcceptedLineAdditions | Lines of code additions suggested by Kiro and accepted by the user. This metric includes code additions generated through the inline chat (not Kiro chat). |
| InlineChat_AcceptedLineDeletions | Lines of code deletions suggested by Kiro and accepted by the user. This metric includes code deletions suggested through the inline chat (not Kiro chat). |
| InlineChat_AcceptanceEventCount | Number of inline chat (not Kiro chat) suggestions that were accepted by the user. |
| InlineChat_DismissalEventCount | Number of inline chat (not Kiro chat) suggestions that were abandoned by the user. By 'abandoned', we mean that the code suggestion was displayed but the user kept typing or performing other operations in their IDE, and did not explicitly accept or reject the code suggestion. |
| InlineChat_DismissedLineAdditions | Lines of code additions suggested by Kiro and abandoned by the user. By 'abandoned', we mean that the code suggestion was displayed but the user kept typing or performing other operations in their IDE, and did not explicitly accept or reject the code suggestion. This metric includes code additions generated through the inline chat (not Kiro chat). |
| InlineChat_DismissedLineDeletions | Lines of code deletions suggested by Kiro and abandoned by the user. By 'abandoned', we mean that the code suggestion was displayed but the user kept typing or performing other operations in their IDE, and did not explicitly accept or reject the code suggestion. This metric includes code deletions suggested through the inline chat (not Kiro chat). |
| InlineChat_EventCount | Number of inline chat (not Kiro chat) sessions that the user engaged in. |
| InlineChat_RejectedLineAdditions | Lines of code additions suggested by Kiro and rejected by the user. This metric includes code additions generated through the inline chat (not Kiro chat). |
| InlineChat_RejectedLineDeletions | Lines of code deletions suggested by Kiro and rejected by the user. This metric includes code deletions suggested through the inline chat (not Kiro chat). |
| InlineChat_RejectionEventCount | Number of inline chat (not Kiro chat) suggestions that were rejected by the user. |
| Inline_AICodeLines | Lines of code suggested by Kiro and accepted by the user. This metric includes code that was accepted as inline suggestions. |
| Inline_AcceptanceCount | Number of inline suggestions accepted by the user. |
| Inline_SuggestionsCount | Number of inline suggestions displayed to the user. |
| TestGeneration_AcceptedLines | Lines of code suggested by Kiro and accepted by the user. This metric applies to lines of code generated through the /test command. |
| TestGeneration_AcceptedTests | Number of unit tests suggested by Kiro and accepted by the user. This metric applies to unit tests generated through the /test command. |
| TestGeneration_EventCount | Number of times the user engaged with Kiro through the /test command. |
| TestGeneration_GeneratedLines | Lines of code suggested by Kiro. This metric applies to lines of code generated through the /test command. |
| TestGeneration_GeneratedTests | Number of unit tests suggested by Kiro. This metric applies to unit tests generated through the /test command. |
| Transformation_EventCount | Number of times the user engaged with Kiro through the /transform command, excluding the times when the user transformed code on the command line. |
| Transformation_LinesGenerated | Lines of code suggested by Kiro. This metric applies to code generated through the /transform command, excluding code transformed on the command line. |
| Transformation_LinesIngested | Lines of code provided to Kiro for transformation. This metric applies to code that is provided through the /transform command, excluding code provided for transformation on the command line, or for an SQL conversion. |

### Kiro and interface endpoints (AWS PrivateLink) - CLI - Docs - Kiro

<!-- toolType: custom-agent -->

# Kiro and interface endpoints (AWS PrivateLink)

---

You can establish a private connection between your VPC and Kiro by creating an interface VPC endpoint. Interface endpoints are powered by [AWS PrivateLink](https://aws.amazon.com/privatelink/), a technology that enables you to privately access Kiro APIs without an internet gateway, NAT device, VPN connection, or AWS Direct Connect connection. Instances in your VPC don't need public IP addresses to communicate with Kiro APIs. Traffic between your VPC and Kiro does not leave the Amazon network.

Each interface endpoint is represented by one or more [Elastic Network Interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html) in your subnets.

For more information, see [Interface VPC endpoints (AWS PrivateLink)](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html) in the Amazon VPC User Guide.

## Considerations for Kiro VPC endpoints

Before you set up an interface VPC endpoint for Kiro, ensure that you review [Interface endpoint properties and limitations](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html#vpce-interface-limitations) in the Amazon VPC User Guide.

Kiro supports making calls to all of its API actions from your VPC, in the context of services that are configured to work with Kiro.

## Prerequisites

Before you begin any of the procedures below, ensure that you have the following:

- An AWS account with appropriate permissions to create and configure resources.
- A VPC already created in your AWS account.
- Familiarity with AWS services, especially Amazon VPC and Kiro.

## Creating an interface VPC endpoint for Kiro

You can create a VPC endpoint for Kiro using either the Amazon VPC console or the AWS Command Line Interface (AWS CLI). For more information, see [Creating an interface endpoint](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html#create-interface-endpoint) in the Amazon VPC User Guide.

Create a VPC endpoint for Kiro using one of the following service names:

- com.amazonaws.us-east-1.q
- com.amazonaws.eu-central-1.q
- com.amazonaws.us-east-1.codewhisperer

Kiro supports Amazon Q Developer profiles in the US East (N. Virginia) and Europe (Frankfurt) regions. Also, the Amazon CodeWhisperer endpoint (com.amazonaws.us-east-1.codewhisperer) is only supported in the US East (N. Virginia) Region.

If you enable private DNS for the endpoint, you can make API requests to Kiro using its default DNS name for the Region, for example, `q.us-east-1.amazonaws.com`.

For more information, see [Accessing a service through an interface endpoint](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html#access-service-though-endpoint) in the Amazon VPC User Guide.

## Using an on-premises computer to connect to a Kiro endpoint

This section describes the process of using an on-premises computer to connect to Kiro through a AWS PrivateLink endpoint in your AWS VPC.

1. Create a VPN connection between your on-premises device and your VPC.
2. Create an interface VPC endpoint for Kiro.
3. Set up an inbound Amazon Route 53 endpoint. This will enable you to use the DNS name of your Kiro endpoint from your on-premises device.

## Autonomous Agent

<!-- toolType: autonomous-agent -->

### Kiro autonomous agent - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Kiro autonomous agent

---

Kiro autonomous agent works independently on development tasks, from implementing features to fixing bugs. It operates asynchronously in isolated sandbox environments, learning from your code reviews and building deep understanding of your codebase and patterns.

## Get started

Everything you need to begin using Kiro autonomous agent.

## Configuration

### Chatting with the agent - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Chatting with the agent

---

You can chat with Kiro autonomous agent to discuss approaches, ask questions, and provide guidance before and during task execution.

## Before creating a task

Use chat to:

- Discuss different implementation approaches
- Clarify requirements or constraints
- Get the agent's input on technical decisions

The agent has access to web search, learnings from previous code reviews, and context from other tasks to provide informed responses.

## During task execution

Once a task is created, you can continue chatting to:

- Steer the agent on the implementation approach
- Provide additional requirements or constraints
- Ask the agent to do more work after reviewing initial results

Any comments or steering will update the scope of the current task. You cannot create a second task in the same chat—to work on a different task, start a new chat.

### Creating tasks - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Creating tasks

---

You can create tasks for Kiro autonomous agent (Preview) in several ways, depending on your workflow.

## From app.kiro.dev/agent

Navigate to [app.kiro.dev/agent](https://app.kiro.dev/agent) to start a new chat:

1. Optionally select multiple repositories when starting the chat
2. Describe what you want the agent to do
3. If you didn't select repositories at the start, you'll be prompted to choose them when you ask Kiro to work on something

The agent will analyze your request, break down the work, and begin execution.

Kiro autonomous agent can work across multiple repositories in a single task. When you assign work that spans multiple repos, it coordinates all changes and opens pull requests in each one. Only select repositories you trust, especially when mixing public and private repos, as the agent will learn from and follow instructions in the repository code even if these are malicious.

## From GitHub issues

You'll need to [connect GitHub](/docs/autonomous-agent/github) first.

**Using the /kiro command**

Mention `/kiro` in a comment on any issue to assign that specific task to Kiro autonomous agent.

**Using the Kiro label**

Add the `kiro` label to any issue. Kiro autonomous agent will start working on the task and listen to all comments on the issue for additional context or feedback.

## Task lifecycle

Tasks move through different states as the agent works:

**Queued**

The task is waiting to start. This happens when you've reached the limit of 10 concurrent tasks.

**In progress**

The agent is actively working on the task, analyzing requirements, writing code, or running tests.

**Needs attention**

The task needs input or the agent has a clarification question. Review the agent's message and provide the requested information to unblock the task.

**Completed**

The agent has finished the work and opened pull requests. Review the changes and provide feedback. Providing feedback moves the task to queued and then to in progress when a parallel task slot becomes available.

**Cancelled**

The task was cancelled and will not be completed. Cancelled tasks cannot be resumed.

## Task tips

Follow these best practices when creating tasks:

**Be specific about the outcome**

Clearly describe what you want the end result to look like. Instead of "improve the login flow," say "add password reset functionality to the login page with email verification."

**Describe the problem you're trying to solve**

Explain the context and why the work is needed. This helps the agent understand constraints and make better implementation decisions.

**Provide relevant context**

Link to related documentation, examples, or existing code that should inform the implementation.

**Define acceptance criteria**

List specific conditions that must be met for the task to be considered complete.

**Use steering files**

Kiro autonomous agent automatically looks for [steering files](/docs/steering) in the `.kiro/steering/` folder at the root of your repository. These markdown files define your team's standards, architecture, and conventions, ensuring the agent consistently follows your established patterns without needing to explain them in every task. Steering files are particularly useful for coding conventions, architecture patterns, technology stack preferences, and testing approaches.

### Data protection - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Data protection

---

## Shared responsibility model

The AWS [shared responsibility model](https://aws.amazon.com/compliance/shared-responsibility-model/) applies to data protection in Kiro autonomous agent. As described in this model, AWS is responsible for protecting the global infrastructure that runs all of the AWS Cloud. You are responsible for maintaining control over your content that is hosted on this infrastructure. You are also responsible for the security configuration and management tasks for the AWS services that you use. For more information about data privacy, see the [Data Privacy FAQ](https://aws.amazon.com/compliance/data-privacy-faq/).

## Data storage

Kiro autonomous agent stores your task descriptions, chat messages, code changes, and additional context to execute tasks and generate responses. For information about how data is encrypted, see [Data encryption](#data-encryption).

### AWS regions where content is stored and processed

During the preview, all Kiro autonomous agent content, such as task descriptions, chat messages, and code changes, is stored in the US East (N. Virginia) Region.

With cross-region inferencing, your content may be processed in a different Region within the United States. For more information, see [Cross-region processing](#cross-region-processing).

## Cross-region processing

Kiro autonomous agent uses cross-region inference to distribute traffic across different AWS Regions to enhance large language model (LLM) inference performance and reliability. With cross-region inference, you get increased throughput and resilience during high demand periods, as well as improved performance.

Cross-region inference doesn't affect where your data is stored. All data remains stored in the US East (N. Virginia) Region during the preview.

### Supported regions for Kiro autonomous agent cross-region inference

| Supported geography | Inference regions |
| --- | --- |
| United States | US East (N. Virginia) (us-east-1)US West (Oregon) (us-west-2)US East (Ohio) (us-east-2) |

## Data encryption

This topic provides information specific to Kiro autonomous agent about encryption in transit and encryption at rest.

### Encryption in transit

All communication between customers and Kiro autonomous agent and between Kiro autonomous agent and its downstream dependencies is protected using TLS 1.2 or higher connections.

### Encryption at rest

Kiro autonomous agent encrypts your data using AWS owned encryption keys from AWS Key Management Service (AWS KMS). You don't have to take any action to protect the AWS managed keys that encrypt your data. For more information, see [AWS owned keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) in the *AWS Key Management Service Developer Guide*.

## Service improvement

To help Kiro provide the most relevant information, we may use certain content from Kiro autonomous agent, such as task descriptions, chat messages, other inputs you provide, and the responses and code that Kiro generates, for service improvement. This page explains what content we use and how to opt out.

### Kiro autonomous agent content used for service improvement

We may use certain content from Kiro autonomous agent for service improvement. Content that Kiro may use for service improvement includes, for example, your task descriptions, chat messages, other inputs you provide, and the responses and code that Kiro generates. Kiro may use this content, for example, to provide better responses to common questions, fix Kiro operational issues, for de-bugging, or for model training.

## Opt out of data sharing

By default, Kiro autonomous agent collects content for service improvement. This section explains how to opt out of sharing your data.

### Opting out of sharing content in Kiro autonomous agent

To opt out of sharing your client-side telemetry and content in Kiro autonomous agent:

1. Go to app.kiro.dev/agent/settings
2. Navigate to the Data collection section
3. Toggle off Allow AWS to use your Kiro autonomous agent content for service improvement

### Environment Configuration - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Environment Configuration

---

You can configure the sandbox environment using a [Dockerfile](https://docs.docker.com/reference/dockerfile/). This defines your development environment configuration, including dependencies, build commands, and runtime requirements.

## Automatic configuration

Kiro autonomous agent looks for a `Dockerfile` in the root of your repository. If found, the agent automatically configures the sandbox based on these specifications, ensuring the environment matches your project's requirements.

Only publicly available container images are supported. Private registry images and private repositories cannot be accessed by the sandbox.

## Dockerfile configuration

You can use a standard [Dockerfile](https://docs.docker.com/reference/dockerfile/) to configure the sandbox environment. The agent will build and use the Docker image defined in your Dockerfile.

Example Dockerfile:

```dockerfile
FROM node:18

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm install

# Copy application code
COPY . .

# Set environment variables
ENV NODE_ENV=production

# Expose port
EXPOSE 3000

# Start command
CMD ["npm", "start"]

```

### Environment Variables - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Environment Variables

---

Configure environment variables and secrets for autonomous agent execution.

## Environment Variables

Set environment variables that will be available to the agent during task execution. These are useful for configuration values that aren't sensitive.

## Secrets

Securely manage sensitive credentials and API keys in the sandbox. Secrets are encrypted at rest and exposed as environment variables in the isolated sandbox during task execution. The agent may exfiltrate these secrets through code changes, logs, or external requests, so only provide secrets necessary for the task and only use the agent with repositories you trust.

## Duplicate Keys

If the same key exists in both environment variables and secrets, the environment variable value takes precedence.

### GitHub - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# GitHub

---

Kiro autonomous agent (Preview) integrates with GitHub to work on your repositories.

## Installation

Connect your GitHub account to Kiro autonomous agent:

1. Navigate to app.kiro.dev/agent and go to Settings
2. Select "Connect GitHub" under Integrations
3. Authorize the Kiro Agent GitHub app
4. Grant access to specific repositories or all repositories in your organization

The Kiro Agent GitHub app only needs to be installed once per organization or account. Organization owners select which repositories the app can access, controlling which repositories are available to Kiro.

Individual users then connect their GitHub account to Kiro. Each user sees all repositories where both conditions are met:

1. The Kiro Agent GitHub app has been installed and authorized for that repository
2. The user's GitHub account has access to that repository

This means you'll see repositories from personal accounts, shared repositories, and organizations—regardless of who installed the app—as long as your GitHub user has access.

Users can only assign tasks to repositories where they have write permissions. Other users cannot assign tasks on your behalf—each user controls their own agent tasks.

## Assigning tasks from GitHub issues

You can assign work to Kiro autonomous agent directly from GitHub issues in two ways:

- Add the kiro label - Kiro will start working on the task and listen to all comments on the issue for additional context or feedback.
- Mention /kiro in a comment - Assigns that specific issue to Kiro.

If you use `/kiro` but haven't registered your GitHub account with Kiro, you'll receive instructions on how to sign up. The Kiro Agent GitHub app must be installed on the repository for this to work.

## How the agent works with GitHub

**Clones repositories**

The agent clones authorized repositories into its [isolated sandbox environment](/docs/autonomous-agent/sandbox). It can work across multiple repositories in a single task, maintaining context and coordinating changes.

**Creates branches and commits**

For each task, the agent creates a feature branch from your default branch, makes commits with clear messages, and pushes to your repository. The agent acts on your behalf and includes both you and itself as co-authors in every commit, ensuring proper attribution.

**Opens and updates pull requests**

After completing work, the agent opens pull requests with a detailed description of changes, implementation approach, and any trade-offs considered.

The agent only responds to your explicit feedback and instructions (the user who created the task). When you provide feedback, the agent will address all comments on the pull request, including those from other reviewers. If you don't want a comment to be addressed, delete it before providing your feedback, or reply to it with your own perspective (which will trigger the agent to review).

GitHub action feedback (automated checks, tests, security scans) is automatically addressed when you provide any feedback.

You can provide feedback in two ways:

- Leave comments directly on the pull request
- Provide feedback from the task view on app.kiro.dev/agent

**Learns from your code reviews**

You can teach the agent your team's patterns through PR feedback. When you leave comments like "remember to use our standard error handling" or "always follow our naming conventions," the agent learns and applies those patterns to future work across all repositories. Only your feedback influences the agent's learnings—other reviewers' comments don't affect what the agent learns.

## Multiple users on the same repository

When multiple team members have Kiro autonomous agent connected to the same repository, each user can independently assign tasks.

**How it works**

- The Kiro Agent GitHub app only needs to be installed once per repository
- Each registered user can assign tasks independently
- If multiple users assign the same GitHub issue (using the kiro label or /kiro command), Kiro creates separate tasks for each user
- Each task runs independently in its own isolated sandbox environment

**Best practices**

- Coordinate with your team to avoid duplicate work on the same issue
- Use GitHub's issue assignment feature to indicate who is working on what
- Review open pull requests before assigning similar tasks to avoid conflicts

## Permissions

Connecting to GitHub requires several layers of access control.

**App installation and configuration**

The Kiro Agent GitHub app is installed once per organization or account by an owner. The app configuration is global and defines the maximum set of repositories that Kiro can access. All users in the organization share this app installation.

**Repository-level access**

Each user can only work with repositories where both conditions are met:

- The Kiro Agent GitHub app has been granted access by an organization owner
- The user has write permissions on the repository

This two-layer approach ensures that owners control the maximum scope of access while individual users can only assign tasks to repositories they personally have access to.

**Repository permissions**

The following repository permissions are required:

Read & Write:

- Actions - Workflows, workflow runs and artifacts
- Checks - Checks on code
- Contents - Repository contents, commits, branches, downloads, releases, and merges
- Issues - Issues and related comments, assignees, labels, and milestones
- Pull requests - Pull requests and related comments, assignees, labels, milestones, and merges
- Workflows - Update GitHub Action workflow files

Read-only:

- Metadata - Search repositories, list collaborators, and access repository metadata (mandatory)
- Administration - Repository creation, deletion, settings, teams, and collaborators
- Commit statuses - Commit statuses

**Organization permissions**

Read-only:

- Administration - Manage access to an organization

**Webhook events**

The app subscribes to the following webhook events:

- Pull requests (opened, synchronized, closed, etc.)
- Pull request reviews (submitted, edited, dismissed)
- Pull request review comments (created, edited, deleted)
- Issues (opened, edited, closed, labeled, etc.)
- Issue comments (created, edited, deleted)
- Push events
- Branch and tag creation/deletion
- Releases (created, edited, published, etc.)
- Repository changes (created, deleted, renamed, etc.)
- Repository dispatch and ruleset events
- Workflow runs (requested, completed)
- Installation target changes

**User permissions**

Users must have write access to create branches and open pull requests.

**Branch protection**

The agent respects your branch protection rules. It cannot push directly to protected branches and must go through your standard pull request workflow.

**Organization policies**

If your organization has security policies or required status checks, the agent follows these requirements.

**Revocation**

Organization owners can revoke the agent's access at any time by removing repository permissions from the Kiro Agent GitHub app, which immediately blocks access for all users. Individual users can disconnect their GitHub account from Kiro at any time, which stops their agent from accessing any repositories.

### Internet Access - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Internet Access

---

Control which domains Kiro autonomous agent can access during task execution. You can choose from three network access levels: Connections access only, Common dependencies, or Open internet. You can also create a custom allow-list.

## Connections access only

The minimum access level required for the sandbox to function. This allows the agent to:

- Clone GitHub repositories
- Open and update pull requests
- Access GitHub via our gateway service

This is the most secure option and recommended when your tasks don't require external dependencies.

## Common dependencies

Includes access to connections plus common package registries and development tools. This level allows the agent to install dependencies from popular package managers without requiring full internet access.

The following domains are automatically allowed:

```
alpinelinux.org
amazonaws.com
anaconda.com
apache.org
apt.llvm.org
archlinux.org
aws.amazon.com
azure.com
bitbucket.org
bower.io
centos.org
cocoapods.org
continuum.io
cpan.org
crates.io
debian.org
docker.com
docker.io
dot.net
dotnet.microsoft.com
eclipse.org
fedoraproject.org
gcr.io
ghcr.io
github.com
githubusercontent.com
gitlab.com
golang.org
google.com
goproxy.io
gradle.org
hashicorp.com
haskell.org
hex.pm
java.com
java.net
jcenter.bintray.com
json-schema.org
json.schemastore.org
k8s.io
launchpad.net
maven.org
mcr.microsoft.com
metacpan.org
microsoft.com
nodejs.org
npmjs.com
npmjs.org
nuget.org
oracle.com
packagecloud.io
packages.microsoft.com
packagist.org
pkg.go.dev
ppa.launchpad.net
pub.dev
pypa.io
pypi.org
pypi.python.org
pythonhosted.org
quay.io
ruby-lang.org
rubyforge.org
rubygems.org
rubyonrails.org
rustup.rs
rvm.io
sourceforge.net
spring.io
swift.org
ubuntu.com
visualstudio.com
yarnpkg.com

```

## Open internet

Gives the sandbox unrestricted internet access.

Enabling network permissions exposes your environment to security risks. These include prompt injection attacks, extraction of code and secrets, introduction of malware or security flaws, and use of content that may violate licensing terms. Consider these risks carefully before enabling network permissions.

## Custom allow-list

You can specify a custom comma-separated list of allowed domains. Use the `.domain` format to include all subdomains.

**Examples:**

- api.example.com - Allow only this specific domain
- .example.com - Allow example.com and all subdomains (api.example.com, www.example.com, etc.)
- api.example.com, .cdn.example.com - Allow multiple domains and subdomain patterns

### MCP - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# MCP

---

The MCP (Model Context Protocol) configuration is loaded into the agent sandbox and available during task execution. This allows the agent to use specialized tools and access external data sources through MCP servers.

MCP servers are third-party tools. Only install servers from trusted sources and review their documentation and licensing. Kiro is not responsible for third-party MCP servers.

MCP servers require [Open Internet](/docs/autonomous-agent/sandbox/internet-access) access to function. Enabling network permissions exposes your environment to security risks. These include prompt injection attacks, extraction of code and secrets, introduction of malware or security flaws, and use of content that may violate licensing terms. Consider these risks carefully before enabling network permissions.

## Configuration

MCP servers are configured in your MCP configuration file. The configuration is loaded when the sandbox starts and remains available throughout task execution.

### Example configuration

```json
{
  "mcpServers": {
    "aws-knowledge-mcp-server": {
      "command": "uvx",
      "args": [
        "fastmcp",
        "run",
        "https://knowledge-mcp.global.api.aws"
      ],
      "env": {}
    }
  }
}

```

## Supported servers

Only local MCP servers are currently supported. Remote MCP servers are not available at this time.

## Using environment variables and secrets

You can reference [environment variables and secrets](/docs/autonomous-agent/sandbox/environment-variables) in your MCP configuration to securely pass credentials and configuration values to MCP servers.

Use the `${key_name}` syntax to reference the key names of your environment variables and secrets in the server configuration:

```json
{
  "mcpServers": {
    "server-name": {
      "command": "executable",
      "args": ["arg1", "arg2"],
      "env": {
        "ENV_VAR_KEY": "${my_env_var_key}",
        "SECRET_KEY": "${my_secret_key}"
      }
    }
  }
}

```

Both environment variables and secrets use the same syntax. The values are resolved when the sandbox starts.

### Agent Sandbox - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Agent Sandbox

---

The agent sandbox provides a secure, isolated environment where Kiro autonomous agent executes tasks. Each task runs in its own sandbox with configurable access controls, ensuring your code and resources remain protected.

## How it works

When you assign a task, Kiro autonomous agent:

1. Spins up an isolated sandbox environment
2. Clones authorized repositories into the sandbox
3. Configures the environment based on your Dockerfile or detected project settings
4. Executes the task with access only to explicitly permitted resources
5. Tears down the sandbox when the task completes

## Configuration

Configure sandbox access and behavior for your tasks.

### Setup - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Setup

---

Get started with Kiro autonomous agent (Preview) by connecting your GitHub account and configuring access to your repositories.

1. Go to the web app
Navigate to app.kiro.dev/agent to access Kiro autonomous agent.
2. Log in with your Kiro account
Sign in using your existing Kiro account.
3. Link your GitHub account
Connect your GitHub account to give the agent access to your repositories:

You must have write permissions on repositories for the agent to create branches and open pull requests.
  - Click "Connect GitHub" in Settings
  - Authorize the Kiro Agent GitHub app
  - Select which repositories the agent can access

**How repository access works:** Kiro autonomous agent shows all repositories where both conditions are met:

1. Your GitHub user has access to the repository
2. The Kiro Agent GitHub app has been installed and authorized for that repository

This means you'll see repositories from personal accounts, shared repositories, and organizations—as long as both your GitHub user and the Kiro Agent app have access.

See the [GitHub integration guide](/docs/autonomous-agent/github) for detailed setup instructions.

## Next steps

Once you've connected your GitHub account, you're ready to [create your first task](/docs/autonomous-agent/using-the-agent#your-first-task).

### Using the agent - Autonomous Agent - Docs - Kiro

<!-- toolType: autonomous-agent -->

# Using the agent

---

Once you connect your Kiro autonomous agent (Preview) to [GitHub](/docs/autonomous-agent/github), you can create tasks and work with the agent in several ways.

## Your first task

Now that you've [set up Kiro autonomous agent (Preview)](/docs/autonomous-agent/setup), let's create your first task.

1. Go to app.kiro.dev/agent
2. Optionally select repositories before starting your task
3. Write a clear description of what you want the agent to do

For your first task, try something straightforward like:

- "Add error handling to the login function in auth.ts"
- "Write unit tests for the UserService class"
- "Update the README with installation instructions"

Or try something that spans multiple repositories:

- "Add a new API endpoint in the backend service and update the frontend client to call it"
- "Update the shared authentication library and migrate both the web and mobile apps to use the new version"

Include any specific requirements or constraints in your description. You can always refine or add more details as the conversation progresses.

Only select repositories you trust, especially when mixing public and private repos, as the agent will learn from and follow instructions in the repository code even if these are malicious.

If you didn't select repositories when starting the chat, you'll be prompted to choose them when you ask Kiro to work on something.

## Chat and tasks

You can chat with the agent at any time to ask questions, discuss approaches, or provide context. When you're ready, ask the agent to create a task.

Once a task is created in a chat, you cannot create a second task in that same chat. Any additional comments or steering will update the scope of the current task. Use this to:

- Steer the agent on the implementation approach
- Provide additional requirements or constraints
- Ask the agent to do more work after reviewing initial results

To work on a different task, start a new chat.

## How it works

When the agent is assigned a task, it follows a structured process:

1. Environment setup - Spins up a new sandbox, loads any MCP servers, and looks for Dockerfiles in the repository
2. Repository analysis - Clones the repositories and analyzes the codebase
3. Planning - Proposes a plan and generates requirements and acceptance criteria to work against
4. Execution - Assigns sub-agents to each step of the plan, verifying changes before moving forward
5. Clarification - Asks questions if uncertain about any aspect of the work
6. Completion - Opens pull requests and listens for feedback from you or CI/scanners

## Data retention

Chats and tasks expire after 90 days, at which point the task logs and chat messages are deleted and no longer available. Any pull requests, code changes, or conversations on GitHub issues or pull requests are not deleted.

## Limits

You can execute up to 10 concurrent tasks. Additional tasks will be queued and start automatically when a slot becomes available.

Usage is subject to weekly limits during the preview. Limits reset each week, and there is no additional cost to use Kiro autonomous agent during the preview period.

## Web search

Kiro autonomous agent can search the web to access current information in real-time. This enables the agent to get up-to-date answers about topics that may have changed since the model's training data was created.

Web search capabilities have been designed to not reproduce meaningful chunks of text and should not be able to access webpages behind paywalls, authentication, and similar access restrictions. Search results may vary over time as internet content changes. Some content may not be accessible through web search due to various restrictions or the nature of the content.

Citations are provided for output that incorporates web search or grounded information. You can follow a provided citation to the source page.

## Learn more

## Subagents

<!-- toolType: subagent -->

## Context Providers

<!-- toolType: context-provider -->

## General Reference

### Overview - Agent Skills

- Why Agent Skills?
- What can Agent Skills enable?
- Adoption
- Open development
- Get started

## ​Why Agent Skills?

## ​What can Agent Skills enable?

- Domain expertise: Package specialized knowledge into reusable instructions, from legal review processes to data analysis pipelines.
- New capabilities: Give agents new capabilities (e.g. creating presentations, building MCP servers, analyzing datasets).
- Repeatable workflows: Turn multi-step tasks into consistent and auditable workflows.
- Interoperability: Reuse the same skill across different skills-compatible agent products.

## ​Adoption

## ​Open development

## ​Get started

### Integrate skills into your agent - Agent Skills

- Integration approaches
- Overview
- Skill discovery
- Loading metadata
- Parsing frontmatter
- Injecting into context
- Security considerations
- Reference implementation

## ​Integration approaches

## ​Overview

1. Discover skills in configured directories
2. Load metadata (name and description) at startup
3. Match user tasks to relevant skills
4. Activate skills by loading full instructions
5. Execute scripts and access resources as needed

## ​Skill discovery

## ​Loading metadata

### ​Parsing frontmatter

```
function parseMetadata(skillPath):
    content = readFile(skillPath + "/SKILL.md")
    frontmatter = extractYAMLFrontmatter(content)

    return {
        name: frontmatter.name,
        description: frontmatter.description,
        path: skillPath
    }

```

### ​Injecting into context

```
<available_skills>
  <skill>
    <name>pdf-processing</name>
    <description>Extracts text and tables from PDF files, fills forms, merges documents.</description>
    <location>/path/to/skills/pdf-processing/SKILL.md</location>
  </skill>
  <skill>
    <name>data-analysis</name>
    <description>Analyzes datasets, generates charts, and creates summary reports.</description>
    <location>/path/to/skills/data-analysis/SKILL.md</location>
  </skill>
</available_skills>

```

## ​Security considerations

- Sandboxing: Run scripts in isolated environments
- Allowlisting: Only execute scripts from trusted skills
- Confirmation: Ask users before running potentially dangerous operations
- Logging: Record all script executions for auditing

## ​Reference implementation

```
skills-ref validate <path>

```

```
skills-ref to-prompt <path>...

```

### Specification - Agent Skills

- Directory structure
- SKILL.md format
- Frontmatter (required)
- name field
- description field
- license field
- compatibility field
- metadata field
- allowed-tools field
- Body content
- Optional directories
- scripts/
- references/
- assets/
- Progressive disclosure
- File references
- Validation

## ​Directory structure

```
skill-name/
└── SKILL.md          # Required

```

## ​SKILL.md format

### ​Frontmatter (required)

```
---
name: skill-name
description: A description of what this skill does and when to use it.
---

```

```
---
name: pdf-processing
description: Extract text and tables from PDF files, fill forms, merge documents.
license: Apache-2.0
metadata:
  author: example-org
  version: "1.0"
---

```

| Field | Required | Constraints |
| --- | --- | --- |
| name | Yes | Max 64 characters. Lowercase letters, numbers, and hyphens only. Must not start or end with a hyphen. |
| description | Yes | Max 1024 characters. Non-empty. Describes what the skill does and when to use it. |
| license | No | License name or reference to a bundled license file. |
| compatibility | No | Max 500 characters. Indicates environment requirements (intended product, system packages, network access, etc.). |
| metadata | No | Arbitrary key-value mapping for additional metadata. |
| allowed-tools | No | Space-delimited list of pre-approved tools the skill may use. (Experimental) |

#### ​name field

- Must be 1-64 characters
- May only contain unicode lowercase alphanumeric characters and hyphens (a-z and -)
- Must not start or end with -
- Must not contain consecutive hyphens (--)
- Must match the parent directory name

```
name: pdf-processing

```

```
name: data-analysis

```

```
name: code-review

```

```
name: PDF-Processing  # uppercase not allowed

```

```
name: -pdf  # cannot start with hyphen

```

```
name: pdf--processing  # consecutive hyphens not allowed

```

#### ​description field

- Must be 1-1024 characters
- Should describe both what the skill does and when to use it
- Should include specific keywords that help agents identify relevant tasks

```
description: Extracts text and tables from PDF files, fills PDF forms, and merges multiple PDFs. Use when working with PDF documents or when the user mentions PDFs, forms, or document extraction.

```

```
description: Helps with PDFs.

```

#### ​license field

- Specifies the license applied to the skill
- We recommend keeping it short (either the name of a license or the name of a bundled license file)

```
license: Proprietary. LICENSE.txt has complete terms

```

#### ​compatibility field

- Must be 1-500 characters if provided
- Should only be included if your skill has specific environment requirements
- Can indicate intended product, required system packages, network access needs, etc.

```
compatibility: Designed for Claude Code (or similar products)

```

```
compatibility: Requires git, docker, jq, and access to the internet

```

#### ​metadata field

- A map from string keys to string values
- Clients can use this to store additional properties not defined by the Agent Skills spec
- We recommend making your key names reasonably unique to avoid accidental conflicts

```
metadata:
  author: example-org
  version: "1.0"

```

#### ​allowed-tools field

- A space-delimited list of tools that are pre-approved to run
- Experimental. Support for this field may vary between agent implementations

```
allowed-tools: Bash(git:*) Bash(jq:*) Read

```

### ​Body content

- Step-by-step instructions
- Examples of inputs and outputs
- Common edge cases

## ​Optional directories

### ​scripts/

- Be self-contained or clearly document dependencies
- Include helpful error messages
- Handle edge cases gracefully

### ​references/

- REFERENCE.md - Detailed technical reference
- FORMS.md - Form templates or structured data formats
- Domain-specific files (finance.md, legal.md, etc.)

### ​assets/

- Templates (document templates, configuration templates)
- Images (diagrams, examples)
- Data files (lookup tables, schemas)

## ​Progressive disclosure

1. Metadata (~100 tokens): The name and description fields are loaded at startup for all skills
2. Instructions (< 5000 tokens recommended): The full SKILL.md body is loaded when the skill is activated
3. Resources (as needed): Files (e.g. those in scripts/, references/, or assets/) are loaded only when required

## ​File references

```
See [the reference guide](references/REFERENCE.md) for details.

Run the extraction script:
scripts/extract.py

```

## ​Validation

```
skills-ref validate ./my-skill

```

### What are skills? - Agent Skills

- How skills work
- The SKILL.md file
- Next steps

```
my-skill/
├── SKILL.md          # Required: instructions + metadata
├── scripts/          # Optional: executable code
├── references/       # Optional: documentation
└── assets/           # Optional: templates, resources

```

## ​How skills work

1. Discovery: At startup, agents load only the name and description of each available skill, just enough to know when it might be relevant.
2. Activation: When a task matches a skill’s description, the agent reads the full SKILL.md instructions into context.
3. Execution: The agent follows the instructions, optionally loading referenced files or executing bundled code as needed.

## ​The SKILL.md file

```
---
name: pdf-processing
description: Extract text and tables from PDF files, fill forms, merge documents.
---

# PDF Processing

## When to use this skill
Use this skill when the user needs to work with PDF files...

## How to extract text
1. Use pdfplumber for text extraction...

## How to fill forms
...

```

- name: A short identifier
- description: When to use this skill

- Self-documenting: A skill author or user can read a SKILL.md and understand what it does, making skills easy to audit and improve.
- Extensible: Skills can range in complexity from just text instructions to executable code, assets, and templates.
- Portable: Skills are just files, so they’re easy to edit, version, and share.

## ​Next steps

- View the specification to understand the full format.
- Add skills support to your agent to build a compatible client.
- See example skills on GitHub.
- Read authoring best practices for writing effective skills.
- Use the reference library to validate skills and generate prompt XML.

### Automate your development workflow with Kiro’s AI agent hooks

As your software projects grow, keeping documentation, testing, code readability, and performance in sync becomes increasingly challenging. Kiro’s agent hooks work alongside you to handle these critical tasks automatically in the background, helping you maintain your flow while coding and ship high-quality code every time.

[Kiro](https://kiro.dev/), an agentic IDE, introduces agent hooks as a new way to simplify complex workflows. These custom, AI-powered triggers respond to your coding activities in real-time, handling tasks like updating tests, synchronizing documentation, and applying coding standards across your codebase.

Kiro agent hooks mark a fundamental shift from reactive AI assistance to proactive AI integration, where your development environment becomes an intelligent partner that anticipates your needs and acts automatically.

In this post, I'll show you how to set up and use Kiro agent hooks and walk you through practical examples that demonstrate how these hooks can transform your development workflow.

## What Are Kiro’s Agent Hooks?

Kiro’s [agent hooks](https://kiro.dev/docs/agents/) are intelligent automation rules that connect your workspace events to AI-powered actions. Think of them as "if-then" logic for your development environment but powered by natural language AI that understands your code and context. At their core, Kiro hooks bridge your workspace activities with the powerful agentic capabilities built in Kiro.

A hook consists of two main components:

- A trigger: Then event that activates the hook (like saving, editing, creating, or, deleting a file)
- An action: AI-powered response that automatically executes (like code generation, file updates, documentation)

## Key Benefits

When a task requires your close guidance and expertise, Kiro keeps you in control via multimodal agent chat. Kiro’s agents challenge you to think beyond the code and work alongside you to solve hard engineering problems confidently. Kiro’s agent hooks offer a number of advantages over traditional development automation:

- Natural Language Configuration: You can define hooks using plain English instead of complex scripting.
- Context-Aware AI: Kiro’s hooks understand your codebase structure and can make intelligent decisions faster.
- Real-Time Execution: Actions happen immediately as you work, helping you to maintain your development flow.
- Collaborative: Kiro’s agent hooks can be shared with your team through version control.
- Customizable: You can tailor automation to your specific workflow and coding patterns.

## Setting Up Your First Agent Hook

**Quick Start Steps**

Let’s create a hook that keeps your Typescript project’s unit tests up to date with your code.

1. Open the Hooks Panel: Click on the Kiro icon in the Activity Bar, then select "Agent Hooks" from the sidebar navigation
2. Create Your First Hook: Click the "+" button in the hooks panel and either:
  - Type a natural language description of your desired hook; or
  - Select from available templates

3. **Configure Options**: Review and adjust the title, description, event type, file patterns, and instruction prompt.

4. **Create hook:** When you create the hook it will appear in your IDE agent hooks panel and a new corresponding configuration file will be created in your `.kiro/hooks` directory, you can open the `***.kiro.hook` file to inspect the configuration:

## Hook Configuration Options

**General Options:**

- name: name of the hook
- description: the description of the hook

**Trigger Options:**

- when:
  - Type:
    - fileEdit: Monitor file modifications.
    - fileCreate: Respond to new file creation.
    - fileDelete: Handle file deletion events.
    - userTriggered: Manual trigger.
  - Patterns: File matching pattern supports GLOB Pattern for files and directory structures

**Action Options:**

- then:
  - type:
    - askAgent: Send a custom prompt to the AI agent with full context
  - prompt: The description of the action you want Kiro to take when the hook is triggered

**Managing Your Hooks**

All your available hooks will appear in the Kiro hooks panel where you can:

- Enable/disable hooks on demand
- Edit hook configurations
- Delete hooks

You can also modify the hook configuration file under `.kiro/hooks` directory.

## Kiro Agent Hooks in Action

**Practical Examples to Try**

Below are some examples of common use cases that you can automate with Kiro’s agent hooks:

- Test Synchronization: Keep unit tests updated with source code changes.
- Documentation Updates: Automatically update README files when adding new features.
- Internationalization Helper: Translate your documentation to and from English.
- Git Assistant: Generate changelog based on Git diff and Git commit message helper.
- Compliance check: Check the compliance against your standard.
- Style Consistency: Apply formatting and coding standards automatically.

### Example 1: Automatic Test Generation

**Scenario**: You're working on a Python application, and you want your tests to stay synchronized with your components.

**Hook description:**

**File path(s) to watch for change:**

**What Happens**: Every time you modify a Python file, Kiro will automatically review your changes and update the test file to maintain comprehensive coverage of the new functionality.

### Example 2: Documentation Synchronization

**Scenario**: You want your API documentation to stay current with code changes.

**Hook description**:

**File path(s) to watch for change:**

**Result**: Your API documentation will automatically reflect the code changes, eliminating the common problem of having outdated documentation.

## Best Practices for Kiro Agent Hooks

Here are some tips, tricks, and best practices when getting started with Kiro’s agent hooks.

### Start Simple

Begin with basic file-to-file relationships like updating tests when you change the source code. You’ll see the value right away and can build up to more complex workflows as you get comfortable.

### Use Descriptive Prompts

The more context you provide in your hook prompts, the better the AI will understand your intentions:

### Leverage Workspace Context

You can reference your project's documentation, coding standards, and patterns in hook prompts to maintain consistency.

### Monitor and Iterate

Use your chat history to review hook performance and refine prompts based on results.

### Team Collaboration

Share your hooks with the team by committing them to version control - it's as simple as that. Every new hook you create lives in the .kiro/hooks directory, ready to be shared. Once you push the changes, your teammates can pull and start using your hooks instantly. It's like having a shared cookbook of automation recipes that grows with your team.

## The Future of Automation is Hooks

Kiro's agent hooks bring intelligent automation to your daily development work, handling repetitive tasks so you can focus on creative problem-solving. Think of it as a smart assistant that learns your coding patterns, from formatting preferences to deployment procedures, and helps you maintain consistency throughout your projects. Kiro’s natural language configuration makes advanced automation accessible to developers of all experience levels; simply describe what you need, while the AI-powered actions guide automated changes to be intelligent and contextually appropriate.

Whether you're coding solo or working with a team across time zones, Kiro's agent hooks fit naturally into your workflow. Teams can share and version their automation recipes just like code, creating a growing library of time-saving tools tailored to their projects. Start with basic tasks like standardizing code formatting or automating test runs, then expand to more complex workflows as your comfort grows. You'll quickly recover the time investment in setting up these hooks in dividends through smoother, more efficient development cycles.

Ready to give it a try? Kiro is free to start, and our documentation has everything you need to create your first hook. We're here to help you write better code, more efficiently.

Let’s connect - tag @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev), and share what you’ve built using hashtag #builtwithkiro

### Blog

### Announcing the Code with Kiro Hackathon

****[Join our waitlist](/downloads/)** and we'll notify you as soon as access to Kiro is available. Please note we will be adjusting the submission period accordingly. Registrants will be emailed once the new dates are finalized. Thank you!**

---

Gear up for the [Code with Kiro Hackathon](https://kiro.devpost.com/?trk=b85f313f-a67c-452d-b088-07f0ddbd7e15&sc_channel=el). Kiro transforms your development workflow with seamless AI integration in a development environment that understands how you code. Come explore Kiro’s AI IDE and see what spec-driven development is all about, with $100,000 in prizes up for grabs. Your only limitation is how far your creativity can take you as Kiro scales your ideas through AI features like context-aware inline coding, multimodal chat, spec-driven development, and intelligent agent hooks capable of automating all kinds of tasks. Learn more about [Kiro’s unique AI features](/).

## Build (almost) whatever you want

To maximize your creative freedom, the main requirement of your project is simply to use Kiro to build a working app. We've got four categories to help get your creative juices flowing, but don't let these box you in:

- Productivity & Workflow Tools: Build the CLI of your dreams, the task tracker application that checks all your feature boxes, or design a scrum board that streamlines your team's process.
- Games & Entertainment: From rogue-likes to real-time multiplayer games, if it's fun, we want to see it.
- Educational Apps: Interactive coding tutorials, algorithm visualizers, or anything that makes learning enjoyable and engaging.
- Wildcard: Do you have a unique idea that doesn't fit anywhere else? This is your space. Surprise us.

## All skill levels welcome

If you can dream it, Kiro can help you realize it. We encourage developers of any skill level to join, whether as a solo developer or as a team (up to 3 members allowed) - this is your call for action. Still not sure if this is the right hackathon for you?

It takes all types of skill sets to build a successful application:

- Developers
- Startup founders or entrepreneurs
- Designers
- Students (high school to postgraduate)
- Basically, any builder

The beauty of AI-driven software engineering in the modern age is the accessibility across different levels of technical skills. Kiro works with you to bring out your strongest skills and enable you to take your projects from ideation to production code. But don’t take our word for it - try it for yourself, and maybe win some cash while you’re at it!

## Need we say more? ...okay

It’s no secret that AI is shaping the world around us like never before. Many tools are touting faster coding with AI, but it’s time for more than that. Kiro is an agentic IDE that’s built to be your development partner, elevating your work beyond just writing code faster. Get in on the cutting edge of [AI development with Kiro](/blog/introducing-kiro/) and grow your skills while bringing powerful solutions to the world.

Need more reasons to enter? Join the community and make new connections with fellow developers and industry experts who are shaping the future of development with AI. We'll have weekly office hours and Discord at the ready to support you, in addition to our tech docs and tutorials at [kiro.dev/docs](/docs/). Our panel of judges feature some of the community's best and brightest, including experts like [Tim Ruscica](https://www.linkedin.com/in/tim-ruscica/), [Aishwarya Srinivasan](https://www.linkedin.com/in/aishwarya-srinivasan/), [Angie Jones](https://www.linkedin.com/in/angiejones/), [Santiago Valdarrama](https://www.linkedin.com/in/svpino), and [Jeff Barr](https://www.linkedin.com/in/jeffbarr/). Judges will evaluate projects based on their potential value, implementation leveraging Kiro, and quality of idea, with diverse prize categories like Influencer Judge’s Choice, Most Innovative Use of Kiro, and Best-In-[Track].

## Key dates and submission details

The hackathon kicks off on July 14, 2025, with submissions due by August 25, 2025, at 12:00pm PT. Winners will be announced on October 1, 2025 across Kiro social channels on [X](https://x.com/kirodotdev), [Bluesky](https://bsky.app/profile/kiro.dev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), and [Instagram](https://www.instagram.com/kirodotdev). Your submission should include a demonstration video (maximum 3 minutes) that explains to the judges why it is a valuable solution and how Kiro was used to build it, a public GitHub repository with open-source code, and detailed project documentation. For the full rules and submission details, please visit [kiro.devpost.com](https://kiro.devpost.com/?trk=b85f313f-a67c-452d-b088-07f0ddbd7e15&sc_channel=el).

Kiro is currently free during its preview period and supports multiple operating systems and programming languages, making it accessible for developers to build real applications rather than just proofs-of-concept. To get started,

1. Register for the Code with Kiro hackathon
2. Join the waitlist, then, when invited, set up your Kiro account
3. Learn about the capabilities you can use to build your project
4. Fire up your creativity and get building!

## Ready to go from idea to production ?

Join us in this exciting journey to explore the possibilities of AI-assisted development. This is your chance to be at the forefront of the AI-powered development revolution, shaping the future of software creation. Register now at [kiro.devpost.com](https://kiro.devpost.com/?trk=b85f313f-a67c-452d-b088-07f0ddbd7e15&sc_channel=el) and start building something amazing. We can’t wait to see what you come up with!

Have more questions? [Read the official hackathon rules](https://kiro.devpost.com/rules). Check out our [tutorials](/docs/guides/). Bookmark the [Kiro Discord community](https://discord.gg/kirodotdev).

Let’s connect - tag @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev), and share updates on your progress using hashtag #codewithkiro

—

NO PURCHASE NECESSARY. 18+. Eligibility restrictions apply. See [terms and conditions](https://kiro.devpost.com/rules).

### Kiro 0.9: Custom subagents in the IDE, new enterprise controls, and granular code review

This release brings new features in the IDE to give developers more control without slowing them down, while also giving enterprise teams the governance they need. We're shipping custom subagents, skills support, and smarter refactoring tools. Let's dive in.

## Custom subagents: build your own specialists

Subagents have been around for a few releases now, but they were general-purpose. Many of you have asked to be able to customize behavior to many different use cases.

Here's just one scenario that kept coming up: a team has a React frontend and a Python backend. One agent context handles both, which means loading tools for everything—Chrome DevTools, database MCP servers, component libraries, API docs. The context window fills up fast and performance begins to suffer.

Custom subagents let you split that up. Create a `frontend-agent` that knows about components and browser tooling. Create a `backend-agent` that loads your database server and API documentation. Each subagent stays focused and manages its own context.

## Enterprise teams get more controls and flexibility

Organization admins can now better manage access to plugins and tools.

**Extension Registry Governance** — Point Kiro IDE at your own VS Code extension registry. Security teams can curate what's available, and developers still get the extensions they need, just from a pre-approved list.

**Web Tools Toggle** - You can now enable or disable web tools (web search & web fetch) based on your workflow or security needs.

Organization admins have also asked us for user-level usage metrics across tools. We are actively working on this and will release a first version of this capability in the coming weeks.

## Agent skills: modular instructions that load when you need them

We're introducing support for Agent Skills, based on the open [agentskills.io](http://agentskills.io/) standard. Skills are modular instruction packages that teach the agent new capabilities. A good way to think of Skills is as expertise you can drop into your workflow.

Why do we need Skills when we have Steering and Powers? Steering files work great for always-on guidance, but sometimes you want specialized knowledge that only loads when relevant. A Terraform skill shouldn't consume context when you're writing React components. A security review skill shouldn't be active during routine refactoring. While powers solve this problem, they are a superset of skills and also include MCP servers and rules, which you may not need. Skills use progressive disclosure. At startup, Kiro only loads the name and description for each skill. When the agent determines a skill is relevant (or you explicitly request it), the full instructions load into context. This keeps your context window lean until you actually need the expertise.

You can install skills at the user level (`~/.kiro/skills/`) for capabilities you want everywhere, or at the workspace level for project-specific knowledge. Workspace skills take precedence when names collide, so teams can override global defaults. Each skill lives in its own directory with a `SKILL.md` file and can include scripts and resources the agent can reference.

The distinction from steering and powers is intentional. Steering files direct agent behavior—coding standards, project conventions, things that should always apply. Skills are capabilities the agent learns on demand. Both show up in the same UI, but they serve different purposes and load differently.

For teams already using skills with other AI coding tools, the format is compatible. Just drop your existing skills into the `.kiro/skills/` directory and they work.

## Smart agent refactoring

Refactoring isn't just find-and-replace at scale—it's a graph traversal problem across workspaces. When you rename a symbol or move a file, the changes cascade across various call sites, import statements, and so on. As a result, agents often stumble when refactoring by missing some of these references references or taking too many turns to update them.

To fix this, we created two new refactoring tools that expose IDE refactoring capabilities—powered by language servers—directly to agents. With these tools, when an agent needs to rename a symbol or move a file, it picks the right refactoring tool and invokes it, so cascading updates are applied automatically and reliably.

Early use shows that agents complete refactoring operations faster end-to-end, while producing fewer build, compile, and runtime errors as a result. Read more about [this new feature in our engineering deep dive blog post](/blog/refactoring-made-right/).

## 0.9 in a nutshell

Individual developers can now easily make workflow customizations through subagents. Organizations get more precise governance controls. Everyone gets a better handle over how the agent behaves and what changes make it in their code. Each feature gives you control where it matters. [Update your IDE to 0.9](/downloads/) to get started.

### Empowering Kiro with IDE diagnostics

## Why agents miss the errors your IDE already knows about

Early coding agents had this problem: AI generates code that looks correct, but IDE errors aren't immediately visible to the agent. This was because agents lacked visibility into these errors without executing additional tools. Consequently, the agent would move on confidently while the codebase accumulated technical debt. *This represents a gap in how* any coding agent that doesn't incorporate diagnostics information operates.

While most modern IDEs continuously run sophisticated language analysis tools that catch errors in real-time, agents need an efficient way to access this wealth of information. Otherwise, they have to resort to running (expensive) build/test commands to validate code, which is slower, consumes tokens, and misses the nuanced feedback your development environment already provides. The result? Code validation that's more resource-intensive than it needs to be.

## The cost of blind code generation

When agents aren’t able to see IDE diagnostics, they cannot iterate towards quality. Instead, they generate code they presume is correct before advancing to the next task. You're left performing QA for the agent—manually fixing type errors (e.g. calling `user.getName()` when the property is actually `user.name`), adding missing imports (the agent uses `Button` but forgot `import { Button } from '@/components/ui/button'`), and resolving linting violations (unused variables, inconsistent indentation). This doesn't just slow developers down, it trains you to distrust agent-generated code entirely.

## Closing the feedback loop in Kiro

Modern IDEs are powered by sophisticated language analysis infrastructure. Language servers perform real-time analysis of your codebase. For example, a TypeScript extension performs type checking, ESLint validates code style, Java extensions provide instant compilation feedback, CloudFormation and Terraform extensions validate infrastructure configurations such as resource properties, required arguments, and resource references before deployment.

This analysis happens continuously as you code to surface errors as *diagnostics*—the red squiggles and problem markers you see in your editor. These diagnostics represent a rich source of immediate, accurate feedback about code correctness.

Yet, early AI coding assistants couldn’t access this information. Instead, they validated code by executing build commands (`npm run build`, `npm test`, etc.) although it could take several seconds or even minutes per invocation.

In Kiro, an agentic IDE that brings structure to AI coding through spec-driven development, we've addressed this by giving the agent direct access to IDE diagnostics. Now, when Kiro writes code, it immediately sees the same errors you would see, and can fix them as they occur; before you ever review the changes. The impact on code quality has been significant: fewer manual corrections and better adherence to project quality standards. Kiro’s coding agents integrate tightly with these client-side diagnostics to enhance both code understanding and generation. Through their connection to the same language servers that power the IDE, agents can now read and interpret compile-time errors, type warnings, and linting results in real time. When Kiro generates or modifies code, it queries this diagnostics information to validate correctness—for example, detecting a missing symbol in Java or a syntax error in Python — and can automatically refine its output based on that feedback.

## Workflow comparison

The conventional approach follows a slow, iterative cycle. The agent generates code and then executes a build (and/or test) command which can be time consuming. When the build fails with an error, the agent generates a fix and executes the build command again. This heavy process repeats until the build succeeds.

The diagnostic-driven approach is much faster. After generating code, the agent checks diagnostics in under 35ms. It is provided with specific errors with line numbers and descriptions. The agent then generates a targeted fix and verifies it via diagnostics in another 35ms before proceeding with validated code.

The time difference compounds over multi-step tasks. In spec-driven development, where Kiro implements dozens of tasks, the diagnostic tool is invoked roughly 4x more frequently than in vibe-coding mode because each discrete task boundary requires confirming that acceptance criteria are met. This provides continuous validation throughout the implementation process.

## Real-world impact

We have measured the impact of diagnostic integration across production usage and controlled benchmarks. The results demonstrate significant efficiency gains alongside measurable code quality improvements. On the efficiency side, we observed a 29% reduction in command executions because of cutting back on build/test commands. This metric was derived by comparing agent interaction statistics across several days of production usage before and after introducing the diagnostics feature. Code quality improved while simultaneously reducing end-to-end latency.

## Language-agnostic architecture

The diagnostic system's power comes from its generality. Rather than building custom analysis for each language, Kiro leverages the Language Server Protocol (LSP) and extension APIs that already power a myriad of IDE functionalities. Production data confirms this works across diverse tech stacks. For instance, [popular extensions](https://open-vsx.org/) for general-purpose languages such as TypeScript, Python, and Rust as well as domain-specific languages such as SQL, YAML, and GraphQL which provide type checking and linting information. Additionally, there are extensions for major build tools (such as Maven, Make, Cargo, etc.) and programmatic configuration files (Terraform, Kubernetes YAML, Dockerfile, etc.) to improve the setup and debugging experience.

## Usage scenarios

Analysis of production usage reveals common patterns in how the diagnostic tool improves the quality of the existing or newly generated code:

**Scenario 1 [Syntax Errors]:** In a Python codebase for analytics, the agent implements a new feature for windowed aggregations.

The diagnostics tool finds a regular-expression error (`missing ), unterminated subpattern at position 13`) which is then fixed by the agent. The re-validation confirms that the error is no longer present. In absence of the diagnostics tool, the agent would rely on composing and executing tests via command-line to check for issues.

**Scenario 2 [Avoiding Hallucinations]:** In a TypeScript codebase, Kiro makes changes to a component and immediately validates it:

The diagnostics tool immediately reports two **type mismatches** (`Type 'number' is not assignable to type 'string'` and `Cannot assign to read-only 'executionTime'`) and a **property hallucination** (`Property 'itemAge' does not exist on type 'StackProps'`). Guided by these issues, the agent generates corrections and re-validates the changes. This pattern (generate → validate → refine) occurs frequently in statically-typed languages where type errors are common but easily caught by language servers.

**Scenario 3 [Type Validations]:** In a Swift project, Kiro adds a new functionality and checks the diagnostics for the edited files:

The diagnostics reveal that there is a **type error** in one of the files. The agent then fixes the issue and re-validates the affected file to ensure the fix is correct.

**Scenario 4 [Infrastructure as Code — aka IaC]:** Diagnostic validation extends beyond application code. A user prompts Kiro to check their **Terraform configurations**:

This demonstrates how the diagnostic system works with domain-specific languages and configuration formats, not just conventional programming languages.

## Benefits for agentic development

By bringing code generation and code validation closer together, the diagnostics tool enables the following improvements:

**Reduced Cognitive Load:** Developers spend less time manually validating AI-generated code. When Kiro reports "No diagnostics found," developers can proceed with higher confidence.

**Faster Iteration:** The reduction in the frequency of bash commands translates to tangible time savings.

**Better Code Quality:** Addressing issues as soon as they appear means cleaner, higher quality code.

## Summary

IDE diagnostics represent an important source of immediate feedback for code validation. By integrating diagnostic information directly into Kiro's agentic workflow, we've eliminated the gap between code generation and validation that plagued early coding agents.

The results speak for themselves: fewer command executions, fast validation cycles, and improved code quality across diverse tech stacks. Rather than forcing agents to rely on slow, expensive build/test commands, Kiro leverages the same sophisticated language analysis infrastructure that already powers modern IDEs; from TypeScript type checking to Terraform configuration validation.

This diagnostic-driven approach speeds up the agent’s feedback loop. Instead of generating code blindly and hoping it works, Kiro sees the same errors you would see and fixes them proactively. The outcome is code that requires less manual correction which builds greater developer confidence.

Ready to experience the difference? [Get started with Kiro](/downloads/) for free and see how diagnostic-powered agents can transform your development workflow. Join our growing community on [Discord](https://discord.com/invite/kirodotdev) to share feedback, ask questions, and connect with other developers building with AI-assisted coding.

---

**Acknowledgements**

Credits (listed in alphabetical order) Al Harris, Nathan Jones, Nikhil Swaminathan, Siwei Cui, and Varun Kumar

### Use Kiro for free until September 15

Following our [pricing update on August 22nd](/blog/important-pricing-updates/), we are extending the free Kiro usage beyond September 1st, until September 15th.

This means you can continue to use Kiro for free until September 15th. We’ll refund the full amount for your September charge, so you can continue using Kiro for free. Your usage limits will reset on September 1st to the full limits of your plan as part of your regular subscription cycle.

Additionally, regardless of the paid pricing plan you are on, you will be able to turn on overages and benefit from 1,000 additional vibe and 200 spec requests free of cost through September 15th. Please see the FAQs below for more details.

Also, all refunds have been processed. We have also reset limits earlier this week as we are deploying improvements to the system. We hope this gives you more room to do meaningful work.

We have been listening to your feedback, and it has been very valuable to inform how we evolve the Kiro pricing model. Based on your input, we will be announcing updated pricing in the coming weeks and intend to roll out new pricing after September 15th. Before we roll out the new pricing changes, we will notify you of the upcoming changes so you can plan accordingly.

We’re making these changes to give everyone more time with the current experience while we incorporate your feedback in the pricing model. Thanks again for all your support — and please keep the feedback coming by joining [our Discord](https://discord.gg/kirodotdev).

## FAQs

##### When and how will customers be refunded?

If you have an active subscription with Kiro, your credit card will be charged on September 1st for September usage. We will refund the amount by September 15th.

##### Are you refunding overages too?

If you have already incurred overages in August, we will refund those. [Overages](https://kiro.dev/docs/billing/overages/) are temporarily capped to 1,000 vibe requests and 200 spec requests during September. If your credit card gets charged for overages, we will refund it at the end of September.

##### How and when will the usage be reset for customers?

Your monthly plan limits will reset on September 1st.

##### If I purchase a subscription today is it free until September 15th?

If you purchase a subscription anytime before September 14th, you can use it for free until September 14th. Your credit card will be charged, and we will refund those charges by September 15th. You can use the plan you purchased to the full monthly limits until September 15th.

##### Can I use Kiro for free in September?

If you’re already on a paid plan, your monthly limits are resetting on September 1st, and you can continue to use Kiro for free until September 15th to the full monthly limits.

If you are purchasing a paid plan between now and September 14th, you will need to provide a valid credit card, which will be charged the price of the plan you purchased, plus applicable taxes and fees. We will then refund you by September 15th, within a few days of your purchase. You can use Kiro within the full monthly plan limits you upgraded to for free. Unused requests will not roll over to the following months, or to the updated plans. We are working on tweaking our existing pricing plans to better meet your needs, and once we are ready to roll out the updates in the coming weeks, you will be migrated to the new plans, unless you cancel your subscription. We will communicate more details later in September.

##### Can I enable overages for free during September?

Yes, you can turn on overages. [Overages](/docs/billing/overages/) are temporarily capped to 1,000 vibe requests and 200 spec requests until September 15th. If your credit card gets charged for overages you incur until September 15th, we will refund it at the end of September.

##### What pricing updates can I expect in the coming weeks?

We are considering making changes to how spec and vibe requests work to ensure you get great mileage when using Kiro for common development tasks. We will communicate updates before we roll out pricing so you get a chance to decide if the changes work for you.

##### How does pro-rated billing work?

If a month has 30 days, and you sign up on day 20, you get charged for the remaining 10 days of the month, and get to use monthly limits accordingly. For example, if you subscribe to Kiro Plus on September 5th, since September has 30 days, you get charged 25/30 × $20 (Kiro Plus cost) = $16.67, and get 25/30 × 225 = 187 vibe requests and 25/30 × 125 = 104 spec requests.

##### I’m taking part in the Kiro hackathon, how do these changes affect me?

The [hackathon](https://kiro.devpost.com/) submission deadline is September 15th, and you can use Kiro for free until that date, within the same terms described in this announcement.

### From chat to specs: a deep dive into AI-assisted development with Kiro

As developers, we've all been there. You have a brilliant idea for a feature or application, you fire up your favorite AI coding assistant, and then... you spend the next hour going back and forth, refining requirements, clarifying edge cases, and watching your context window fill up with exploratory conversations before you even write a single line of code.

**Kiro, **a new IDE, fundamentally changes how we approach AI-assisted development through **Spec-Driven Development**.

## Limitations of current AI coding assistants

Limitations of current AI coding assistants tend to follow a predictable and inefficient pattern. When a developer provides a high-level prompt, the AI immediately jumps into code generation, often before fully understanding the requirements. This premature action leads to a cycle where the developer must repeatedly clarify their intentions with "actually, I meant..." statements, as the initial requirements weren't sufficiently clear. As this exploratory dialogue continues, the context window becomes increasingly cluttered with back-and-forth discussions, leaving limited space for the final code generation. This constrained context space ultimately impacts the quality and completeness of the final output, making the entire process less efficient than it could be. This approach treats the LLM as a code generator first, when it should be considered a thinking partner throughout the entire development lifecycle.

## Spec-driven development: Bridging design intent and implementation

If you're working on a challenging feature, Kiro serves as your intelligent sounding board to help you understand your codebase, define your problem clearly, and reach a quality solution efficiently. You can collaborate with Kiro on creating concise specifications that include clear requirements, system architecture, tech stack considerations, and implementation approach. Kiro helps make all requirements and constraints explicit, then uses these specifications as context to complete tasks with fewer iterations and higher accuracy. This is the power of spec-driven development. Let's dive deeper into some of the key benefits of Kiro's approach:

##### 1. Understand your existing codebase

Before starting new development, Kiro analyzes your existing code and generates three foundational documents: **structure.md** (codebase architecture), **tech.md** (technical stack and patterns), and **product.md** (business context and requirements). This gives you and your team a clear baseline understanding that informs all subsequent specification work. Existing codebases can now take advantage of this new paradigm.

##### 2. Analyze and plan your project

When you provide a project prompt in spec mode, Kiro's AI doesn't immediately start coding. Instead, it performs deep analysis to understand your requirements, identifies potential challenges, and creates comprehensive planning documents.

##### 3. Generate comprehensive planning documentation

From a simple prompt, Kiro creates detailed specification files including:

- Requirements Analysis - Breaking down your prompt into specific, actionable requirements
- Technical Design - Architecture decisions, technology choices, and implementation approach
- Task Breakdown - Granular development tasks with clear acceptance criteria

##### 4. Collaborate with AI effectively

Kiro saves specification files in your project directory as readable markdown files. You can review, edit, and refine them before any code is written. This creates natural checkpoints for collaboration with team members or stakeholders.

##### 5. Maximize coding context and efficiency

When it's finally time to write code, Kiro references these specification files rather than cluttering your context window with exploratory conversation. This means maximum context space is available for the actual coding task.

## The power of spec-driven development

Spec-driven development delivers key advantages that fundamentally improve how teams design, build, and maintain software. Rather than treating planning as overhead, it becomes your competitive advantage. Here's how this approach transforms the development process:

##### Catch problems before they're expensive

Rather than discovering requirements issues mid-development, Kiro identifies and resolves ambiguities upfront. This prevents costly rewrites and provides alignment before coding begins.

##### Stay in control of your project's direction

The specification phase creates natural pause points where humans can review, modify, and approve the direction before resources are invested in implementation.

##### Iterate without losing your progress

If you make a mistake in defining your requirements, no problem. You can modify the specification files and regenerate the implementation plan without losing your entire conversation history.

##### Keep your AI focused on what matters

By externalizing the planning phase to files, Kiro keeps the active context focused on the immediate coding task, leading to higher quality code generation.

##### Enable seamless team collaboration

Specification files serve as living documentation that team members can review, comment on, and contribute to using standard development workflows.

##### Build institutional knowledge

Every decision and requirement is documented, creating a clear audit trail of why certain technical choices were made and preserving context for future team members.

## Let’s see Kiro specs in action

The best way to understand spec-driven development is to see it in practice. Whether you're starting fresh or working with an existing codebase, Kiro's systematic approach enables you to build on a solid foundation. Here's how a typical workflow unfolds, from initial concept to implementation-ready specifications.

##### Step 1: Initiating your project

Before diving into new features, establish context for your project:

User: "Set up steering for this project"

Kiro analyzes your existing codebase and generates three foundational documents:

- structure.md - Current architecture, key components, and code organization
- tech.md - Technology stack, patterns, and technical constraints
- product.md - Business context, existing features, and user workflows

This gives you a clear baseline understanding of what you're building upon.

##### Step 2: Generating your project specs

Now start laying out the details for the project that you want to build.

User: "I want to build a task management app for small teams with real-time collaboration features"

This is where the magic of spec-driven development becomes apparent. Rather than jumping straight into framework selection or database design, Kiro takes a step back to fully understand what you're trying to accomplish. It considers your prompt in the context of the steering documents, identifying how this new feature fits within your existing architecture and constraints.

Kiro creates a series of documents in sequential order, building from requirements through to actionable tasks:

- requirements.md - Detailed feature breakdown including user stories and acceptance criteria
- design.md - Architecture and technology decisions including frameworks, architecture diagrams, and structure
- tasks.md - Development phases and tasks to be executed in a sequential order

##### Step 3: Reviewing and refining

You review the specifications, perhaps adding:

##### Step 4: Informed Development

Now when Kiro begins coding, it references these comprehensive specifications rather than trying to infer requirements from conversation history. Every implementation decision is grounded in documented requirements and design choices.

## The future of development is here—and it starts in the specs

Spec-driven development represents a shift from reactive coding to proactive specification that isn't just a workflow improvement—it's a fundamental evolution in how we partner with AI to build software. Instead of treating AI as a sophisticated autocomplete tool, spec-driven development positions it as your strategic thinking partner, helping you make better decisions before they become expensive to change. The result? Faster development cycles, higher quality code, fewer surprises, and documentation that actually stays current because it's integral to the process, not an afterthought. The next time you have a feature to build, try leading with specification instead of code. Your future self (and your teammates) will thank you for the clarity, and you might just discover that the best code is the code you plan before you write.

Ready to experience the difference? [Join the waitlist](/waitlist/).

### Kiro is generally available: Build with your team in the IDE and terminal

*Applications for startup credits have closed due to high demand. We are still reviewing applications on a rolling basis. Stay tuned for updates.*

---

Since launching Kiro in preview in July, we've seen strong adoption of Specs as a structured way to build with AI. We were the first to bring spec-driven development to AI coding tools, and the broader industry has recognized its value—planning is the right way to do work with AI agents.

Over the past months, we've added capabilities like remote MCP, global steering files, dev server support, our Auto agent, and making specs more flexible with optional tasks.

Today at general availability, we are releasing a set of brand new capabilities: 1/ property-based testing for spec correctness (which measures whether your code actually matches what you specified); 2/ new way to checkpoint your progress on Kiro; 3/ a new Kiro CLI bringing agents to your terminal and; 4/ team plans with a simple way to manage them centrally.

## Kiro IDE

The new version of Kiro IDE introduces three new capabilities.

### Measuring “spec correctness” with property-based tests

There's a fundamental problem with AI code generation: how do you know the code actually does what you specified? Traditional unit tests only check specific examples. Worse, whoever writes the tests (human or AI) is limited by their own biases—they have to think of all the different, specific scenarios to test the code against, and they'll miss edge cases they didn't think of. AI models often “game” the solution by modifying tests instead of fixing code, or go in endless loops to fix the issues.

Property-based testing (PBT) addresses this by measuring whether your code matches the behavior you defined in your Spec. Instead of testing specific examples, Kiro goes into your project’s specifications and extracts properties that represent how the system should generally behave, then tests against them.

**What is a property?** A property is a universal statement: *for any* set of inputs, *such that* certain preconditions hold, some *predicate* (expected behavior) is true. For example: "For any authenticated user and any active listing, the user can view that listing."

**How it works:** Kiro helps you write specifications using EARS format (e.g., "THE System SHALL allow authenticated users to view active car listings"). Kiro extracts properties from these requirements, determines which can be logically tested, then generates hundreds or thousands of random test cases to check your code. For example, if you’re building a car sales app:

- Traditional unit test approach: User adds Car #5 to favorites, Car #5 appears in their list
- Property-based test approach: For any user and any car listing, WHEN the user adds the car to favorites, THE System SHALL display that car in their favorites list. PBT then automatically tests this with User A adding Car #1, User B adding Car #500, User C adding multiple cars, users with special characters in usernames, cars with various statuses (new, used, certified), and hundreds more combinations, catching edge cases and verifying that implementation matches your intent.

Throughout this process, PBT probes to find counter-examples through a technique called "shrinking"—almost like a ‘red team’ trying to break your code. When it finds violations or counter-examples, Kiro can automatically update your implementation, or surface options for you to fix the Spec, implementation, or PBT itself.

**Why this matters:** While PBTs are not verification or proof, they provide evidence for correctness across scenarios you'd never write manually—showing whether your implementation actually behaves according to what you defined.

[Read the full, technical deep-dive on property-based testing →](/blog/property-based-testing/)

### Rewind changes with checkpointing

You can now go back to a previous change in your agent execution flow. Kiro generates a checkpoint every time the agent makes a change or takes an action. You can roll back any number of steps without losing progress. This comes in handy when you're far along in implementing a task and don't want to lose your progress or spend credits redoing work.

[See the checkpointing deep dive →](/blog/introducing-checkpointing/)

### Multi-root workspace support

Kiro now supports working across multiple project roots simultaneously. Teams with multiple git submodules or multiple packages in a single project can now work with the AI agent across all of them. A typical Kiro workspace contains a single “root” folder, e.g., `/users/bob/my-project`. With multi-workspace support, a single kiro workspace can have multiple roots, e.g., a single workspace that contains both `/users/bob/my-project` and `/shared/utils/auth` as top-level folders.

[Read the docs for multi-root workspaces →](/docs/editor/multi-root-workspaces/)

## Introducing Kiro CLI

The Kiro agent is now available in your terminal. Use the CLI to build features, automate workflows in seconds, analyze errors, trace bugs, and suggest fixes—all in a terminal of your choice, in a highly interactive loop that keeps you in flow. Kiro CLI works with the same steering files and MCP settings you set up in the Kiro IDE so you and your team have access to the same tools and preferences across both environments.

**What's included: **The CLI brings the full power of Kiro to your terminal—Claude Sonnet 4.5, Claude Haiku 4.5, and Auto, with steering files, advanced context management, and MCP tools to read and write files locally, call APIs, and run bash commands. Spec creation support is coming shortly, but you can work with existing specs in the CLI as well. The CLI also supports custom agents, specialized AI assistants you tailor for specific tasks—optimized with pre-approved tool permissions, your context files, and custom prompts. For example, your backend specialist focuses only on your API patterns and schemas. Your frontend agent knows only your components. Each agent uses its context window on just what matters. Think of custom agents as a way to package expertise very precisely so Kiro acts as an expert in that area without you repeating yourself or risking context rot.

Users building with the CLI over the past few weeks tell us they love the speed and interactivity.

You can use the CLI with the same Kiro subscription and login you're using in the IDE, with credit limits and overages shared across both tools. Install it on macOS or Linux:

[Learn more about Kiro CLI and custom agents →](/blog/introducing-kiro-cli/)

## Kiro for organizations

Teams can now sign up to Kiro via AWS IAM Identity Center, with support for more identity providers coming soon. Admins can manage access from the AWS Management Console, where they can assign Pro, Pro+, or Power subscriptions. They can also turn on overages, monitor costs, control MCP, and manage a single bill across the org. The new management dashboard gives you all the tools you need to manage Kiro for your team, startup, or enterprise, from one place. As a user, just click on “Sign in with your organization identity'” and follow the process.

## One year's worth of Kiro Pro+ for startups

Today, we are also introducing a startup offer: we are giving away [one year’s worth of Kiro Pro+ for qualifying startups](/startups/). Available globally to eligible startups up to Series B, the offer is available while credit supplies last. Existing AWS Activate credits can now be used for Kiro, and both offers stack.

Across teams, tools, and tests, Kiro now better supports the way you want to work by bringing the right level of context and structure to AI-powered development. This is just the start.

[Get started with the IDE](/downloads/) | [Get started with the CLI](/docs/cli/)

### How I stopped worrying about ReadMe files

Like most developers, I have been there: I push a brilliant new feature at 2 AM, feeling that familiar rush of dopamine as the build passes and deploys successfully. But three weeks later, when a new team member tries to onboard using my old README, they're staring at instructions for version 2.1 while my app is running version 3.2. The setup commands don't work. The API endpoints have changed. My beautiful documentation has become a liability.

Development teams often struggle with keeping documentation up to date, since manually updating README files with every code change is unrealistic in fast-paced environments. As a result, docs quickly become outdated and unreliable, slowing down onboarding and forcing developers to interrupt each other for answers. This constant disruption drains senior engineers, accelerating burnout and turnover, and when they leave, critical institutional knowledge leaves with them.

## What if your documentation could update itself auto-“magically”?

[Kiro's agent hooks](/docs/hooks/) solve this problem. Agent hooks are automated triggers that execute predefined agent actions when specific events occur in your IDE. Instead of manually updating documentation, you can set up hooks that automatically refresh your README when files are saved, update API documentation when endpoints change, and generate examples in your documentation when your code evolves.

## How it works

**1. Define the agent hook:  **Users can define their documentation requirements as an agent hook in natural language. Example prompt: “Watch for new or removed old API’s in all python files in this repository (*.py files), update OpenAPI yaml with the new API’s and remove the API’s that do not exist anymore. Update the ReadMe files with the updates in the *.py files. Figure 1 demonstrates the user creating an agent hook.

**2. Kiro creates the agent hook configuration: **Kiro translates your agent hook requirements into a configuration with a title, description, event, file paths to watch and Instructions that are sent to Kiro when event occurs. See [best practices when defining hooks](/docs/hooks/best-practices/) to understand this in detail.

In this case, the following configuration (in figure 2) was created using the example prompt in step 1. Kiro generated the title as ‘API Documentation Sync’, the event as ’File Saved’ (other [hook types](/docs/hooks/types/)) , and set the paths to watch as all .py files in the repository. The instructions for the agent hook are also generated based on the initial user provided prompt during agent hook creation.

##### Agent Hook Creation

Once the agent hook is created you will see that a json configuration is stored in the .kiro/hooks folder as a .hook file. In my case, the below config in figure 3 is stored. The agent hook configuration can be modified either through the UI or the .hook file that is generated.  Configuration stored under .kiro/hook/api-documentation-sync.kiro.hook after creation of the agent hook:

**3. Hook is triggered when event occurs: **When events such as file save and file create occur, then agent hook is triggered and a new session inside Kiro opens in the background and runs. Developers can then accept or modify changes proposed via the agent hook session.

**Let’s test the hook. **Let’s say we prompt Kiro to “Help me add a new API to extract records as a CSV”, Kiro adds the new API endpoint in the relevant .py file. In the background, another session named “Execute hook: API Documentation Sync” is created in which Kiro updates the OpenAPI.yaml file and ReadMe files . Kiro also generates a CHANGELOG.md to track the change introduced.

The following video shows how API Documentation Sync hook is triggered when a new API is added to ‘app.py’ file.

##### Agent Hook Triggered

## What else can you do with agent hooks?

While README automation is powerful, it's just the beginning. Agent hooks can automate any routine task that would need to happen when your code changes:

- Code optimization: Optimize code for readability, maintainability, and performance optimizations.
- Language localization: Generate automated translations of user-facing text content
- Security documentation: Update security considerations when you modify authentication code
- Architecture diagrams: Refresh system diagrams when you change service integrations
- Deployment guides: Update deployment instructions when you modify Docker configurations
- Troubleshooting guides: Generate common error scenarios based on your exception handling code
- Validate Figma design: Validates HTML/ CSS files that they follow a Figma design using the Figma MCP

And much more. Here’s a list of a few [examples for with detailed agent hook configurations.](/docs/hooks/examples/)

## What matters in the end

When documentation stays current automatically, something magical happens: developers start trusting it again. They interrupt each other less. Developers spend more time in flow state, code quality improves, and features ship faster. But the benefits go deeper than productivity metrics.

New Developers onboard faster. Accurate documentation becomes your institutional memory. When senior developers leave, their knowledge doesn't walk out the door, it lives in the guides that agent hooks kept current throughout their tenure. Your documentation should be a living reflection of your codebase, not a snapshot from three months ago. With Kiro's agent hooks, you can focus on building great software while your documentation evolves automatically alongside your code.

## Conclusion

I’m excited to see your all try setting up agent hooks in Kiro and see them in action on your projects. I would love to hear your thoughts on our [Discord server.](https://discord.com/invite/kirodotdev) You can start with the documentation use-case we spoke about in this blog and expand to others that we have discussed above or mentioned [in the documentation examples.](/docs/hooks/examples/)

## Considerations when using agent hooks

When implementing agent hooks with event triggers that utilize regular expressions (e.g., **/*.py), it is essential to carefully evaluate the pattern scope. Overly broad patterns may result in excessive changes when hooks are executed, leading to unnecessary documentation updates in large projects. It is recommended to implement more specific and targeted pattern matching to maintain efficiency and documentation clarity. See [troubleshooting agent hooks](/docs/hooks/troubleshooting/).

### How Kiro helped me code a game

Over the past 6 months, I have been putting Kiro, a new AI IDE, to the test by building an infinite crafting video game. The result is *Spirit of Kiro*, a living, open-source experiment that pushed my coding capabilities to the edge and taught me valuable lessons about how to use AI to build software.

*Spirit of Kiro* is a quirky sandbox game where you can combine any game item with any other game item. There are no hardcoded recipes limiting what you can do. Instead, modern LLMs handle the crafting logic on the fly. Players can get a taste of the same “yes, and…” creativity I feel when coding with Kiro.

Using Kiro to build the game changed how I prototype, how I write code, and how I think about the whole craft of software engineering.

## Start Fast. Break Things. Rewrite. Repeat.

One big lesson I learned from *Spirit of Kiro* is that great AI engineering thrives around the idea of disposable work. Most software projects involve a bit of upfront planning — maybe one or two prototypes — then you must commit to a direction and stick with the existing code. With Kiro, I found that AI enabled me to explore dozens of potential branching paths, then purposefully choose what I liked best. Each throwaway idea made the final product sharper.

Kiro makes it easier to experiment, and less painful to rewrite things. Need a quick WebSocket server? Prototype it. Want to try DynamoDB versus Postgres? Ask Kiro to prototype both. Wonder if Vue or React is better? Try both. Toss out the things you don’t like. Keep the insights.

## Steering Files: Consistent, Quality Code

One thing I particularly love about Kiro is its steering files: tiny documentation overviews that guide Kiro as it works on each prompt. Kiro helped me generate and update these steering files. As a result, I was able to spend a lot less time thinking about prompt engineering, and more time just asking for what I wanted. Steering files make Kiro dramatically better at turning vague instructions into clear, useful output with consistent code quality.

## Smaller Steps for Bigger Impact

Both AI and humans work best when big tasks are broken up into smaller ones. While Kiro is very capable of “vibe coding”; one of its unique powers is spec-driven development.

With spec-driven development, I asked Kiro to chart the path for large features such as a brand new “appraisal” feature I wanted to add to the game. This nontrivial feature required changes to the game client, the game server, and game infrastructure. Kiro helped me think through all the edge cases and potential subtasks I might have missed. It generated a design based on my actual code. Then, it generated a step-by-step plan to get the code from where it was to where I wanted it to be.

Spec-driven development works great with traditional software engineering best practices like continuous integration. I found myself working in small commits, with quick merges, and less fear of rolling back to make another try.

## Strongly Typed Languages

Kiro is great at TypeScript. I found that using a strongly typed language gives the LLM additional context info, resulting in higher quality code. In *Spirit of Kiro*, even when I used Bun (which does not strictly type-check at runtime), keeping TypeScript types in the mix gave Kiro exactly what it needed to stitch together functions, interfaces, and data flows with surprising accuracy. I could also use Kiro to run my build, detect errors, and then fix them automatically.

## Refactoring is fun and easy with Kiro

If you have ever stared at a huge code file wondering where it went wrong, I feel you. Short, well-scoped files are easier for both humans and AI to read, understand, and then add to.

Using Kiro taught me that clean, maintainable code is a deliberate choice, no matter what tool you are using. AI-assisted coding isn’t just about delivering features. Sometimes it’s time to use AI for a “vibe refactor”. I found myself asking Kiro to rewrite code with the “early return” pattern, or break large functions up into smaller, shorter functions.

I even asked Kiro to take a look at my code through the eyes of famous software engineers like Martin Fowler. Then, Kiro helped me break monolithic code into neat modules. The result was cleaner boundaries, and plenty of room to keep adding to the game over time.

## Event driven code is better for AI

Whether your code is monolithic or modular is just the start. The next factor is how tightly coupled code is. Unsurprisingly, both human software engineers and AI benefit from more loosely coupled systems. Instead of making each game component directly invoke functions from other game systems, I asked Kiro to implement a decoupled event system.

Game components emit events, then other game components or systems can subscribe to the event to react to it. This keeps game systems separate, which is perfect for fast iteration. Once I gave clear examples of how to wire up events, Kiro could repeat the pattern again and again.

The result was a game that scales better, and where I can continue to slot in new features over time.

## Ideation and Investigation

AI-assisted development doesn’t mean that you hand the entire software engineering job over to AI. Kiro did not replace me during this coding process. I stayed involved and engaged throughout. I found that I got tremendous value from asking Kiro to generate five to ten ideas for how to solve something, then I made the final pick. I also learned by asking follow-up questions. If Kiro generated code that I didn’t immediately understand, I always asked “why?” and “how?”

Most Kiro generated code was great, but sometimes the code didn’t quite work right. I still got tremendous value from some of these false starts and dead end paths along the way. Chatting with Kiro about issues in the code helped me identify where there were gaps in my knowledge that were preventing me from making more precise asks. For example, at one point I wanted to refactor the game’s main data store, but realized that in doing so, Kiro had broken the reactivity that Vue uses to refresh components automatically when the data changes. Ultimately, it was bad prompting on my part because I did not know enough about reactivity fundamentals to predict this outcome. A follow-up prompt via Kiro directed me to Vue’s reactivity in depth documentation, where I was able to fill in some personal knowledge gaps.

Maintaining a curious, engaged mindset let me use AI to build, while still building up my own skills and abilities.

## What’s Next?

*Spirit of Kiro* is not done. The [roadmap ](https://github.com/kirodotdev/spirit-of-kiro/blob/main/docs/ROADMAP.md)is long and the [open-source repo is now available](https://github.com/kirodotdev/spirit-of-kiro) to fork, remix, or break however you want. I am excited to see how other builders experiment in directions I have not even imagined yet.

If you take one thing away from my project, let it be this: Kiro is a multiplier of your abilities. If you are curious and want to explore, then you can use Kiro to test bold new ideas faster. If you want high quality code, you can use Kiro to iterate on code over and over until things are perfect. But most of all, if you enjoy coding, and have fun doing it, then Kiro is a multiplier of that enjoyment as well.

If you want to learn more or try *Spirit of Kiro* for yourself, [check out the repo](https://github.com/kirodotdev/spirit-of-kiro/) or the [guided tutorial in the documentation](https://kiro.dev/docs/guides/learn-by-playing/).

### Important Kiro pricing updates

*Read our *[latest blog post](/blog/free-until-september-15/)* on billing and pricing.*

---

We wanted to provide an update on our pricing.

## We fixed a metering bug causing requests to be miscounted

First, we have heard many of you were surprised by how quickly you were using included requests. We were surprised as well! We discovered that we introduced a bug when we rolled out pricing in Kiro where some tasks were inaccurately consuming multiple requests. We’ve deployed the fix for the metering issue that was causing the unexpected usage spikes many of you experienced.

## We have reset your limits for August

We’ve also heard concerns that the current limits do not give you enough room to get meaningful work done. We believe that much of this was coming from the metering issue which was causing users to deplete their limits faster than intended. As such, we’ve also reset your limits included in your plan. We want to understand how you’re using Kiro and how our current plans are working for you.

We’re keeping a close eye on the system. If any new bugs surface, we’ll continue to make adjustments and reset limits as needed.

## We are refunding you for charges incurred in August

Considering the confusion caused by the bug, we have decided to not charge for the month of August. Refunds will be rolling out starting Monday, August 25th. Below are FAQs on refunds, limits, and free usage during August. If you have additional questions, please [join the conversation on our Discord](https://discord.gg/kirodotdev).

## Thank you for your support and feedback

We know the last few days haven’t been smooth, and we don’t take that lightly. Our top priority is to get this right — not just the pricing, but building Kiro into something you can rely on to do real, meaningful work. Thanks for sticking with us and continuing to share your feedback. Please let us know what you think as you try things out.

## FAQs

##### When and how will customers be refunded?

Refunds for the subscription fee will be rolling out starting Monday, August 25th.

##### Are you refunding overages too?

If you have already incurred overages, we will refund those as well.

##### How and when will the usage be reset for customers?

Usage limits for both free and paid plans have been reset. Free plan users are reset to 100 vibe requests and 100 spec requests. Paid plan users are reset to the prorated limits of the plan they purchased.

##### If I purchase a subscription today is it free until September 1?

If you purchase a subscription before August 31st, you can use it for free until August 31st, and we'll refund the subscription price by the end of the month.

##### How does the ‘free August’ work?

If you’re already on a paid plan, your limits have been reset, and you can continue to use Kiro for free within the prorated limits until August 31st.

If you are purchasing a paid plan between now and August 31st, you will need to provide a valid credit card, which will be charged the price of the plan you purchased, plus applicable taxes and fees. We will then refund you by August 31st, within a few days of your purchase. You can use Kiro within the prorated plan limits you upgraded to (e.g. prorated number of 450 vibe requests and 250 spec requests for Pro+) for free. Unused requests will not roll over to the following months.

##### Can I enable overages for free during August?

Yes, you can turn on overages. [Overages](/docs/billing/overages/) are temporarily capped to 1,000 vibe requests and 200 spec requests. If your credit card gets charged for overages, we will refund it at the end of August.

##### As a paying customer who has already been charged for use of Kiro, can I opt to use my existing August payment as pre-payment for September, so that I don’t lose money on foreign exchange fees?

This is not possible currently. You will be refunded for August.

##### What are some known metering issues that still exist?

Here are some known billing discrepancies that we are aware of and are actively addressing. To unblock you faster, we have reset the limits now, but as we address these cases in the coming days, we will ensure that these miscounted requests are credited back to your request pool. We will update you as we make these changes.

1. If you type “Execute task X” in the chat window vs. actually clicking ‘Start task’ in the tasks.md file, you will be charged an extra vibe request in addition to a spec request.
2. For tasks with sub-tasks (e.g. Task 2 with 2.1 and 2.2 as subtasks), if you click on the parent task (e.g. Task 2), you get charged an extra vibe and an extra spec request. For now, you can click on the sub-tasks instead as a workaround.
3. If the agent has successive tool call failures (either its own tools or MCP tools), you will get billed for extra vibe requests.

### Never lose your way: Introducing checkpointing in Kiro

As developers, we've all been there. You're working with an AI coding assistant, making great progress on a feature. The agent makes a series of changes—updating files, refactoring code, adding new functionality. Then suddenly, something goes wrong. Maybe the agent misunderstood a requirement. Maybe it made an assumption that doesn't fit your architecture. Or maybe you just want to try a different approach.

The challenge isn't just undoing the code changes—it's losing the context of your conversation. You might revert your files, but then you're left trying to reconstruct where you were in your dialogue with the AI. The flow is broken, and getting back on track takes time and mental energy.

What if you could experiment without fear? What if you could let your AI assistant tackle ambitious refactors, knowing you could instantly rewind if things don't go as planned? That's the confidence checkpointing brings to AI-assisted development.

## What is checkpointing?

**Checkpointing gives you the power to rewind Kiro's changes to any point in your development session.** As Kiro modifies your codebase, it automatically creates checkpoint markers in your chat history. Think of them as auto-save points in a video game—if things go off the rails and you lose more health than you wanted, you can revert to an earlier checkpoint and try a different approach.

**Each checkpoint captures the specific changes Kiro made to your files during that session.** With a single click, you can roll back any file modifications the agent made after that checkpoint, while preserving your conversation history leading up to that restoration point. You keep the context, undo the unwanted changes, and get back to building.

**Important: Checkpointing only reverts changes made by Kiro during the current session.** We don't save your entire codebase, only the files modified by the agent in this specific session can be restored. **Note:** Restoring a checkpoint reverts the *complete state* of any file Kiro touched, not just Kiro's changes. If you or another tool made edits to those same files after the checkpoint, those edits will also be lost. Be sure to use version control if you're manually editing code or have other systems modifying files while building with Kiro.

## Why checkpointing matters

AI-assisted development is powerful, but it's not perfect. Large language models are probabilistic by nature. Sometimes they make the right call. Sometimes they don't. The key is giving you, the developer, control over the process.

Without checkpointing, every AI-generated change carries risk. You might hesitate to let Kiro tackle a complex refactor because you're worried about the cleanup if something goes wrong. You might spend more time reviewing each change than you would just writing the code yourself. The fear of losing progress can actually slow you down.

Checkpointing changes that dynamic. It gives you the confidence to let Kiro take bigger swings. Want to try a different architectural approach? Go for it. If it doesn't work out, you're one click away from where you started. Want to experiment with a new library? No problem. The checkpoint is there if you need it.

## How it works

Checkpointing in Kiro is designed to be invisible until you need it. You don't have to remember to create checkpoints or manage them manually. Kiro handles that for you.

As you work with Kiro, checkpoint lines appear automatically in your chat interface. Before you start a task a checkpoint is created. These visual markers make it easy to see the structure of your development session at a glance.

When you want to revert, simply click the “Restore” button on any checkpoint line. Kiro rolls back everything—all file changes made by the agent and your conversation history—putting you right back at that exact moment. If you had typed a message but not sent it yet, it'll be there in your chat window, ready to edit or send. It's like time travel for your development session. You get back not just the code state, but the complete context of where you were and what you were thinking.

## Checkpointing and spec-driven development

Checkpointing pairs naturally with Kiro's spec-driven development workflow. When you're working through a specification, you might want to try different approaches to implementing a particular requirement. Checkpointing makes that exploration risk-free.

You can also use checkpoints to mark the completion of major milestones in your spec. Finished implementing the authentication system? That's a checkpoint. Completed the data layer? Another checkpoint. These markers give you a clear map of your progress and make it easy to revisit earlier stages if you need to make changes.

## Real-world scenarios

Let's look at a few scenarios where checkpointing shines:

**Safe experimentation**: You're curious whether a particular refactoring would improve your code's performance. Let Kiro make the changes and run your benchmarks. If the results aren't what you hoped for, revert to the checkpoint. No harm, no foul. The ability to experiment without consequences is incredibly freeing.

**Iterative refinement**: Sometimes you need to try a few variations before you find the right solution. With checkpointing, you can iterate quickly. Try an approach, evaluate it, revert if needed, and try again. Each iteration builds on the lessons of the last, but without the baggage of failed attempts cluttering your codebase.

**Exploring different implementations**: You're building a new API endpoint and you're not sure whether to use REST or GraphQL. Ask Kiro to implement it as REST first. Review the code, test it out, see how it feels. Not quite right? Revert to the checkpoint and ask Kiro to try GraphQL instead. Same conversation, different approach, zero manual cleanup.

**Recovering from misunderstandings**: You ask Kiro to "add authentication to the user service." Kiro implements OAuth2, but you actually wanted simple API keys. Instead of manually undoing dozens of file changes, you revert to the checkpoint before Kiro started and clarify your requirements. Kiro tries again, this time with the right approach.

## Building confidence in AI-assisted development

The real power of checkpointing isn't just the ability to undo changes. It's the confidence it gives you to work differently.

With checkpointing, you can treat AI-assisted development more like a conversation and less like a transaction. You can explore ideas, test hypotheses, and iterate rapidly without worrying about the cost of being wrong. You can let Kiro handle more complex tasks because you know you have a safety net.

This shift in mindset is subtle but profound. Instead of carefully controlling every step Kiro takes, you can focus on the bigger picture—what you're trying to build and why. Instead of spending mental energy on "what if this goes wrong," you can spend it on "what if this goes right."

## Checkpointing and version control

Let's be clear: checkpointing isn't a replacement for version control. You should still use Git (or your preferred version control system) as part of your development workflow. Think of version control as your long-term project history and collaboration tool, while checkpointing is your short-term experimentation and iteration tool.

Checkpointing shines during active development sessions when you're exploring ideas and iterating rapidly with Kiro. Once you've landed on an approach you're happy with, commit it to version control like you normally would. The two tools serve different purposes and work best together.

## Try it yourself

Checkpointing is available now in Kiro. You don't need to configure anything or change how you work. Just start a conversation with Kiro, make some changes, and watch the checkpoint lines appear. When you need to revert, they'll be there waiting for you.

We built Kiro to give you more control over AI-assisted development, not less. Checkpointing is a big part of that vision. It's about making AI a true partner in your development process—one that gives you the freedom to explore, experiment, and iterate without fear.

Ready to code with confidence? [Download Kiro](/downloads/) and see how checkpointing changes the way you work with AI.

---

*Have questions about checkpointing or want to share how you're using it? Join the conversation in our *[Discord community](https://discord.gg/kirodotdev)* or follow us on *[X](https://x.com/kirodotdev)*, *[LinkedIn](https://www.linkedin.com/showcase/kirodotdev)*, and *[Bluesky](https://bsky.app/profile/kiro.dev)*.*

### Introducing Kiro

I’m sure you’ve been there: prompt, prompt, prompt, and you have a working application. It’s fun and feels like magic. But getting it to production requires more. What assumptions did the model make when building it? You guided the agent throughout, but those decisions aren’t documented. Requirements are fuzzy and you can’t tell if the application meets them. You can’t quickly understand how the system is designed and how that design will affect your environment and performance. Sometimes it’s better to take a step back, think through decisions, and you’ll end up with a better application that you can easily maintain. That’s what Kiro helps you do with spec-driven development.

I'm excited to announce Kiro, an AI IDE that helps you deliver from concept to production through a simplified developer experience for working with AI agents. Kiro is great at ‘vibe coding’ but goes way beyond that—Kiro’s strength is getting those prototypes into production systems with features such as **specs** and **hooks.**

**Kiro specs** are artifacts that prove useful anytime you need to think through a feature in-depth, refactor work that needs upfront planning, or when you want to understand the behavior of systems—in short, most things you need to get to production. Requirements are usually uncertain when you start building, which is why developers use specs for planning and clarity. Specs can guide AI agents to a better implementation in the same way.

**Kiro hooks** act like an experienced developer catching things you miss or completing boilerplate tasks in the background as you work. These event-driven automations trigger an agent to execute a task in the background when you save, create, delete files, or on a manual trigger.

## Building with Specs and Hooks

Kiro accelerates the spec workflow by making it more integrated with development. In our example, we have an e-commerce application for selling crafts to which we want to add a review system for users to leave feedback on crafts. Let's walk through the three-step process of building with specs.

### 1. From single prompt to requirements

Kiro unpacks requirements from a single prompt—type *"Add a review system for products"* and it generates user stories for viewing, creating, filtering, and rating reviews. Each user story includes EARS (Easy Approach to Requirements Syntax) notation acceptance criteria covering edge cases developers typically handle when building from basic user stories. This makes your prompt assumptions explicit, so you know Kiro is building what you want.

### 2. Technical design based on requirements

Kiro then generates a design document by analyzing your codebase and approved spec requirements. It creates data flow diagrams, TypeScript interfaces, database schemas, and API endpoints—like the Review interfaces for our review system. This eliminates the lengthy back-and-forth on requirements clarity that typically slows development.

### 3. Implement tasks

Kiro generates tasks and sub-tasks, sequences them correctly based on dependencies, and links each to requirements. Each task includes details such as unit tests, integration tests, loading states, mobile responsiveness, and accessibility requirements for implementation. This lets you check work in steps rather than discovering missing pieces after you think you're done.

The task interface lets you trigger tasks one-by-one with a progress indicator showing execution status. Once complete, you can see the completion status inline and audit the work by viewing code diffs and agent execution history.

Kiro's specs stay synced with your evolving codebase. Developers can author code and ask Kiro to update specs or manually update specs to refresh tasks. This solves the common problem where developers stop updating original artifacts during implementation, causing documentation mismatches that complicate future maintenance.

### 4. Catch issues before they ship with hooks

Before submitting code, most developers run through a mental checklist: Did I break anything? Are tests updated? Is documentation current? This caution is healthy but can take a lot of manual work to implement.

Kiro's agent hooks act like an experienced developer catching things you miss. Hooks are event-driven automations that execute when you save or create files—it’s like delegating tasks to a collaborator. Set up a hook once, and Kiro handles the rest. Some examples:

- When you save a React component, hooks update the test file.
- When you modify API endpoints, hooks refresh README files.
- When you're ready to commit, security hooks scan for leaked credentials.

Hooks enforce consistency across your entire team. Everyone benefits from the same quality checks, code standards, and security validation fixes. For our review feature, I want to ensure any new React component follows the Single Responsibility Principle so developers don't create components that do too many things. Kiro takes my prompt, generates an optimized system prompt, and selects the repository folders to monitor. Once this hook is committed to Git, it enforces the coding standard across my entire team—whenever anyone adds a new component, the agent automatically validates it against the guidelines.

## Everything Else You'd Expect

Beyond specs and hooks, Kiro includes all the features you'd expect from an AI code editor: Model Context Protocol (MCP) support for connecting specialized tools, steering rules to guide AI behavior across your project, and agentic chat for ad-hoc coding tasks with file, URL, Doc’s context providers. Kiro is built on Code OSS, so you can keep your VS Code settings and Open VSX compatible plugins while working with our IDE. You get the full AI coding experience, plus the fundamentals needed for production.

## The Future

Our vision is to solve the fundamental challenges that make building software products so difficult—from ensuring design alignment across teams and resolving conflicting requirements, to eliminating tech debt, bringing rigor to code reviews, and preserving institutional knowledge when senior engineers leave. The way humans and machines coordinate to build software is still messy and fragmented, but we're working to change that. Specs is a major step in that direction.

Ready to experience spec-driven development? Kiro is free during preview, with some limits. We're excited to see you try it out to build real apps and would love to hear from you on our [Discord server.](https://discord.com/invite/kirodotdev)

To get started, [join the waitlist](/waitlist/). We support Mac, Windows, and Linux, and most popular programming languages. Our hands-on tutorial walks you through building a complete feature from spec to deployment. [Start the tutorial](/docs/guides/learn-by-playing/).

Let’s connect - tag @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev), and share what you’ve built using hashtag #builtwithkiro

### Introducing Kiro autonomous agent

IDE assistants were the first wave of AI developer tools. They started with simple in-line completions and expanded into chat interfaces, evolving into agentic workflows that can plan and execute multi-step tasks directly from the IDE. CLI assistants then emerged, bringing AI assistance to the command line.

Earlier this year, we introduced Kiro IDE and Kiro CLI to bring structure to these AI workflows. They're great for working directly with agents on your local machine. Agentic workflows are continuing to evolve, and a new class of agents has emerged: frontier agents that work independently, maintaining context, and learning from every interaction.

Today, we're launching Kiro autonomous agent in preview, one of [three new frontier agents](https://www.aboutamazon.com/news/aws/amazon-ai-frontier-agents-autonomous-kiro) that transform how developers and teams build and operate software.

Kiro autonomous agent is starting to roll out for individual developers in preview to Kiro Pro, Pro+, and Power subscribers. There's no cost during the preview period, and usage is subject to weekly limits. Teams can [join the waitlist](https://pages.awscloud.com/Kiro-autonomous-agent-contact.html) to get early access.

## The development context gap

Most AI coding assistants require you to actively manage context, which hasn't been easy. You constantly re-explain your preferences and patterns or build systems to store context in repos. And they're session-based. Once you close a session, they forget everything. This becomes especially painful when working across multiple repositories. You need to set up context for each repo and give the agent access to each one.

Let's say you need to upgrade a critical library that's used across 15 microservices.

**Doing it yourself**: Open each repo, update dependencies, fix breaking changes, run tests, create PR. Repeat 15 times, and this can amount to days of work.

**Using an agentic IDE/CLI**: You're faster than doing it manually. Open the first repo, prompt the agent to update the library, review its changes, fix what it missed, run tests, create the PR. Then, move to repo 2 and start over. You're still in the loop for every single repo, and the agent forgets everything once you close that session.

**With Kiro autonomous agent**: Describe it once. It treats the multi-repo work as a unified task, identifies affected repo, analyzes how each service uses the library, updates code following your patterns, runs full test suites, and opens 15 tested pull-requests for review, while you work on something else.

The difference? Kiro autonomous agent isn't session-based. It's always there and maintains context across your work. When you give feedback on one PR about error handling, it remembers and applies that pattern to subsequent change. When it encounters similar architectural decisions, it considers existing implementations and preferences. You're not re-explaining your codebase or repeating the same work—it already knows how you work and gets better with each interaction.

## How it works

As we roll out Kiro autonomous agent, paid users will get access [in their online account](https://app.kiro.dev/agent). You can chat with it, describe a change you need, or an improvement you want, and execute up to 10 tasks concurrently. The agent will independently figure out how to get the work done.

When you assign a task, Kiro autonomous agent:

1. Spins up an isolated sandbox environment that mirrors your development setup
2. Clones your repositories and analyzes the codebase
3. Breaks down the work and defines requirements and acceptance criteria
4. Coordinates specialized sub-agents: one handles research and planning, another writes code, and a verification agent checks output before moving forward
5. Asks questions if uncertain about any aspect of the work
6. Opens pull requests with detailed explanations of changes and implementation decisions

Each task runs in its own isolated sandbox with configurable network access, environment variables, and development environment settings. Because Kiro autonomous agent runs asynchronously, it can take the time needed to properly set up your development environment, run test suites, and verify changes, all while you focus on other work.

## Working with Kiro autonomous agent

Chat with Kiro autonomous agent to discuss approaches, ask questions, or provide context about your work. When you're ready to delegate, ask it to create a task.

**Before creating a task**

Use chat to discuss different implementation approaches, clarify requirements or constraints, and get the agent's input on technical decisions. The agent has access to web search, learnings from previous code reviews, and context from other tasks to provide informed responses.

**During task execution**

Once a task is created, continue chatting to steer the implementation approach, provide additional requirements, or ask the agent to do more work after reviewing initial results. Any comments or steering will update the scope of the current task. To work on a different task, start a new chat.

**Assigning tasks from GitHub**

You can also assign work directly from GitHub issues. Add the `kiro` label to any issue, or mention `/kiro` in a comment to assign that specific task to Kiro autonomous agent. The agent will listen to all comments on the issue for additional context or feedback.

## Learns from your code reviews

When you leave PR feedback like “always use our standard error handling pattern” or “remember to follow the team's naming conventions,” Kiro autonomous agent doesn't just fix that PR. It remembers and applies those patterns to future work automatically.

As you work with it, the agent gets better at understanding your code, your products, and the standards you follow, building knowledge that improves every subsequent task.

## Secure, configurable execution

Each task that agent runs operates in an isolated sandbox with configurable access controls. You control permissions, network access, and what resources the agent can touch.

**Network access controls**

Choose from three levels for each task: Integration only (the sandbox only accesses the GitHub proxy), Common dependencies (access to package registries like npm, PyPI, and Maven), or Open internet. You can also define custom domain allowlists for precise control.

**MCP integration**

MCP integrations are used during task execution, giving Kiro access to more tools. Connect specialized tools and proprietary systems through Model Context Protocol servers for individual tasks.

**Environment variables and secrets**

Configure environment variables and secrets that are available to the agent during individual task execution. Secrets are stored encrypted and never exposed in logs or pull requests.

**Environment configuration**

The agent automatically detects [DevFiles](https://devfile.io/) or [Dockerfiles](https://docs.docker.com/reference/dockerfile/) in your repository to configure the sandbox environment with the right dependencies, build commands, and runtime requirements. If neither is found, the agent analyzes your project structure to set up an environment for your projects.

## Kiro autonomous agent for teams

For teams, Kiro autonomous agent becomes a shared resource that works alongside everyone, building collective understanding of your codebase, products, and standards. Unlike individual AI assistants that operate in isolation, the team agent weaves together specs, discussions, and pull requests into a unified memory that makes the entire team more effective.

Consider a team building a new payment processing feature. One developer teaches the agent about the team's error handling patterns through a code review. Another developer assigns the agent to implement the refund workflow days later. The agent already knows those patterns and applies them automatically, maintaining consistency across the feature without anyone needing to re-explain the standards.

**Ship faster together**

The agent runs development work in parallel across multiple repositories and tasks, so releases move forward with fewer bottlenecks. While one developer focuses on the API redesign, the agent handles the corresponding updates across client libraries, documentation, and integration tests as part of the workflow.

**Works across your stack**

Connect your team's repos, pipelines, and collaboration tools—Jira, GitHub, GitLab, Teams, Slack, Confluence—so the agent maintains context as work progresses. When someone updates a spec in Confluence, comments on a Jira ticket, or discusses an approach in Slack, the agent incorporates that context into its tasks, ensuring changes align with team best practices.

**Learns from your team**

Code reviews, feature requests or bugs, and architectural decision becomes part of the agent's understanding. It learns not just from what's documented, but from how your team actually works and the patterns you prefer. This learning means the agent gets better at supporting your specific team over time, not just better at coding in general.

Teams can [join the waitlist](https://pages.awscloud.com/Kiro-autonomous-agent-contact.html) to get early access.

---

We’re starting to gradually roll out Kiro autonomous agent in preview to Kiro Pro, Pro+, and Power users. [Learn more](/autonomous-agent/) or [sign in to check availability](https://app.kiro.dev/agent).

### Bring Kiro agents to your terminal with Kiro CLI

You’re connected to a production server at 2am debugging an issue. You know AI could help since you've been using agents in your IDE all week, moving fast, building confidently. But switching contexts means losing your terminal session, your SSH connection, your flow. So you stay stuck, manually tracing through logs, Googling syntax, working alone. It's a choice you shouldn't have to make: work in your IDE where you have AI agents, or work in the terminal where its more practical for such scenarios, but without their assistance.

Today, we're closing that gap. [Kiro CLI](/cli/) brings agentic AI directly into your terminal. Same agents, same intelligence, wherever you code.

## What is Kiro CLI?

Kiro CLI uses advanced agent functionality and technology from the Q Developer CLI (including agent mode, MCP, steering, and custom agents), and adds support for social login, Haiku 4.5, and our agent Auto, which balances performance, efficiency, and output quality. Scaffold projects, debug production issues, write infrastructure code, all without leaving your shell. Just describe what you need in plain language.

The power comes from specialization. Create custom agents tailored to your codebase: a backend specialist that knows your API patterns, a frontend expert familiar with your components, a DevOps agent that understands your infrastructure. Each agent focuses its full context window on what matters for that workflow.

Already using Kiro IDE? Your `.kiro` folder configuration works in both environments. Kiro CLI can utilize the same steering files (these are rules to guide AI behavior across your project) and the same MCP servers. Configure once, use everywhere.

## Why Kiro CLI?

**Stay in the terminal.** No context switching. No looking up syntax. Just describe what you need and keep building.

**Structure your AI workflows.** Custom agents let you pre-configure tools, permissions, and context for different tasks. Switch between them instantly.

**One setup, two environments.** Your MCP servers, steering rules, and project docs work in both Kiro IDE and Kiro CLI. Configure once, use everywhere.

**Built for how you actually work.** Whether you're managing infrastructure, reviewing code, or debugging—create agents for your specific workflows and share them with your team.

**Fast automation.** Format code, run tests, manage logs, and more—all through automated shell commands.

## Getting started

### Installation

[Kiro CLI](/cli/) is available for macOS and Linux. [Installation](/docs/cli/installation/) is straightforward:

### First steps

**1. Authenticate and start chatting**: Sign in with your credentials

**2. Explore commands**: Get help anytime

## Key features

### 1. Custom agents: structure for AI coding in the terminal

Custom agents bring structure to AI-powered terminal workflows by letting you define exactly how the AI should behave for different tasks:

- Pre-approved tools: Trust specific tools to run without constant permission prompts, perfect for your regular workflows
- Persistent context: Automatically load project files, documentation, and standards
- Controlled access: Limit which tools are available to keep things focused and secure including granular tool permissions
- Workflow-specific configurations: Different agents for different vibes, cloud ops, code reviews, debugging sessions

Example agent configuration:

This structured approach means you're not constantly context-switching or re-explaining your project setup. Kiro knows what it needs to know, and you stay in the flow. This example agent is like having a specialist instead of a generalist because it focuses on backend development, so it doesn't waste time or mental energy thinking about frontend, DevOps, or other unrelated topics. The file path restrictions mean it can only touch backend files (like `src/api/**` and `server.js`), preventing it from accidentally breaking your frontend or config files. It automatically loads your `backend-standards.md` file, so it always remembers your team's rules about async/await, error handling, and API design without you having to remind it every time. The result is faster, more accurate responses that consistently follow your standards because the agent isn't distracted by irrelevant information.

Beyond individual tool restrictions, Kiro CLI also supports broader permission patterns for even more flexibility:

**Fine-grained tool permissions**: Use the `@builtin` namespace to pre-approve all built-in tools at once, or specify individual tools for precise control:
 `@builtin` namespace to pre-approve all built-in tools at once, or specify individual tools for precise control:

### 2. Smart context management with visual indicators

Kiro CLI offers three flexible approaches to provide context:

- Agent Resources: Persistent context across sessions for essential project files
- Session Context: Temporary files for quick experiments
- Knowledge Bases: Semantic search for large codebases (supports PDFs!) without consuming context window space

**Context usage percentage**: with `kiro-cli chat` open, typing `/context` will show visual indicators. This helps you stay aware of context consumption and manage it proactively during long conversations.

### 3. Flexible authentication options

Kiro CLI supports multiple authentication methods to fit your workflow:

- GitHub: Seamless integration with your GitHub account
- Google: Sign in with your Google credentials
- AWS Builder ID: Quick setup for AWS developers
- AWS IAM Identity Center: Enterprise-grade authentication with centralized management

For teams using IAM Identity Center, administrators can manage everything from the AWS Management Console. For example: assign subscription tiers, track spending, and consolidate billing across the organization.

### 4. Integration with the Kiro IDE

Already using Kiro IDE? **Your existing setup just works**. No need to reconfigure everything from scratch. Your Kiro IDE configurations transfer seamlessly to Kiro CLI:

- MCP Servers: Copy your .kiro/settings/mcp.json and your MCP tools are ready to go
- Steering Rules: Your .kiro/steering/*.md files work in Kiro CLI—same project standards, same context
- Project Documentation: All your .kiro docs and configurations carry over

This means you can jump between IDE and terminal without losing context or reconfiguring your AI assistant. It's the same Kiro vibe, just in a different environment.

### 5. Everything else you’d expect from a modern agentic CLI experience

#### Interactive AI chat in your terminal

Start a conversation with Kiro right from your command line:

Scaffold new projects from scratch, write infrastructure as code, and add features to existing codebases. You can do this all without leaving your terminal. Kiro understands your project context and can make meaningful changes across multiple files:

Need to compose longer, more detailed prompts? Use `/editor` to open your preferred text editor for multi-line input and really spell out what you're building.

#### Multimodal input: reference images directly

Need to share a screenshot, diagram, or error message? Kiro CLI handles it automatically. Pass along images for debugging UI issues, sharing architecture diagrams, or getting help with visual content.

#### Model Context Protocol (MCP) support

Kiro CLI supports the Model Context Protocol, letting you extend its capabilities with external tools and services. The best part? If you're already using MCP servers in Kiro IDE, they work seamlessly in Kiro CLI too. Check out this other [Kiro blog post ](https://kiro.dev/blog/introducing-remote-mcp/)for more on MCP.

#### Credit usage

Just like in the IDE, Kiro will tell you how many credits you use as you go so you can keep track.

#### Auto agent

Kiro CLI includes the same intelligent Auto agent that powers Kiro IDE. Auto dynamically chooses the optimal model for each task, balancing speed, cost, and quality. The result? Superior efficiency—tasks that cost X credits in Auto mode would run you 1.3X credits if you manually selected Sonnet 4. Let Auto handle the heavy lifting so you get excellent results at a better price point, without thinking about which model to use.

Auto is enabled by default and you have the option to select a model with `/model` command in Kiro CLI.

## Real-world use case

Recall the `backend-specialist` example above? Here’s how you’d put that to use in Kiro. After implementing the configuration for the agent, you’re ready to put it to use. See the examples below for how you’d invoke this agent and some sample prompts for how you might put it to work in the real world.

You can create specialized agents for any workflow. Examples: a code review agent with linting tools and your team's style guide, a DevOps agent with infrastructure access and deployment scripts, or a debugging agent pre-loaded with your logging utilities and common troubleshooting steps. Each agent focuses its context on what matters for that specific task, making your AI interactions faster and more relevant.

## Join the Kiro community

We'd love to hear from you! Share your feedback, swap agent configurations, and connect with other Kiro users: [Join the Kiro Discord community](https://discord.gg/kirodotdev) to chat with the team and other developers.

## Get started today

Ready to bring the Kiro vibe to your terminal? [Install Kiro CLI](/docs/cli/installation/) and experience AI-powered command-line workflows that actually feel good to use.

Whether you're an existing Kiro IDE user or new to Kiro, you can work in the terminal with AI assistance that just gets it.

### Introducing Opus 4.5 in Kiro

We’re excited to offer support for Claude Opus 4.5. Opus 4.5 is Anthropic's newest and most intelligent model, setting new standards across coding and agentic workflows.

Opus 4.5 achieves state-of-the-art performance on SWE-bench. It can better balance tradeoffs and ambiguity as it reasons across multiple systems to implement development tasks or fix complex bugs. Opus 4.5 is well-suited to power agents that can perform long duration tasks and reason across complex codebases, making it ideal for spec-driven development.

With this update, you can use Opus 4.5 to solve your most complex production software development tasks, generate detailed specs and architectural designs, while Auto can help you implement day-to-day features quickly and cost-effectively.

This model is available to users logging in with Google, GitHub, and AWS BuilderID in the Kiro IDE and the Kiro CLI. Opus 4.5 is not currently available for customers logging in with AWS IAM Identity Center. Opus 4.5 features a 2.2× credit multiplier, compared to 1.3× for Sonnet 4.5 and 0.4× for Haiku 4.5.

Opus 4.5 in Kiro is available [with experimental support](/docs/privacy-and-security/data-protection/#global-cross-region-inference-for-experimental-features). We’re excited to see what you build and we’d love to hear your feedback on [Discord](https://discord.gg/kirodotdev) or [X](https://x.com/kirodotdev).

### Introducing Kiro powers

You're building a checkout flow. Even if you've used Stripe before, you're still hunting through docs for the right pattern—should you use idempotent keys here? What's the best way to handle webhooks? And if you haven't touched Stripe, the learning curve is even steeper. Your AI assistant should give you instant access to framework expertise so you can ship faster. But today's AI agents face the same challenge: without built-in knowledge, they guess and iterate just like you do.

1. Without framework context, agents guess: Your agent can query Neon, but does it understand connection pooling for serverless? It can call APIs, but does it know the right patterns and best practices? Without built-in expertise, you're both manually reading documentation and refining approaches until the output is right. This trial-and-error repeats for every tool, every framework, every domain outside your core expertise. Powers give your agent—and by extension, you—instant access to specialized knowledge, so you can work in unfamiliar domains faster.
2. With too much context, agents slow down: MCPs are meant to solve the framework context problem, but they come with their own issues. Connect five MCP servers and your agent loads 100+ tool definitions before writing a single line of code. Five servers might consume 50,000+ tokens—40% of your context window—before your first prompt. More tools should mean better results, but unstructured context overwhelms the agent, leading to slower responses and lower quality output aka context rot.

## The existing landscape

AI development tools are evolving rapidly. Anthropic recently introduced dynamic tool loading (Tool Search tool), Claude Skills for packaging instructions, and various primitives such as sub-agents and rules for agent behavior. Cursor provides rules and .cursorrules files for custom instructions. MCP provides a standard for tool communication across clients. These are powerful capabilities, but they exist as separate systems:

- MCP servers for tool access (configure in each client)
- Skills for instructions and workflows (Claude-specific)
- Dynamic tool loading for context management (separate setup)
- Rules and custom instructions for behavior (per-client configuration like .cursorrules)

Each requires separate configuration and management. You're stitching together multiple primitives to get the full picture: tools + knowledge + dynamic loading. And when you switch between Cursor, Claude Code, or other tools, you're reconfiguring everything again.

The challenge isn't missing capabilities—it's fragmentation. Developers want a unified package: "Install the Stripe integration and my agent knows how to use it correctly." Not: "Configure the MCP server in mcp.json, write a Skill or `.cursorrules` file, set up dynamic loading, add custom instructions—and repeat for each tool."

## Introducing Kiro powers

Kiro powers provide that unified approach for a broad range of development and deployment use cases: MCP tools, and framework expertise —packaged together and loaded dynamically.

Remember when Neo instantly downloaded martial arts expertise in The Matrix? That's what powers do for the Kiro agent—instant access to specialized knowledge for any technology. The key is dynamic context loading: traditional MCP implementations load every tool upfront, but powers activate only when relevant. Mention "database" and the Neon power loads its tools and best practices. Switch to deployment and Netlify activates while Neon deactivates.

A power is a bundle that includes:

1. POWER.md: The entry point steering file—an onboarding manual that tells the agent what MCP tools it has available and when to use them
2. MCP server configuration: The tools and connection details for the MCP server
3. Additional steering or hooks: Things you want the agent to run such as hooks or steering files via slash commands.

Install the Stripe power with one click. When you mention "payment" or "checkout," the power activates—loading Stripe's MCP tools and the `POWER.md` steering into context. When you're done with payments and move to database work, the Supabase power activates and Stripe deactivates. Install curated powers, grab what the community's built, or create and share your own.

### What makes powers different

**1. Dynamic MCP tool loading**

Traditional MCP servers load all tools upfront. The Figma MCP server might expose 8 tools consuming 12K tokens. The Postman server adds 122 tools. Connect five servers and you've used up a large portion of your context window before writing code. Powers load tools on-demand. Install five powers and your baseline context usage is near zero. Mention "design" and the Figma power activates, loading its 8 tools. Switch to database work and Supabase activates while Figma deactivates. Your agent only loads tools relevant to the current task.

**2. Power ecosystem: curated from partners, community, or build your own **

Powers are designed for easy discovery and installation, whether you're using curated partners, community-built powers, or your team's private tooling. Discovery, installation, and configuration happen through the IDE or the kiro.dev website. You focus on building.

We've partnered with companies across UI development (Figma), backend development (Supabase, Stripe, Postman, Neon), agent development (Strands), and deployment (Netlify, Amazon Aurora). Open the powers panel and you have a swiss army knife of capabilities ready to install—no hunting for MCP servers or reading setup docs. Launch partners include Datadog, Dynatrace, Figma, Neon, Netlify, Postman, Supabase, Stripe, and Strands Agent, with more coming soon. In addition we have community members who have created powers such as a SaaS builder, AWS CDK infrastructure development, and working with Amazon Aurora DSQL.

**One-click install from IDE and web**: Browse powers directly in Kiro or on kiro.dev. Click "Install" and the power registers automatically. If it needs API keys or environment variables, it prompts you on first use. No JSON configuration files, no command-line setup.

**Anyone can build and share**: Import powers from GitHub URLs for community-built tools. Teams with private powers can import from local directories or private repos. Build once, share with your team, and everyone gets the same expertise and tooling.

**3. Cross-compatibility (coming soon)**

Today, powers work in Kiro IDE. We're building toward a future where powers work across any AI development tool—Kiro CLI, Cline, Cursor, Claude Code, and beyond. The Model Context Protocol provides a standard for tool communication. Powers extend this with standards for packaging, activation, and knowledge transfer. Build a power once, use it anywhere.

This matters for our partners. Companies don't want to maintain proprietary context for each AI tool. They want to write one onboarding manual—one `POWER.md`—and have it work everywhere. Powers will be that standard.

## The anatomy of a power

To understand a power better, let’s look at how the Supabase power is structured to understand what makes powers effective.

**1. Frontmatter: Activating the power**

The frontmatter in the `POWER.md` defines when the power activates. Keywords trigger activation—mention "database" or "postgres" and the Supabase power loads its MCP tools and context.

When you say "Let's set up the database," Kiro detects "database" in the keywords and activates the Supabase power, loading its MCP tools and `POWER.md` into context.

**2. Onboarding with the **`POWER.md`**: Setting up the workspace**

The onboarding section guides the agent through initial setup, validating dependencies and installing hooks or steering files that can be manually invoked. This typically runs once when the power is first activated. The agent follows these steps automatically: checks if Docker is running, validates the Supabase CLI, and creates the performance review hook in your workspace.

**3. Workflow-specific steering: Loading context on-demand**

The `POWER.md` includes a map of steering files for specific workflows. When you're working on RLS policies, the agent loads `supabase-database-rls-policies.md`. When you're writing Edge Functions, it loads `supabase-edge-functions.md`.

This keeps context focused. Instead of loading all Supabase patterns upfront, the agent loads only what's relevant to your current task.

## The future of agent capabilities: Continual learning through powers

Neo didn't learn kung fu once and stop. Throughout The Matrix, he downloaded new capabilities as he needed them—piloting helicopters, mastering weapons, understanding the Matrix itself. Each power expanded what he could do without overwhelming him with abilities. That's the vision for AI agents. Powers aren't just a packaging format—they're a model for continual learning. As frameworks evolve and your team builds internal tools, agents need a way to expand their capabilities without starting from scratch.

Yesterday, adding a new tool meant manually configuring MCP servers and hoping context doesn't overflow. Today, it means installing a power. Supabase ships updated RLS patterns? Your agent gets them automatically. Your team builds an internal design system? Package it as a power and every developer's agent knows how to use it.

This is how agents become truly useful—not by knowing everything upfront, but by learning what they need, when they need it, and continuously expanding their expertise as the tools around them evolve. The result is an AI agent that knows when to think about design systems, when to think about databases, and when to think about deployment—just like a human developer would.

[Try powers today in Kiro](/powers/), and let us know what you build.

### Introducing remote MCP servers

Model Context Protocol, also known as MCP, has become the standard for agents to connect to tools and external systems. It has become the universal interface for executing functions, accessing files, and running prompts. MCP is widely used among AI coding assistants, to help extend the capabilities of the underlying large language models.

MCP has evolved significantly since Anthropic announced it in November 2024. While agents initially connected primarily to locally-running MCP servers, remote MCP server connections have become increasingly common. Remote servers extend agent capabilities, allowing them to go beyond the local environment. Servers running remotely can more easily connect to data sources, internet-hosted tools, and services. For example, you could connect to a remote MCP server that has access to your note taking service. They can also be more properly secured. This opens up the endless possibilities of integrations and scenarios for you as a user.

Kiro users love our local MCP server support, and we've seen so many interesting applications built by combining specs, steering, and hooks with MCP. To take this to the next level, we are proud to announce remote MCP server support and one-click MCP installation — features that make working with Kiro and building apps just a little bit easier.

## Remote MCP Servers Explained

Remote MCP server support allows you to connect to MCP servers hosted on the internet instead of your local machine. The underlying specification is the same. Remote MCP servers still expose prompts, tools, resources, that you’re used to, but the protocol is different. Instead of using stdio, which you would use if you were connecting locally on your computer, you can now connect via Streamable HTTP.

Streamable HTTP handles client connections. It has the added benefit of using Server-Sent Events (SSE) to help stream multiple server messages. Streamable HTTP offers additional features including resumability, redelivery, session management, and backward compatibility. It’s worth noting that Kiro supports both Streamable HTTP as well as the deprecated HTTP+SSE transport protocols. With Kiro, you won't need to worry about these underlying technologies, everything just works.

## Using Remote MCP support in Kiro

While Kiro has always supported local MCP servers (or remote servers via proxy), it now has native support for remote MCP servers. With just a few steps, you can add a remote MCP server and start using it. If needed, you can add an authorization header or authorize directly via dynamic client registration. With dynamic client registration, Kiro will ask you to open a webpage to sign in and authorize.

Let's walk through adding a Notion MCP server with dynamic client registration.

**Step 1:** Open Kiro and from the Kiro panel navigate to the MCP servers section

**Step 2:** Add your remote MCP server configuration. After saving, you'll see a popup in the lower right corner to authenticate the server

**Step 3:** Click authenticate and allow Kiro to open the external website. After you sign in, you'll be able to use the Notion MCP server

## Securing MCP Connections

MCP servers often require API keys or authentication tokens. Hard-coding these in configuration files creates risk—they can accidentally get committed to version control or exposed in screenshots. Kiro now supports environment variables using the `${ENV_VAR}` syntax. Your credentials stay in your local environment, never in configuration files.

Here's an example connecting to a server that needs a Bearer token:

When Kiro detects a new environment variable, you'll get a security prompt to approve it. This prevents malicious configurations from accessing your environment without permission. You can manage approved variables in settings and revoke access anytime.

This keeps your credentials local, makes them easy to rotate, and prevents accidental exposure.

## Add servers with a single click

Adding MCP servers to Kiro is now easier than ever. With the new `Add to Kiro` button, you can install MCP servers with a single click. When you click the button, Kiro prompts you to approve the configuration, then automatically adds the server to your user config setup.

We've curated a [collection of sample MCP servers](/docs/mcp/servers/) to help you get started, including:

## Get Started Today

If you're like us and love MCP servers, you'll love our new features: remote MCP support, environment variables, and one-click MCP install. To get started, update to the latest version of Kiro and try these features today. Let us know what you think!

Check out the [remote MCP server documentation](/docs/mcp/configuration/) for more details, or browse the [sample servers](/docs/mcp/servers/) to find one to try.

### Specialized IDEs deserve AI too: Kiro adopts ACP

I'm excited to share that Kiro CLI now supports the Agent Client Protocol (ACP), which means you can use Kiro's agentic AI capabilities directly into other IDEs. IDEs that currently support ACP include Eclipse, Emacs, JetBrains IDEs, Neovim, Toad, Zed, and more. For me, this solves a real workflow problem that is important to me.

Let me be clear: Kiro is my daily driver for application development. The spec-driven workflows, hooks, and steering files have fundamentally changed how I build features. But here's the thing—when I'm deep in database work, I prefer a purpose build editor. The schema visualization, query execution plans, database-specific autocomplete, and connection management are purpose-built for SQL work. I don't want to configure database extensions in Kiro every time I switched projects or databases. Now, with ACP support, I can use Kiro in my preferred database management tool, JetBrians DataGrip.

## What is ACP?

The [Agent Client Protocol (ACP)](https://agentclientprotocol.com/overview/introduction) standardizes communication between code editors and AI coding agents. Think of it like LSP (Language Server Protocol), but for AI agents instead of language servers. Before ACP, every agent-editor combination required custom integration work. Agents only worked with specific editors. ACP changes this by providing a common protocol that any agent and any editor can implement. The practical benefit: agents that implement ACP work with any compatible editor. You pick your agent, you pick your IDE or ACP compatible application, and they just work together.

## Setting up Kiro in DataGrip

Getting Kiro running in DataGrip takes about two minutes.

First, make sure you have the [Kiro CLI](/cli/) installed. If you haven't already, check out the [installation instructions](/docs/cli/installation/) and make sure that you are [authenticated](/docs/cli/authentication/).

Next, open DataGrip and navigate to the AI Chat tool window. Click the menu button (three dots) in the upper-right corner and select "Add Custom Agent."

This creates or opens the `acp.json` configuration file at `~/.jetbrains/acp.json`.
Add the Kiro agent configuration:

Update the `command` path to match your Kiro CLI installation location. Save the file, and Kiro should appear in the AI Chat dropdown immediately.

## Using Kiro in DataGrip

Once configured, select "Kiro Agent" from the chat dropdown.

Here's where it gets interesting. You can ask Kiro to:

- Generate SQL queries and stored procedures
- Debug slow queries and suggest optimizations
- Write migration scripts and generate test data
- Explain complex joins and conditions

Kiro can execute shell commands, so you can run database CLI tools, export results, or trigger scripts—all from the chat interface. Terminal output displays directly in the IDE, and you stay in control of what gets executed.

The real win is combining DataGrip's database intelligence with Kiro's agentic capabilities. DataGrip knows your schema, indexes, and relationships. Kiro can reason about what you're trying to accomplish and help you get there faster.

## A quick demo

Let's say I'm working on a contacts database and need Kiro's help to design the schema. In the Kiro chat, I can describe what I need in plain English:

As you can see, Kiro generates the SQL, creates sample data and even a few sample queries for me to test (left). In addition, it describes the tables and relationships to help understand what it did (right).

For me, ACP is all about using the right tool for the job. For application code, Kiro remains my go-to. For database-heavy work, DataGrip with Kiro via ACP gives me the best of both worlds.

## Conclusion

ACP opens up possibilities beyond database work. Think about all the specialized IDEs developers use: Xcode, Android Studio, RStudio, or Jupyter. Over time, I hope to see ACP support, and Kiro, in all of these.

With ACP, you don't have to give up your AI coding assistant when you step into one of these environments. Kiro can come along, bringing its agentic capabilities to whatever specialized workflow you're in.

For me, it's DataGrip and SQL. For you, it might be something completely different.

So I'm curious—where would you use ACP to bring Kiro into your workflow? What's the specialized tool you can't live without? [Find me on Discord](https://discord.gg/kirodotdev). I'd love to hear what creative integrations people come up with.

### Kiro and the future of AI spec-driven software development

In the 1950s and 1960s, there was an explosion of innovation in programming languages. Programmers went from programming in assembly language and machine code, to writing programs in higher-level, portable, languages. Pioneers like John Backus, Jean Sammet, and Grace Hopper had the foresight to see what is now common knowledge: software is at the core of technology, and improving the speed and cost of software development would accelerate the rise of computing, and rise of the world’s economy.

These languages from the 50’s and 60’s were a revolution in programmer productivity, and in decoupling the behavior of programs from the underlying hardware. In the six decades since, programming has changed significantly, but one fundamental thing hasn’t changed: most mainstream programming languages describe how to do a task, rather than describing the task to be done. There have been many attempts to raise the level of abstraction programmers work at. Most that have tried to challenge the fundamental step-by-step nature of programming have failed. Those that succeeded have succeeded have been niche successes (including some very big niche successes, like SQL).

SQL is a great example: a SQL query describes the outcome the programmer desires (this data, in this form, from these places), and the database system figures out how to get it done. Low-level implementation choices, like data structures and algorithms, are abstracted away, or are chosen in declarative ways (“please make it efficient to retrieve data by this column”). Despite SQL’s near-ubiquity, it’s still generally only used to interact with database management systems, and not for general application development.

The 60-year-old fundamental paradigm of programming remains mostly unchanged.

Generative and Agentic AI are poised to bring about a new wave of change. For the first time, there are tools developers can use to translate common-sense descriptions of desired program behavior into real, working systems. Many developers are using these tools already. Prompt-by-prompt, step-by step, they describe the system they want to build to AI code generators. This *vibe coding* approach to development has already been proven to be a powerful tool. But its power is limited because it is missing one important piece: a full vision of the bigger picture of what a program should do, and why it should do that.

Enter *specification.*

A *specification* is simply a description of what a program should do, and what needs it should meet. Developers are used to working with specifications every day. The names and forms differ, from tickets, to requirements documents, to hallway conversations with colleagues. The languages differ too: from simple text descriptions, to UI sketches and mockups, all the way to formal mathematical definitions.

A specification is the bigger picture. It’s what those prompts are driving towards, step by step. It is, at its core, the whole point of the program a developer or team is building.

We built Kiro to make this bigger picture, spec-driven-development approach a reality. With Kiro, you can develop or improve programs prompt-by-prompt, or line-by-line. You can also zoom out to the specification level, and work with the IDE to generate, maintain, and act on changes to a specification that describes what you want your program to do. At this higher level, above all the implementation details, it’s easier to understand the purpose of a program, to make fundamental changes to its structure, and to think about and communicate the code’s overall goal.

Approaching development with specifications has three significant benefits. First, it provides a way for developers and stakeholders to understand and agree on the goals of the program. It’s crisp documentation on what we want the program to do, the interface to look like, and how it should be implemented. Working at the specification level allows programmers to move faster, and spend more time thinking about the things that really matter. Second, it provides a guide for AI agents to work from, refer to, and validate their work against. A North Star to guide the work of the agent, allowing it to take on larger tasks without getting lost. Third, the specification tames the chaos of prompt-driven vibe coding on large code bases, moving away from an ad-hoc exercise in prompt engineering, to way for programmers to crisply express their intent to agents. A specification is a kind of (version controlled, human-readable) super prompt.

## Let’s Play a Simple Game

To understand how this plays out in Kiro, let’s start off with a simple example of what a specification is, and how we can use one in our development process. I’ll build a small browser-based version of the classic Towers of Hanoi game.

We’ll start with a new directory, and a prompt:

Kiro will then go off and write out first version of the specification. Despite the fancy name, it’s simply a markdown file describing the user stories for this little game we’re building. We can pause now to change these stories, or go onto the design phase. Kiro will ask me when I’m done with the specification. When I am, I kick off the next phase by saying:

While this looks and feels like prompt-based development from the prompts, the ability to read and customize the user stories, the design, and the plan of tasks for the agent to do allows a deeper collaboration between developer and agent. It allows developers to be much more specific about particular details, and for the agent to communicate its plan ahead of time. By writing down those details along with the plan – as version controlled artifacts – Kiro’s approach changes AI-powered development from *vibe coding* to a real, durable, collaboration between the programmer and the AI development agent.

After a couple minutes, we end up here:

Cool! But this code doesn’t quite do what I wanted it to do in my head when I wrote the prompt. When I click *Auto Solve* it starts a new game rather than solving mine from where I am. In a traditional *vibe coding* approach, I could then prompt the required changes. Kiro gives me another option: add that requirement to the generated *requirements.md, *then request the changes. That way, the requested change is version controlled and written down. It doesn’t get lost as further changes are made. It also provides more space to write structured, specific, and precise text. This is the key power of Kiro’s approach. By writing things down, we make them long-lived, durable, and official. As I keep working with the agent, I know it still remembers all the things I care about (and has flexibility to change the things I don’t care about).

Concretely, making that change requires two new lines in *requirements.md:*

Kiro will make these changes for us, including creating a new task, and moving the code to match these new requirements. Crucially, as I add and remove other requirements from *requirements.md*, these new changes don’t get lost. From vibe coding, to repeatable, trackable, software development, powered by AI agents.

## Specification at the Heart of Development

At Amazon, we’ve been writing specifications for a long time, in many forms. We use a process called *working backwards*, creating documents like press releases and blog posts early in the life of a project to make sure we’re taking a customer-first view of what we’re building. We’ve long had the discipline of writing and reviewing design documents, both formal and informal, specifying the design and behavior of the systems we’re building. One of the most important functions of our principal engineering community is writing and reviewing these documents. We also use [more formal specification](https://cacm.acm.org/practice/systems-correctness-practices-at-amazon-web-services/), where we write down properties of our systems with mathematical precision (using languages like TLA+ and P), allowing us to prove important properties of our systems, and automate testing1.

We spend this time on specification because we think it help us move faster, by making it more likely we’re writing the right code to solve the right customer problem. It reduces back-tracking by keeping a record of the decision we’ve made and why. It communicates to developers and stakeholders what’s truly important in a design.

Kiro’s specifications build on our experiences here. That doesn’t mean they’re complex (they’re simple markdown documents), or only built for large companies (you can make a specification as formal or informal as you’d like). But we believe deeply in the core value of writing down what we’re doing. We think it makes us better, more effective, and more efficient, developers.

## Conclusion

When the precursors to today’s mainstream programming languages were being created, back in the 1950s and 1960s, they stretched the limits of the technology of the day. They raised the level of abstraction from the assembly and machine code level to a much higher one, made of statements and functions that can convert into hundreds of machine instructions. But the technology back then didn’t allow raising the level of abstraction further. Many attempts have been made to raise the abstraction from *step-by-step* to *what do you want done? *ranging from the esoteric (like Datalog) to the mainstream-but-niche (like SQL).

I believe that Kiro’s *specification *approach is an important and powerful step towards a future of programming where outcomes matter more than implementation details, and where implementing programs that solve complex problems is easier and more accessible. Where we can focus more on what we want to do, and less on how we want to do it. More immediately, it’s a significant step towards taming the chaos of *vibe coding* without losing the power and productivity that AI agent-assisted coding brings.

### This is Kiroween

It's finally here! This Halloween, we're kicking off our first-ever [Kiroween hackathon](http://kiroween.devpost.com), our annual challenge designed to inspire wild, creative ideas that would be difficult to bring to life with traditional tooling. We are awarding $100,000 across 12 different prizes and 66 winners, with a 1st place prize of $30,000. Come experience how Kiro's agentic capabilities like specs, agent hooks, steering, and MCP can push the boundaries of what is possible. We can't wait to see how Kiro can empower you, whether you're a seasoned developer, a startup founder, a designer, or a tinkerer.

[Register on Devpost](https://kiroween.devpost.com/)

**Note:** We will be providing supplemental Kiro usage to participants equivalent to the Kiro Pro+ tier throughout the submission period. Once you register for Kiroween, you will receive a confirmation email with detailed instructions on how to receive the benefits. Our priority is making sure you have the resources to meaningfully build and experiment with Kiro.

## Dare to code in dark mode

The challenge is to build a working app using Kiro, inspired by a set of spooky categories to get you in the Halloween spirit. We wanted to keep these open-ended so you can build what excites you the most, and inspiring enough to bring out some really cool and unique app ideas:

- Resurrection: Bring your favorite dead technology back to life. Reimagine obsolete tech with today’s innovations or solving tomorrow's problems.
- Frankenstein: Stitch together a chimera of technologies into one app. Bring together seemingly incompatible elements to build something unexpectedly powerful.
- Skeleton Crew: Build a skeleton code template lean enough to be clear but flexible enough to support various use cases. Show us its versatility with two distinct applications from your foundation.
- Costume Contest: Build any app but show us a haunting user interface that’s polished and unforgettable. Bring in spooky design elements that enhance your app’s function.

## Plus, a startup flavor

We’ve added a new prize category for Kiroween that awards $10,000 to the Best Startup Project (see [full rules](http://kiroween.devpost.com/rules) for submission details). We want to provide startup founders a chance to rapidly prototype and develop concepts that would typically require significantly more resources. Kiro's ability to accelerate development cycles means you can test more ambitious ideas, with faster iterations, and emerge with a compelling product —all within the hackathon timeframe.

## The deets

**Key dates:**

- Launch: Friday, October 31, 2025, 9am PT
- Submission Deadline: Friday, December 5, 2025, 2pm PT

**Prize pool:** A total of $100,000 in prizes awaits, including category winners, overall winners, and special bonus prizes for creativity, social engagement, and more.

**Judging criteria:** Your submission will be evaluated by a panel of expert industry judges, including [Ania Kubow](https://x.com/ania_kubow), [Santiago Valdarrama](https://x.com/svpino), [Rachel Stephens](https://www.linkedin.com/in/rachelstephens), and more. Each app will be assessed based on:

- Potential Value: How useful, accessible, and impactful is your solution?
- Implementation: How effectively did you leverage Kiro's capabilities?
- Quality and Design: How creative, original, and polished is your project?

**Submission Requirements:** You'll need to provide your public code repository with the `.kiro` directory (showing how you used specs, hooks, and steering), a functional application URL, a 3-minute demonstration video, and documentation on how you utilized Kiro throughout your development process that shows us your next-level understanding of its features, such as:

- Vibe coding: How did you structure your conversations with Kiro to build your project? What was the most impressive code generation Kiro helped you with?
- Agent hooks: What specific workflows did you automate with Kiro hooks? How did these hooks improve your development process?
- Spec-driven development: How did you structure your spec for Kiro to implement? How did the spec-driven approach improve your development process? How did this compare to vibe coding?
- Steering docs: How did you leverage steering to improve Kiro’s responses? Was there a particular strategy that made the biggest difference?
- MCP: How did extending Kiro’s capabilities help you build your project? What sort of features or workflow improvements did MCP enable that otherwise would have been difficult or impossible?

[Register on Devpost](https://kiroween.devpost.com/)

## Discord is the place to be

The [Kiro Discord](https://discord.gg/kirodotdev) awaits with a dedicated `#kiroween-hackathon` channel where you can connect with fellow participants, form teams, share ideas, and get support from other developers and Kiro team members. Our community is ready to help you navigate challenges, offer feedback, and celebrate your progress along the way. We also have bi-weekly office hours where you’ll be able to ask questions in real time to our product experts. Beyond the hackathon, you’ll find project spotlights, product announcements, event updates, and other news and resources regularly shared. See you there?

## Ready to git commit to the darkness?

Kiroween was designed for Kiro developers as a fun opportunity to experiment with Kiro and leverage the full gamut of features and capabilities it offers. This is your moment to create something unforgettable. Get inspired by Kiroween’s special spooky factor, summon your ideas, and git commit to the darkness.

[Register on Devpost](https://kiroween.devpost.com/)

Let’s connect - tag @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev), and share updates on your progress using hashtag #codewithkiro

### Making your Kiro credits go further

Kiro’s Auto agent is now more efficient, letting you do more with your credits while maintaining the same high quality you expect from Kiro.

## More efficient Auto agent

Our goal with Kiro is to give you the best results at the best price. To achieve that, earlier we built Auto, an agent that uses a mix of different frontier models, such as Sonnet 4.5, combined with specialized models and optimization techniques such as intent detection, caching, and more. We hold a high bar for the quality of Auto, accepting nothing less than what a frontier model would provide. On 11/7, we shipped a new version of Auto, resulting in a substantial reduction for the credits you’re consuming for your requests. For typical everyday requests, customers saw a 21% reduction in credits used. For customers with the most demanding and complicated requests, they're using 36% less.

What does this mean for your day-to-day development? A typical request that previously used 1 credit now uses 0.79 credits. That means the existing credits on your Kiro plan can now accomplish around 20% more, giving you a longer runway for your development work for the same credits. Kiro user Andres Moreno, Principal Architect at Caylent and AWS Community Builder, said “I've definitely felt Kiro using fewer credits per request. It's been really nice, and it's also been super fast.”

If you're already using Auto, you're already realizing these savings. If you haven't tried Auto yet, now is the perfect time to start! And this is only the beginning. We're working on exciting improvements to Auto, including neuro-symbolic AI that combines neural networks with formal reasoning. These advances will help you write better requirements, validate implementations more effectively, and produce higher quality code all while keeping your credit usage efficient.

### Multi-root Workspaces in Kiro: Work Across Projects, Not Just Inside One

## What’s a Multi-root Workspace?

Normally, a Kiro workspace is tied to a single project folder:

But - what if you’re working on `my-app` and a shared library that it depends on at the same time? Or managing multiple microservices? Or a monorepo with a bunch of packages? That’s where multi-root workspaces come in, and you can try them out today!

With multi-root support, you can bring multiple folders into a single Kiro IDE window. This way, each stay independent, but they can all work together:

This way, you don’t need to worry about merging or symlinks, and you get clean side by side access.

## Why Use This?

Multi-root is a good idea when:

- You’re editing a feature in your app that requires changes to a shared library
- You’re maintaining multiple related services (eg frontend + backend + auth)
- You’re using git submodules or workspaces (like npm/yarn/pnpm workspaces)
- You want to search, navigate or refactor across several projects at once.

Instead of DM’ing your teammates asking for workarounds, or figuring out how to keep multiple versions of Kiro open at the same time, you can now keep all of your context in sync in one workspace for your project. This makes it easier to work on tasks that span multiple roots with Kiro.

## How Do You Set It Up?

There are 2 options, and they’re both easy:

1. File → Add Folder to Workspace... → choose the folder
2. Drag and drop a folder into Kiro

Kiro will then recognize each folder as a root and start loading the `.kiro` config files from each root.

## How Kiro Handles Multiple Roots

Each root keeps its own identity, but Kiro brings it all together for you.

### Specs: One List, Multiple Sources

All of your steering files appear in one list under ‘Workspace’ in the Agent Steering panel, and each one shows which root it comes from. When you make a new steering file, Kiro will give you 3 options:

- my-app agent steering - Applies only within that specific workspace
- Global agent steering - Applies across all workspaces
- Foundation steering files - Auto-create foundation files to establish core workspace context.

Steering files with the “Always Included” directive are always loaded, regardless of the specific root folder the agent is working on. However, those with a “Conditional Inclusion” directive are loaded only if the agent is working on a file defined in that same root.

For multi-root workspaces, you’ll typically want the first option so your steering stays organised.

### Agent Hooks: Scoped to Their Home

Hooks are listed together, but each is tied to its root. So, a hook shared in `shared-ui/.kiro/hooks/` will only trigger when files in `shared-ui` change, which keeps everything nice and contained.

### MCP: Unified, but with Rules

All MCP server definitions from each root are loaded at startup. If 2 different roots have MCPs with the same name, the one from whichever root appears last in your workspace folder ‘wins’. So, make sure you’re being strategic and careful with MCP names to avoid conflicts. Use prefixes like `frontend-github` and `backend-github` instead of just `github`. Then, when you open up the MCP config, Kiro will prompt you to pick which root’s config you want to look at.

### Codebase Search & Context

`#codebase` searches across all roots, and Kiro automatically indexes source code, docs and config files from every root folder in your workspace. When you use `#file` and there are duplicates (eg `utils/logger.ts` in 2 roots), Kiro will show you a list with full paths so you can make sure you pick the right one. If you want even more control, you can use line ranges to focus context, like `#file:src/index.ts:10-25`.

## Real-World Example: Cross-Project Workflows

Imagine this scenario:

> Update the Button component in shared-ui, then update my-app to use the new variant prop.

With multi-root workspaces in Kiro:

1. Open both my-app and shared-ui in one workspace
2. Ask Kiro: 
Loading code example...
3. Kiro works across both roots in one conversation when you need to update code, run hooks or work with specs.

This all happens in one flow, so you don’t need to switch windows or make separate conversations.

## Ready to Try it?

Make sure you’re updated to the latest version of Kiro, then just drag another project folder into your Kiro window, then you’re ready to roll! Want to see what’s new in Kiro? Check out our [General Availability Launch Blog](/blog/general-availability/), and the [Changelog](/changelog/).

### Multimodal development with Kiro: from design to done

Software architecture and engineering is both an art and a science. We craft elegant designs that solve complex problems, but somewhere between the initial design and final deployment, that vision can get lost in translation. If you’re like most developers and architects, you have experienced this firsthand. You spend hours perfecting system diagrams, only to watch the implementation drift away from your original design. Requirements change, developers interpret your diagrams differently, and before you know it, your elegant architecture becomes a patchwork of compromises that are outdated before it even gets deployed.

Traditional systems development is broken. The gap between diagrams and deployed code wastes time, creates technical debt, and delivers systems that miss the mark. But it doesn't have to be this way.

I recently tackled this challenge head-on while building a financial trading system with Kiro. This is the kind of project where architectural missteps mean real money lost and potential compliance nightmares. Instead of the traditional weeks spent translating ERDs (Entity-Relationship Diagrams) into database schemas and UML (Unified Modeling Language) diagrams into service interfaces, Kiro's multimodal agent chat transformed my whiteboard sketches into production code in days, not weeks.

Let me show you how Kiro's ability to process visual diagrams alongside code and documentation changed everything – and how it can transform your development process too.

## From whiteboard photo to TypeScript models

I started where most projects begin - with a whiteboard and a few markers. The ERD I sketched showed the core entities of a financial trading system: users connected to accounts, which hold positions and execute orders that become trades, all fed by real-time market data.

This is where Kiro's multimodal capabilities shine. Instead of manually translating my diagram, I uploaded a photo of my whiteboard directly to Kiro and started a conversation about what I wanted to build.

Kiro didn’t just see an image; it understood the entities, relationships, and business logic represented in my hand-drawn diagram. Within minutes, it analyzed the visual input and created comprehensive specifications that captured not just what I had drawn, but the implied requirements for a real financial trading system.

The visual diagram provided Kiro with the structural context, and through our chat conversation, I could add business nuances that no diagram could capture. We discussed compliance and regulatory requirements, latency expectations, and security considerations. With each interaction, Kiro updated the specifications while maintaining perfect alignment with my original visual design.

Here’s where Kiro’s multimodal approach proves its value. Kiro took my ERD and generated actual TypeScript models that corresponded to my whiteboard sketch. The generated code wasn’t just syntactically correct – it included business logic, relationships, and constraints that were implied in my original diagram. Entities like User, Account, Order, Trade, and Position became fully formed TypeScript classes with proper validation, relationships, and methods.

Looking at the generated classes and database schema I asked Kiro to create along the way, I could see how the simple ERD I drew on a whiteboard had evolved into a production-ready system. Additional object types and relationships were uncovered that I hadn’t initially considered: audit trails, user permissions, portfolio hierarchies, and regulatory compliance fields that are essential for a real financial trading system.

## From architecture discussion to infrastructure diagram

Based on our conversation about scalability, security, and deployment requirements for a financial trading system, Kiro created a comprehensive cloud-agnostic Kubernetes architecture. Along with this plan, Kiro created documentation that included a Mermaid diagram to visualize the system architecture. While the diagram was informative, I requested Kiro to convert it to an SVG format to enhance readability and allow for better scaling across different viewing platforms.

Kiro’s architectural design addressed the specific performance and compliance constraints of financial trading systems. Low-latency trading services were deployed on dedicated node pools, featuring CPU pinning and optimized networking configurations. The data layer achieved high availability through PostgreSQL and TimescaleDB running in StatefulSets distributed across multiple availability zones. Event-driven messaging used Kafka for order processing and real-time market data streaming, while comprehensive security implemented network policies, pod security standards, and HashiCorp Vault for secrets management. The system was designed with regulatory compliance in mind through immutable audit logging, data residency controls, and automated compliance monitoring.

Kiro understood that a financial trading system needs portability across deployment environments. The architecture it designed runs on AWS EKS, Google GKE, Azure AKS, or on-premises Kubernetes clusters without modification, incorporating industry best practices for containerized applications while remaining cloud-agnostic.

This architecture diagram then became the input for the next phase. Using both the visual Kubernetes architecture and our discussion context, Kiro generated complete Kubernetes manifests that implemented our architectural decisions. The generated infrastructure as code (IaC) included namespace organization with proper labeling for compliance and environment management, service deployments with anti-affinity rules and resource limits optimized for each component, and StatefulSet configurations for databases with persistent volume claims. Network policies implemented micro-segmentation between services, while Horizontal Pod Autoscalers with custom metrics managed for financial workloads. All of this was secured following Kubernetes best practices.

The generated Kubernetes resources included production-ready configurations such as pod disruption budgets, resource quotas, and monitoring annotations. Kiro translated our high-level architectural conversation into deployable infrastructure that followed cloud-native best practices while meeting the specific performance and compliance requirements of financial trading systems.

## The multimodal advantage and results

What made this approach so powerful wasn’t just that Kiro could process images; it was that Kiro could simultaneously understand visual diagrams, maintain context from our conversations, reference the generated code files, and provide consistency across all these different input types while challenging me to think beyond implementation details.

Traditional AI development tools would have required separate interactions for each phase: one tool to interpret diagrams, another to generate specifications, a third for code generation, and yet another for infrastructure planning. Each handoff would have lost context, created inconsistencies, and required manual reconciliation. The result would have been weeks of additional development time and significant churn as each tool's output diverged from the original design intent.

Kiro's agent-based approach maintained traceability throughout the entire development process. After three days and roughly 15 hours of development time, I had a nearly complete financial trading system that matched my original visual design. The generated code directly reflected the entities and relationships I had sketched, while incorporating all the additional complexity discovered through our conversations. Each phase informed the next while maintaining traceability back to my original whiteboard sketches, and Kiro worked alongside me to solve complex engineering problems around compliance, performance, and scalability with confidence.

Most importantly, Kiro's agents didn't just generate code; they challenged architectural decisions, suggested improvements for regulatory compliance, and identified potential performance bottlenecks that I hadn't initially considered. This collaborative approach helped preserve the initial design vision throughout the enhancements we made, rather than lost in translation across multiple disconnected sessions and tools.

## The future is multimodal

This experience showcases what's possible when AI agents can truly understand and process multiple types of input simultaneously. From whiteboard photos to generated code, from architecture diagrams to infrastructure configurations – each step builds upon the previous while maintaining design integrity.

If you're tired of watching your beautiful designs become disconnected implementations, try multimodal development. Start with a hand-drawn diagram, upload it to Kiro, and let it understand your visual design and help you maintain that integrity all the way to production. The future isn't about choosing between visual design and code generation; it's about AI that can seamlessly work with both, ensuring your original vision makes it to production intact.

Ready to streamline your journey from diagrams to deployment? [Get started with Kiro](/downloads/) for free and experience multimodal development for yourself! Upload your own diagrams and experience the seamless transition from visual design to working code.

Share your experience with us on [X](https://x.com/kirodotdev) or [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), and join our [Discord community](https://discord.com/invite/kirodotdev) to connect with other developers using multimodal development to transform their workflows.

The gap between design and implementation doesn’t have to exist anymore. With multimodal AI, your diagram can become your code, and your vision can become reality faster and more accurately than ever before.

### Announcing new pricing plans and Auto, our new agent

*Starting October 1st, you will be charged for the plan you’ve selected. The list of countries and regions in this post is out of date and no longer maintained. Please *[see our FAQs](https://kiro.dev/faq/#what-countries-or-regions-are-supported-for-individual-plans)* for the latest list.*

---

Over the past month, you have provided us with great feedback on Kiro. Based on your feedback and looking at usage patterns to understand how you’re using Kiro in your day-to-day development work, we are announcing a new and revamped pricing for Kiro.

- Unified Limits: Instead of separate limits for vibe and spec tasks, all requests will now draw from a single credit pool, giving you flexibility and control in how you use Kiro. The new unified limits are as follows:

| Free | Pro | Pro+ | Power |
| --- | --- | --- | --- |
| $0 | $20 / mo | $40 / mo | $200 / mo |
| 50 credits | 1,000 credits | 2,000 credits | 10,000 credits |
|  | Pay-as-you-go overages ($0.04 / credit) | Pay-as-you-go overages ($0.04 / credit) | Pay-as-you-go overages ($0.04 / credit) |

- Fractional Credit Consumption: Credits will now be charged fractionally, based on the complexity of the prompt. Simple edits and prompts can consume less than 1 credit, and by charging you in 0.01 credit increments, you can maximize your credit usage.
- Free Trial: When you get access to Kiro for the first time, you get 500 bonus credits usable within 14 days; more in the FAQs.

Tasks consume credits at different rates based on complexity. See FAQs below for more on how credits work. We have also improved the visibility of credit consumption in the monthly usage dashboard. In the coming weeks, Kiro will also display how many credits it consumed in the notification bar, so you can easily see how you’re tracking against your monthly limits.

## Introducing Auto

One of the key things we learned about how you want to use Kiro is that prompts differ widely in complexity and output requirements. Our goal with Kiro is to give you the best results at the best price. To achieve that, we’ve built Auto, an agent that uses a mix of different frontier models such as Sonnet 4 combined with specialized models, and optimization techniques such as intent detection, caching, and more.

Auto will always be optimized for performance, efficiency, and output quality. For example, a given task that consumes X credits to execute in Auto, will cost you 1.3X credits to execute via Sonnet 4. This combination of cost-effectiveness and Sonnet 4-level quality is why we have made Auto the default option in the chat window. You can still choose to run your prompts exclusively through Sonnet 4, and if you do, the stated plan limits above won’t get you as far.* *The current version of Auto is just the start. We are excited about some of the innovations we’re working on for Auto, such as using neuro-symbolic AI (which combines neural networks with formal reasoning) to help produce better quality output for tasks such as writing and refining your requirements and validating the implementation. We think you will appreciate how well the Auto handles your everyday requests in a more performant and cost-effective manner.

## Pricing roll-out

Between now and October 1st, we will gradually roll out updated plans with single pool of credits and new limits to paid users. Once migrated, you will notice your limits reset to the new monthly plan limits. Kiro continues to be free through September 30th. Starting on October 1st, you will be charged for the plan you’re on. For more details, see FAQs below.

We hope these pricing changes will make a difference in how you can use Kiro as your main development environment. We look forward to seeing what you build — and please keep the feedback coming by [joining our Discord](https://discord.gg/kirodotdev).

## FAQs

##### How does Kiro pricing work?

Kiro offers flexible pricing tiers designed around how developers use Kiro. New users can start with the perpetual **Kiro Free** tier, which includes 50 credits. You can upgrade to paid tiers ranging from Pro ($20/month), Pro+ ($40/month), to Power ($200/month) for increased capacity. Paid tiers include flexible overages available at $0.04 per additional credit. Kiro prices shown do not include applicable taxes or duties (such as VAT or sales tax) unless explicitly noted. Note that if you have a Japanese billing address, Japanese Consumption Tax will apply to your Kiro usage. The amount of tax collected depends on many factors, including, but not limited to, your Tax Registration Number (“TRN” or Tax ID), and billing address.

##### What is a credit?

A credit is a unit of work in response to user prompts. Simple prompts can consume less than 1 credit. More complex prompts, such as executing a spec task, typically cost more than 1 credit. Additionally, different models consume credits at different rates, with a prompt executed via Sonnet 4 costing more credits than executing it with Auto. For example, a given task that consumes X credits to execute in Auto, will cost you 1.3X credits to execute via Sonnet 4. Credits are metered to the second decimal point, so the least number of credits a task can consume is 0.01 credits.

##### What can I use credits for?

Any prompt you ask Kiro to execute, whether in vibe mode or spec mode, as well as spec refinement, task execution, and agent hook execution, will consume credits.

##### How can I track my credit usage?

You can see the monthly credit limits for your plan, the number of credits used, and credits remaining in your subscription dashboard accessible in the Kiro IDE. Credit usage is updated at least every 5 minutes.

##### Can I pay for additional credits?

Yes, on paid plans, you can enable overage to continue using Kiro past your monthly limits. Additional credits are $0.04 each, billed at month-end based on actual over-cap usage. For example, if you're on the Pro tier and use 1,100 credits (100 over your limit), you'll be charged an additional $4 on your next bill. Overage is disabled by default and must be enabled in Settings before it applies. Once you turn overages on, and for as long as you remain on a paid plan, overages stay on. Once you downgrade to the **Kiro Free** tier, overages will be disabled, and you need to turn them back on when you are back on a paid plan.

##### How is pricing being rolled out?

Between now and October 1st, we will gradually roll out updated plans with single pool of credits and new limits to paid users. Once migrated, you will notice your limits reset to the new monthly plan limits. Kiro continues to be free through September 30th. Starting on October 1st, you will be charged for the plan you’re on.

If you are on a paid plan, you can also turn on overages. Overages are also free until September 30th.** **Until, October 1st, overages are capped at 1,000 credits and will be reimbursed by October 1st.

If you are a new user subscribing to Kiro between now and October 1st, you will be refunded for your use by October 1st and can use your monthly limits fully. For example, if you purchased a Pro+ plan on September 20th, you could use all 2,000 monthly credits for free by September 30th.

##### How does the free trial work?

Starting on October 1st, if you get access to Kiro for the first time (off the waitlist), you will receive 500 bonus credits usable within 14 days, whatever plan you sign up for, including Kiro Free.

##### Can I share my Kiro subscription with my team?

No, subscriptions and usage limits are calculated per individual user. For team usage, each developer needs their own subscription. Team billing and management features are coming soon.

##### What happens if I don’t use all my monthly limit?

Usage limits reset at the start of each billing month. Unused credits do not roll over to the next month.

##### What models does Kiro use under the hood?

By default, your prompts are processed by Auto an agent that uses a mix of different frontier models such as Sonnet 4 combined with specialized models that are experts in specific tasks, intent detection, caching, and other techniques to give you a better balance of quality, latency, and costs. You can also choose to have your prompts processed exclusively by Sonnet 4.

##### What payment methods do you accept?

We accept all major credit cards.

##### Which countries or regions are supported for the paid plans?

Currently, you can purchase a Kiro paid plan with a billing address in Argentina, Australia, Austria, Bangladesh, Belgium, Brazil, Bulgaria, Canada, Chile, China, Colombia, Czech Republic, France, Germany, Hong Kong SAR, India, Indonesia, Israel, Italy, Japan, Malaysia, Mexico, Morocco, Nepal, Netherlands, New Zealand, Norway, Philippines, Poland, Portugal, Romania, Singapore, South Africa, South Korea, Spain, Sweden, Switzerland, Thailand, United Arab Emirates, United Kingdom, and the United States of America. More countries or regions will be added soon.

### Introducing the Kiro startup credits program

*Applications for startup credits have closed due to high demand. We are still reviewing applications on a rolling basis. Stay tuned for updates.*

---

Look, we get it. Moving from "hey, this prototype is pretty cool" to "woah, we can go from vibe coding to scaling a production app without breaking any code?" That's the startup struggle Kiro seeks to solve. Kiro transforms your "wouldn't it be cool if..." prompts into clear requirements, solid designs, and implementation tasks bringing structure to your AI coding workflows. No more crossing your fingers needing to worry if your code will break as your projects become more complex.

With Kiro, you can easily transition from vibe to spec mode and quickly bring your ideas from prototype to production. What’s more? Built and operated by AWS, Kiro benefits from the same security, reliability, and privacy standards and controls trusted by millions of customers. We're committed to making Kiro accessible for startups and so... we're dropping something **huge**.

## Introducing Our Kiro Pro+ Startup Credits Program

Starting today until December 31, 2025, we're giving qualifying startups credits for up to **one full year** of Kiro pro+ tier access to all our premium features. Available in most countries globally, we're offering three credit packages:

- 🌱 Starter Tier: Up to 2 Kiro users
- 🚀 Growth Tier: Up to 50 Kiro users
- ⭐ Scale Tier: Up to 100 Kiro users

We kept the application process simple. Fill out our form. If you're approved, you'll hear back from us, and credits automatically appear in your AWS account. Please note, if you select a plan greater than Kiro Pro+ upon receiving credits or exceed the number of users, you may be charged additional fees once credit allocations are exhausted.

## An Optimized Way to Build for Startups

We know startups thrive on speed and agility, but this often comes at the cost of organization. Kiro helps bring structure to the inevitable chaos of startup life. Built from the ground up for working with AI agents, Kiro gives you the best tool for the job in a fresh development experience that still feels familiar. You can use multimodal chat, and scale and automate tasks with agent hooks. And with specs, steering, and smart context management, Kiro understands the intent behind your prompts and helps you implement complex features on larger codebases, in fewer shots.

## What We Need from You

To access your Kiro Pro+ credits, you’ll need to:

- Be somewhere between "we have an idea and some funding" and Series B VC-backed
- Have an AWS account that matches your business domain
- Apply with your real business email

## Why We're Doing This (Spoiler: We Believe in You)

This isn't just about giving away free stuff. We want to invest in the next wave of companies that are going to build the future. The startup credits program is our bet on ambitious teams like yours.

## Ready to Build the Future with Us?

Applications for startup credits have now closed due to high demand. We are still reviewing applications on a rolling basis. Stay tuned for updates. [Learn more](/startups/). Credits expire one year after they're added to your account.

*Build faster, scale smarter, and have some fun along the way. The future of spec-driven development for AI coding is here, and we're making it accessible to everyone with big dreams and bigger ambitions.*

## Connect with Us

Share what you’re building with us using hashtag **#KiroforStartups** or **#BuildwithKiro** - we’re @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev)!

Join our [Discord](https://discord.gg/kirodotdev) community and hear from other founders, developers, and Kiro experts directly. Have questions about the startup credit program or AWS Activate? [Submit a ticket ](https://aws.amazon.com/startups/contact-us/)to reach the AWS Activate Support Team.

### Opus 4.6 is now available in Kiro

Starting today, you can use Claude Opus 4.6, Anthropic’s newest SoTA model, in the Kiro IDE and CLI. Opus 4.6 is Anthropic’s most powerful model yet and also the world’s best model for coding.

Opus 4.6 maintains everything you love about 4.5, while expanding its coding capabilities to become the best model for production code and sophisticated agents. It excels on large-scale codebases and long-horizon projects, helping senior engineers complete multi-day projects in hours by delegating complex tasks to Opus 4.6 with less oversight.

We see Opus 4.6 as the strongest model for Kiro’s spec-driven development workflows. With Opus 4.6 under the hood, Kiro is able to create detailed but precise specs on top of large existing projects, making updates with surgical precision with minimal user input.

Opus 4.6 is available [with experimental support](/docs/privacy-and-security/data-protection/#global-cross-region-inference-for-experimental-features) to all Kiro Pro, Pro+, and Power customers, logging in with Google, GitHub, AWS BuilderID and AWS IAM Identity Center. Opus 4.6 is available in the AWS US-East-1 (Northern Virginia) region, and features a 2.2x credit multiplier, the same as Claude Opus 4.5.

[Download Kiro](/downloads/) or restart the app or CLI to use the new model.

### Kiro pricing plans are now live

*Read our *[latest blog post](/blog/free-until-september-15/)* on billing and pricing.*

---

Over the past few weeks, we have shared [several](/blog/pricing-waitlist-updates/) [important](/blog/understanding-kiro-pricing-specs-vibes-usage-tracking/) Kiro pricing updates. We made these updates to our pricing model in response to your feedback. Many in our community have asked for a way to use Kiro above and beyond the daily preview limits, while others have been eager to get off the waitlist and try Kiro for themselves. We’re making pricing plans available today, which means we can accelerate onboarding of all Kiro enthusiasts already on our waitlist, and give existing users more control over their Kiro usage.

## What this means for you

As of today, users logging in with Google, GitHub, or an AWS Builder ID account without a Q Developer subscription have been transitioned to our new pricing model. Those accounts are now on the Free tier, which includes 50 Vibe requests per month and 0 Spec requests.

We're also introducing a welcome bonus of 100 Spec requests and 100 Vibe requests for all users. This bonus is available within the first 14 days of usage on the new pricing plans, and starts counting from your first request, regardless of which tier you're on. This gives you time to experience Kiro's full capabilities and figure out your usage needs.

When you're ready to upgrade, you have three paid options:

## Monitoring your usage

You can monitor month-to-date usage against plan limits for both Vibe and Spec requests, track overage charges if enabled, and manage your subscription plan. Check out the Kiro documentation for more details.

## Upgrading your plan

When you’re ready, upgrading is simple:

1. Click your profile icon in Kiro and choose "Upgrade Plan"
2. Select your preferred plan (Pro, Pro+, or Power)
3. Enter your payment details and your new plan activates immediately

You can upgrade, downgrade, view your billing history, or update payment details at any point, and changes are immediate.

Not sure which plan to choose? Here is our recommendation:

- Getting started: Choose Pro and enable overages for flexibility while you learn your usage patterns.
- Known usage patterns: Choose the smallest plan that covers your typical monthly usage with some buffer.
- Fixed costs: Select the plan that covers your peak usage and disable overages. Usage pauses at your monthly limit and resets the following month.

## Important: make sure you upgrade to v0.2.13 or newer to get started

To access the new usage dashboard and manage your plan, [upgrade to Kiro v0.2.13 or newer](/downloads/) by clicking the settings icon in Kiro and choosing "Check for updates...".

## Questions and feedback

For detailed pricing questions, check our updated pricing FAQ and [documentation](/docs/), or read our [recent blog post about the subscription model](/blog/understanding-kiro-pricing-specs-vibes-usage-tracking/). Join our [Discord community](https://discord.gg/kirodotdev) to share feedback, ask questions, and see how other developers are using Kiro.

Get started with the new pricing tiers by updating to Kiro v0.2.13, exploring your usage dashboard, and selecting the plan that fits your development needs.

### Kiro pricing update + waitlist invites coming soon

*Updated on August 15: The two-week free trial bonus for new users includes 100 spec requests and 100 vibe requests.*

*Read our *[latest blog post](/blog/free-until-september-15/)* on billing and pricing.*

---

We're grateful for the incredible interest in Kiro! The community feedback has been amazing, and one thing is clear: you all want more. Those of you following along but still on the waitlist want a chance to test Kiro for yourselves, and those of you already using Kiro want more control over how much you can access. That's why we have two updates for the community that get to the heart of this:

1. Waitlist invites are starting: Beginning next week, we'll onboard waitlisted developers, giving more of you the opportunity to experience Kiro firsthand.
2. New pricing tiers are coming: Based on what we've learned from early preview users about their workflows and needs, we're introducing pricing tiers later this month, giving you the option to invest in additional capacity or continue using Kiro for free.

**Waitlist Update**

Thank you for your patience - we're almost ready to start sending invites! Next week, we'll begin emailing sign-up codes to those on our waitlist. You'll be able to use these codes to onboard and experience everything Kiro has to offer. When pricing tiers go live later this month, you'll automatically get access to our two-week free trial giving you plenty of time to explore how Kiro fits into your development workflow before deciding on a pricing tier. We’re working through our waitlist as quickly as possible.

**Pricing Update**

Our preview period helped us better understand real-world usage patterns, leading us to structure our pricing in alignment with developer needs around Kiro's two core actions: **Spec **and **Vibe**. We've seen developers do amazing things with Specs—they've been able to accomplish tasks that often take many vibe interactions to get right. This highlights Kiro's primary value: a spec-driven development approach where developers generate requirements and design specs, then execute them task-by-task to create production-ready code—all powered by Claude 4 Sonnet. The second way developers build with Kiro is through "vibe," our agentic chat experience for those who prefer a familiar, conversational approach to building with AI agents.

Building on these insights and usage patterns, we’ve created pricing tiers that support developers and teams at every stage of their journey with Kiro. Whether you're just starting with AI development or leading a large team building complex applications, our pricing model  is designed to support your growth from free trial through enterprise-level usage. This new structure was shaped by observing how developers work, creating a more intuitive experience for our growing community. The highlights:

- Two-Week Free Trial: All new users receive a two-week trial with access to both Vibe (50 requests with 100 request bonus) and Spec (100 request bonus), ensuring everyone can experience Kiro's complete feature set.
- New Tiered Structure: We're introducing a more flexible tiered system, including Free, Pro ($20/month), Pro+ ($40/month), and Power ($200/month) plans, allowing developers to choose the tier that best fits their needs.
- Separate Allocations for Vibe and Spec requests: Recognizing the distinct ways developers use Kiro's Vibe and Spec features, we're providing separate allocations for each in our paid tiers.
- Perpetual Free Tier: We're maintaining a free tier with access to 50 monthly Vibe requests, allowing developers to continue exploring Kiro's capabilities without cost barriers.
- Flexible Overages: Additional usage is available for all paid tiers at $0.04 per Vibe request and $0.20 per Spec request, ensuring you never hit a wall when you need Kiro most.

Vibe requests include chat-based interactions like code explanations and bug fixes, while Spec requests cover executing tasks within Kiro's structured development workflow. We'll continuously evaluate usage patterns and may adjust limits to better serve our community, always prioritizing our users' needs.

**A Note to Our Existing Preview Users**

Thank you to everyone who's been part of Kiro's free preview since launch. Your feedback on GitHub and Discord has been invaluable in shaping not just our pricing model, but the entire Kiro experience. We hope you've been enjoying building with Kiro over these past few weeks.

You can continue using Kiro for free over the next few weeks. Later this month, you’ll have the option to either select a paid tier for increased capacity or continue with the Free Tier.  We've designed these tiers based directly on the usage patterns and feedback we've seen from the community, so we're confident there's an option that fits how you work.

**Looking Ahead**

As we begin onboarding users from our [waitlist](https://kiro.dev/waitlist/), we're committed to making the transition smooth for everyone. In the coming days, we'll host office hours to help you maximize value from Kiro.

Stay tuned for more details on the official launch date. For any questions about the transition, view our [pricing information and FAQs](https://kiro.dev/pricing/), join our community discussions at [Discord](https://discord.gg/kirodotdev). We can’t wait to see what you build!

### Does your code match your spec?

## The importance of specification

Kiro is an agentic IDE that introduced Spec Driven Development (SDD) when it launched in July. With SDD, Kiro’s agent writes a full specification of your software before writing any code. This allows you to iterate with the agent and check that you have fully captured your application’s requirements before you develop it. Kiro then translates your requirements document into an “executable specification” that it then uses to check if the generated code adheres to the specification. Kiro uses these executable specifications to test your program, using a technique called property-based testing, which we believe is more effective at finding bugs.

## From requirements to properties

When using Kiro, it will generate some code starting from a spec. How do we know the code really does what the spec says it should do? Kiro and other GenAI code generation tools have been using automatically generated unit tests to help answer this question. Kiro generates unit tests along with the code, and makes sure the code passes them. But there is a chicken-and-egg problem. How do we know the unit tests capture the behavior given in the specification? We need to look at each test and figure out 1/ which specification requirement(s) the test may apply to, and 2/ whether the prescribed behavior in the test matches the specification. Both steps can be tedious and error prone.

As it turns out, we can do better in some cases by using *property*-based tests, rather than unit tests. Unit tests are essentially “example-based” tests, comprised of single input/output pairs. Each one asserts that on a specific example, your system behaves a certain way. In contrast, a property-based test (or simply, *property test*) tests that *property* is true of the system’s behavior, which is to say that it holds for a large (potentially infinite) range of inputs. It’s this universality that gives property tests their power. Given some property tests, we randomly generate many inputs in order to test them. If the property test ever returns false, we’ve found a counter-example that breaks the property. This likely represents a bug in the program under test (but it could also be a bug in property definition, or in the original specification, which is also useful to find). Kiro can use this example to fix the code until it gets it right.

Property-based testing was invented more than two decades ago for the Haskell programming language in a framework called QuickCheck. It has grown and matured over time. Property tests are a great match for specification-driven development, as done by Kiro, because specification requirements are oftentimes directly expressing properties, and these properties can be tested using property-based tests. In a sense, properties are another representation of (parts of) your specification. With property-based tests, we have an “executable specification” — in other words: a version of the specification that we can run. The executable specification comprising of property-based tests is easily linked to the textual requirements, thus giving us confidence that as long as the property tests pass, our code is doing what the requirements say that it should.

### Example

As an example, let’s imagine we’re writing a small traffic light simulator in Python. Kiro will create a specification with a Requirements document comprised of Acceptance Criteria. One of the Acceptance Criteria might look like this:

This criterion is expressing an important condition for a traffic light: that *no two directions are ever green at the same time.* Here’s this Acceptance Criterion transformed into a textual property.

Notice that this property starts with the words “for any”. This is a property because it is talking about a range of inputs and behaviors, not a description of how a single example input should be processed. Kiro takes this property text and reifies it into a property-based test, i.e., an *executable specification*. Kiro connects the two, by letting us navigate directly from our textual specification to the test that checks this property.

Kiro translates textual properties into property-based tests written using a framework called [Hypothesis](https://hypothesis.readthedocs.io/en/latest/), which we see more about later. The code for our traffic light property is given below. We can read this code and see that it does in fact check the property we care about. It first checks that we are starting in a nominal state. Then it iterates through each operation in the schedule of operations, applies them, and checks that we only ever see one green light.

The thing that is great about this property test is that it directly tests the requirement we started from. This means that if we use sufficiently many inputs, we get confidence that the requirement is satisfied. More importantly, the corollary also holds: The program is *incorrect *if there exists an input that causes this function to fail. Kiro will make great use of this fact.

A key part of property testing to randomly generate a diverse range of inputs with which to execute a property test. In our example, the key input is the `list` of operations passed to `test_safety_invariant_at_most_one_green`. We will discuss input generation in the context of this example in the next section. Automated input generation provides a key advantage over unit testing. Whenever someone writes unit tests (whether a model or a human) they will try to account for edge cases,** but they are limited by their own internal biases**. By utilizing random generation, we can often uncover edge cases and interactions between components that are often missed.

### Shapes of properties

The program correctness literature finds that there are common “shapes” of properties that tend to show up. Kiro is aware of these shapes, and looks for them when generating properties. For instance, a common property of data structures, like binary search trees, is that they maintain some runtime invariant. We can write a property to validate that individual operations maintain the invariant.

Another common property shape is the “round trip”, in which some sequence of operations gets you back the value you started with. This property is especially useful for parsers and serializers.

Oftentimes for web APIs, we want delete operations to be "idempotent", meaning that repeating an action twice has the same effect as doing it once.

For more information on designing properties yourself, we’d recommend the following blog post: [Choosing Properties for Property-Based Testing](https://fsharpforfunandprofit.com/posts/property-based-testing-2/), and the [How To Specify it](https://research.chalmers.se/publication/517894/file/517894_Fulltext.pdf) [PDF] papers.

## Testing properties with input generators

In order to test properties, we need concrete input values. In order to get many (hundreds) of diverse values, and reduce the impact of bias, PBT frameworks use “generators” which are functions that take some kind of randomness and produce input values of a specific type. Users of property-based testing frameworks specify which input generators to use when executing particular property tests. Kiro does that for us for the property tests it generates.

PBT frameworks such as Hypothesis ship with a bunch of generators for common types that you can use as building blocks to create more complex generators. The Hypothesis framework calls its generators *strategies*, and often stores strategies in the variable `st`. Here are some example strategies for generating integers.

Hypothesis also ships with more complicated strategies for bespoke datatypes.

We can build up complicated strategies from smaller ones, too. For example, the `lists` strategy takes another strategy as an argument, building lists of things generated by that argument.

## Property-based testing in Kiro

As of today, Kiro will write property-based tests for you, both the property checking code and the generators, in order to test your requirements. Returning to our traffic light example from earlier, Kiro not only generates the property checking code we saw earlier, it adds the `@given` annotations on top of the method, listing the two Hypothesis strategies that we want to use.

Here is the strategy that Kiro wrote for our property. This code uses the Hypothesis strategy framework to build up a strategy over sequences of traffic light transitions. We can see the strategy referencing other strategies that Kiro has written, such as `signal_state_strategy`, allowing for code sharing between multiple property tests.

This test integrates out of the box with pytest, the standard Python testing framework. When `pytest` is executed, Hypothesis will generate 100 test cases, and make sure all of them pass the property.

It’s important for testing quality that input generation strategies indeed produce a variety of inputs. We can assess how well we are doing by examining those inputs, and the code covered when running them, using a tool called [Tyche](https://github.com/tyche-pbt/tyche-extension). Here are some samples of the inputs that the generator came up with, which Tyche shows us:

Here is a visualization Tyche produces to show code being executed by our property-based test. You can see that even after 50 trials, we’re still exploring new code paths.

A word of caution about code coverage: While it is an extremely common metric for measuring test suite effectiveness, is not the ultimate arbiter of test quality. Covering (i.e., executing) a line of code does not mean we’ve exhausted all the behavior on that line. Property testing can’t guarantee your program is absent of bugs, as it’s not an exhaustive technique. There could always be a counterexample that property-based testing fails to find. However, we believe that property-based testing is a more effective tool than traditional example-based testing at finding bugs, does a better job at tying your specifications and tests together, and takes the critical step of phrasing the program correctness problem in terms of concrete, executable specifications.

## Counterexamples and shrinking

Before we finish up this post, we want to talk about one final feature of property-based testing that is really helpful: *shrinking*. When a property test fails, you get an input that causes the property to fail, i.e. a counterexample. Ideally, you would like a *minimal* input, some small example that demonstrates the core of the problem that made the test fail. A giant counterexample likely contains extraneous data that has nothing to do with the problem, whereas a minimal example helps you (and likely the Kiro agent) identify the actual fault in the program, and repair it. Most property-based testing frameworks attempt to give you a minimal example through a process called “shrinking”. Let’s see how this works.

Imagine we’re implementing a set backed by a Search Tree. We would likely have the following property:

Running this test, we might get an output like:

But this wasn’t in fact the first falsifying example that Hypothesis found. Looking at Hypothesis logs, the first failing counterexample was actually the following:

This would be a more annoying case to debug! **Shrinking systematically simplifies the failing input while checking it still triggers the failure.** In our example, Hypothesis removed unnecessary nodes, reduced integer values, and simplified the tree structure until it found the minimal case: two single-node trees both containing the value 0. This reveals the core issue—the union operation doesn't properly handle duplicate values—without the noise of a complex tree structure.

When Kiro generates property tests, it leverages the shrinking capabilities of the underlying PBT framework. This means that when a property test fails during development, you get an actionable, minimal counterexample that makes debugging significantly easier. The agent can use this minimal example to more easily understand the root cause and propose a fix, creating a tight feedback loop between specification, testing, and implementation. When Kiro finds that the implementation might be correct but it disagrees with the specification, or if the AI generated code looks fundamentally wrong in a non-trivial way, Kiro will surface this to the developer to make a choice: fix the code, fix the spec, or fix the PBT. Doing so combines human judgement with AI and PBTs to more clearly align the implementation to developer intent.

## Conclusion

Kiro’s inclusion of property-based testing is a shift in how we think about correctness with AI coding tasks, moving from checking individual examples to validating universal properties across entire input spaces. By automatically translating natural language specifications into executable properties and generating comprehensive test cases, Kiro creates a powerful feedback loop that helps both AI agents and human developers build more reliable software. This approach not only finds bugs that traditional testing misses, but also maintains a clear, traceable link between requirements and the tests that validate them. While PBT cannot guarantee the absence of all bugs, it provides significantly stronger evidence of correctness than example-based testing alone, making it an essential tool for specification-driven development.

For more information on LLMs and property-based testing please see the following research papers:

- QuickCheck
- Can LLMs write good PBTs
- Agentic PBT
- Use Property-Based Testing to Bridge LLM Code Generation and Validation
- Tyche [PDF]

[Download Kiro](/downloads/), and try [property-based testing](/docs/specs/correctness/) with [specs](/docs/specs/).

### Property-Based Testing Caught a Security Bug I Never Would Have Found

### When Targeted Random Testing Finds Real Security Vulnerabilities

Security vulnerabilities often hide in the corners of our code that we never think to test. We write unit tests for the happy path, maybe a few edge cases we can imagine, but what about the inputs we'd never consider? Many times we assume that LLMs are handling these scenarios by default, however LLM-generated code can be as prone to contain bugs or vulnerabilities as human-written code. What happens when a user enters a malicious string into your application?

This is exactly what happened when we tested building a storage service for a chat application using AI with Kiro’s [latest GA features](/blog/property-based-testing/). Following a [specification-driven development (SDD) workflow](/docs/specs/), Kiro carefully defined the requirements, extracted testable properties, and implemented what seemed like straightforward code for storing and retrieving API keys. The implementation looked solid. Code review would likely have approved it. Traditional unit tests would have passed.

But on the 75th iteration of a property-based test, something unexpected happened: the entire round-trip property failed. What should have been a simple save-and-retrieve operation instead exposed a mishandling of javascript prototypes—a bug that can lead to security issues in the future if you’re not careful to eliminate the flaw early on.

This post tells the story of how Property-Based Testing (PBT) caught a security bug that human intuition and traditional testing methods would likely have missed. We'll walk through:

- The specification and property that Kiro defined
- The seemingly innocent implementation that contained a critical flaw
- How PBT's systematic exploration of the input space uncovered the vulnerability
- The fix that addresses the vulnerability
- Why this matters for building secure software

This isn't just a theoretical exercise—it's a real example of how automated testing techniques can find the edge cases that keep security researchers up at night, before they make it to production.

### Background

When working through building an application with some customers and walking through their prompts for a Spec, Kiro was implementing a storage system for a chat application that saves user data to browser localStorage. One key feature was storing API keys for different LLM providers (like OpenAI, Anthropic, etc.). Users could save their API keys using a provider name as the key. This object would have API like the following:

Kiro, following SDD formulated the following requirement:

Let’s drill down on acceptance criteria `2`, which Kiro decided to pick as a key correctness property:

Kiro calls this a “round-trip” property. Round-trips are a common shape for correctness properties, where you start with an arbitrary value, perform some sequence of operations, and end up with the same value. In this case, we’re asserting that if we start with an arbitrary string values `provider` and `key`:

1. Store the key under provider in storage
2. Retrieve the value associated with provider

Then the value we get back should be equal to `key`. If this isn’t true (say, we get back a different value, or an exception is thrown), then clearly something is wrong with our implementation. This spec looks great, so we’ll sign off on it, and have Kiro implement our api.

The LLM produced the following code as part of our API:

Kiro then proceeded to test this code using property-based testing, to gather evidence that the property we expect to hold, actually does. To check Property 2, Kiro wrote the following test, using the [fast-check ](https://fast-check.dev/)library for TypeScript:

Kiro runs this test, and on trial #75 → we get a failure! Kiro proceeds to shrink the failure and then reports to us the following counterexample: the provider `"__proto__"` and and the apikey `" "`.

### What’s going on?

The property-based test generated random strings for provider names, and after 75 test runs, it generated the string `"__proto__"` as a provider name. This caused the test to fail with this counterexample:

When we try to save an API key with provider name `__proto__`, then load it back, something strange happens and we don’t get the value we expect. Kiro helps us localize the problem by using shrinking, to remove extraneous details from the problem. In this case it reduces our apiKey string to the smallest string allowed by our generators, only containing spaces. This tells us that the problem probably isn’t with the value, but instead that the weird key is what’s causing the issue. If you’re familiar with JavaScript, then this error probably sticks right out at you, but if you’re not read on.

This is a feature of how JavaScript implements its object system. More traditional object oriented programming languages (such as Java, Python, and SmallTalk), use the idea of classes. Each class is a static member of the codebase that describes how to build an object, and describes the inheritance relationship between different objects. JavaScript uses an alternative approach, called “prototypes”. In a prototype-based object system, there are no classes. Instead, every object contains a special field called its prototype that points to a parent object from which it should inherent code and data. This lets the inheritance relationship be configured dynamically. In JavaScript, this prototype lives in the `__proto__` field. When we tried to set the field to a string, the JavaScript engine rejected this, and kept the original prototype in place. This results in us getting back the original prototype (an empty object) when we look up the `provider` in the second step of the property test.

Not all writes to the prototype are as benign as this one. Since the `provider` and `apiKey` are under attacker control, if the attacker found a way to get a non-string value into `apiKey` they could have injected values into the prototype, resulting in further reads from the objects properties potentially returning attacker controlled values.

Is this exploitable? No. The `apiKeys` object doesn’t live long enough, it’s immediately freed after serializing it, and `JSON.stringify` knows to skip the `__proto__` field. We’re also only overwriting the prototype of `apiKeys`, not mutating a global prototype. However, refactors to the code could introduce new code paths that turn this un-exploitable vulnerability in one that could have wider impact. The testing power offered by property-based testing catches this now, helping prevent subtle incorrectness and sharp edge cases from growing in your code base.

### How did Kiro test this?

When we tried to save an API key with provider name `__proto__`, then load it back, we got an empty object `{}` instead of the API key we saved. Why did this happen? Let’s understand a bit more background on what happened under the covers.

One of the advantages of PBTs we often talk about is bias. With unit tests, whoever wrote the tests (model or human) tried to account for edge cases, but they are limited by their own internal biases. Since the same (model/person) wrote the implementation, it stands to reason they are going to have a hard time coming up with edge cases they didn’t think about during the implementation. In this case, using property-based tests allows us to access the collective wisdom of those who have contributed to the testing framework. In this case we are injecting institutional knowledge of common bug types to the process. (`__proto__` is one of the common bug strings encoded into the PBT generator by the fast-check community authors) into your testing process.

Before moving on, one thing to note is the PBT code had `{ numRuns: 100 }` which means that there were 100 iterations by the generator to try and find a bug. Kiro defaults to this but you can raise or lower this value depending on what level of confidence you’re looking for in your program. Sometimes you want more, but it also might be the case that an implementation takes a bit of time to test and therefore the performance of running 100 or more input tests isn’t valuable yet in that phase of your development lifecycle. The good thing is you can always raise or lower this as necessary.

### The fix

Kiro implemented two defensive measures based on [MITRE's highly effective mitigation strategies](https://cwe.mitre.org/data/definitions/1321.html):

1. Safe Storage (in `saveApiKey`):

Objects created with `Object.create(null)` have no prototype chain, so `__proto__` becomes just a regular property.

2. Safe Retrieval (in loadApiKey):

## The Bigger Picture

This story illustrates why Kiro uses property-based testing as part of SDD:

1. Properties connect directly to requirements - The property "for any provider name, round-trip should work" is a direct translation of the requirement. When the property passes, we have evidence the requirement is satisfied.
2. Random generation finds unexpected edge cases - Humans and LLMs have biases about what inputs to test. Random generation explores the space more thoroughly.
3. Executable specifications - Properties are specifications you can run. They bridge the gap between "what should the code do" (requirements) and "does the code actually do it" (tests).
4. Tight feedback loops - When a property fails, you get a minimal counterexample that makes debugging easier. Kiro can use this to fix the code, creating a rapid iteration cycle.

This bug was found during real development with Kiro. The property-based test caught a security weakness that would have been very difficult to find through:

- Manual code review
- Traditional unit tests with hand-picked examples
- Integration testing

### Refactoring made right: how program analysis makes AI agents safe and reliable

You ask your AI coding assistant to do something simple—rename a function or move a file—and suddenly you’re in recovery mode. Imports break or references point to files that no longer exist. A codebase that compiled five minutes ago starts throwing errors everywhere. What should have been a 20-second refactor turns into a 5-minute debugging and cleanup session.

## Why refactoring is hard for agents

Refactoring isn't just find-and-replace at scale—it's a graph traversal problem across your codebase's semantic structure. When you rename a function, the changes cascade: every call site across the workspace, type definitions and interfaces that reference it, import/export statements, tests, and (optionally) documentation and comments. Moving a file triggers an even more complex ripple, affecting import paths in every dependent file, barrel files (`index.ts`) and re-exports, module resolution assumptions baked into `tsconfig` paths and bundler configs, and scattered configuration files like Webpack config, just to name a few. Here's the fundamental mismatch: LLMs excel at generating plausible code through pattern matching, but refactoring demands *precision over plausibility*. It's not a creative task—it's a constraint satisfaction problem that requires exact understanding of symbol relationships, language-specific semantics, and the project's dependency graph. An agent that “looks right” but misses one import in a deeply nested module hasn't just made a minor error; it's introduced a runtime failure that won't surface until production. This is why text generation, no matter how sophisticated, is an unreliable tool for structural code transformation.

## The problem: when agents work harder, not smarter

Many AI agents stumble with refactoring because they treat *structural* edits like *text* edits. Here are some failure modes developers keep hitting:

**The ask:** “Rename this method.”

**The traditional failure:** The agent updated the method definition but missed call sites across the project. Even when the prompt explicitly asked it to update references, the process turned into a slow, error-prone loop: search for the old name and replace it. Consider this prompt: rename` get_loose_identifier `in` expression.js `to better reflect what it does`.` Renaming this symbol propagates to four files, impacting eight references and three imports. The left side of the following figure (Traditional Approach) shows how this operation plays out without a dedicated refactoring tool: after renaming the symbol in the first file (`expression.js`), the agent searches the codebase for `get_loose_identifier` and updates `CallExpression.js` and `AssignmentExpression.js` through multiple LLM calls and tool invocations. Despite the effort, it still misses the remaining references.

**How Kiro handles it: **Consider what developers would do manually to perform this task in an IDE. They would press F2 on `get_loose_identifier`, type the new name, and press enter. The IDE would automatically perform the renaming along with updating all eight references and three imports across the codebase. This is precisely what a semantic rename tool does. The right side of the following figure (New Approach) shows how Kiro performs the entire renaming properly in a single tool invocation.

**The ask:** “Fix the lint errors in this file”

**The traditional failure:** The agent treated the linter output as a to-do list of text edits. It renamed function names in the signatures from camelCase to snake_case in one file, but introduced “missing reference” and “missing import” errors in other files. It failed to propagate the changes to all usages.

**How Kiro handles it: **Here's an example showing how an agent benefits from the semantic rename tool even if the user doesn't directly ask for a rename. The user asks the agent to “fix lint errors in `text_helpers.py`”. The lint errors indicate that `normalizeText` and `slugifyTitle` in `utils/text_helpers.py` must change to snake_case. A partial snapshot of the codebase is shown below:

An agent that treats these fixes as text edits will rename the function definitions and may fix local references, but it will likely miss imports and call sites elsewhere, causing `ImportError`/`NameError` at runtime. By using the semantic rename tool, Kiro updates the definitions as well as the imports and calls in `api/routes.py` and `services/indexer.py`, as illustrated in the image below.

**The ask:** “Reorganize our components - move `Button.tsx` from `src/components/` to `src/shared/ui/`”

**The traditional failure: **The agent treated the task as a simple file operation. The file moved successfully, but now every import statement pointing to the old location is broken. The agent then attempted to fix imports file-by-file with find-replace operations, but missed dynamic imports: `import('../components/Button')`.

**How Kiro handles it: **Here's a concrete example showing how Kiro automatically updates import paths. The diagram shows a partial snapshot of the project structure and some of the dependent code snippets:

After moving `Button.tsx` from `src/components/` to `src/shared/ui/`, Kiro automatically updates all the import statements involving the moved file.

**Key Benefits:**

- No manual find-replace needed because the built-in language server handles the edits.
- Language-aware: Understands TypeScript/JavaScript module resolution.
- Safer: Less likely to break working code.
- Handles edge cases: Works with path aliases, monorepos, and more.

This is exactly what happens when you drag-and-drop a file in VSCode's Explorer. The semantic rename tool is the agentic equivalent!

## How Kiro agents refactor

IDEs already solved this problem before the rise of agentic AI. When you press F2 to rename a symbol in VSCode, the IDE doesn't guess. It consults the language server that understand your code's structure, computes a workspace-wide edit, and applies it safely. VSCode's workspace edit capabilities enable a programmable, semantic find-and-replace that understands your code's structure rather than just text patterns.

The Kiro agent doesn’t attempt to simulate refactoring through LLM reasoning alone. Instead, the agent uses the same mechanism described above to register two new refactoring tools that expose these battle-tested IDE capabilities programmatically. When the agent has to rename a symbol or move a file, it intelligently recognizes the intent, selects the appropriate refactoring tool, and invokes it. The agent orchestrates the refactoring workflow while the IDE’s language server helps validate correctness.

Let’s look at how these agent-registered refactoring tools work under the hood.

### Semantic rename tool: renaming done right

This tool taps directly into VSCode's symbol renaming API; the same one you use when you hit F2. It uses `vscode.prepareRename` to validate the symbol is renameable (e.g., it is not a keyword) and `vscode.executeDocumentRenameProvider` to generate a workspace edit with all necessary changes across the workspace. For TypeScript, JavaScript, TSX, and JSX, built-in VSCode rename providers handle everything. For Python, Go, Java, and beyond, the tool relies on your installed language extensions and the language servers they provide.

### The smart relocate tool: moving files without breaking everything

This tool uses VSCode's file moving capabilities to relocate files while automatically updating all references. It's the programmatic equivalent of dragging and dropping in VSCode's explorer, except the agent can do it for you. Using `vscode.WorkspaceEdit.renameFile` and `vscode.workspace.applyEdit`, the tool generates comprehensive changes across multiple files and updates impacted imports.

## Why this matters

**Precision over creativity:** Refactoring doesn't need an LLM to imagine what the code should look like. It needs tooling that understands what the code *actually is* and can modify it surgically.

**Trust through proven infrastructure:** These aren't experimental LLM features, but rather direct integrations with the refactoring infrastructure that developers already rely on daily. If it works when you press F2, it works when the agent does it.

**Language agnostic:** Because the heavy lifting is done by language servers, the approach generalizes across tech stacks and languages.

**Maintain productivity:** A 20-second manual refactor shouldn't become a 5-minute AI-generated recovery mission. With proper tooling, the operation stays fast and atomic.

## The bigger picture

Building on our philosophy of correctness by construction—the same principle that guided our [IDE diagnostics integration](/blog/empowering-kiro-with-ide-diagnostics/)—we're extending this approach to cover the full spectrum of VSCode's refactoring capabilities. Just as we integrated real-time diagnostics to catch errors before they compound, we've now expanded those battle-tested deterministic IDE capabilities to our new internal smart relocate and semantic rename tools.

But refactoring capabilities don't stop at renaming and relocating. VSCode's language servers offer a rich suite of automated code transformations that agents should leverage: Extract Method/Function to pull out code blocks into reusable functions, Inline Variable/Function to simplify code, Change Signature to update method parameters across all call sites, and Convert to Arrow Function or other language-specific transformations are prime candidates.

By taking this approach, we can build correctness, security, and reliability into the foundation that agents run on. The pattern we've established with these tools will guide new additions to our toolkit: instead of asking LLMs to generate fragile text-replacement scripts, intelligent coding agents will continue leveraging these battle-tested IDE operations that developers already trust. When the IDE knows how to do it right, we let it do the work. As agents become more capable, this is a good technique to also make their outputs more trustworthy.

Ready to experience the difference? [Get started with Kiro](/downloads/) for free and see how it can transform your development workflow. Join our growing community on [Discord](https://discord.com/invite/kirodotdev) to share feedback, ask questions, and connect with other developers building with AI-assisted coding.

**Acknowledgements**

Credit to Al Harris for the engineering insights and valuable feedback.

### Run all tasks: the feature we refused to ship (until now)

When we first launched Kiro, we made a deliberate decision that frustrated some early users: we didn’t include an “run all tasks” button. You had to check in with the agent after every task. That wasn't an oversight. It was intentional.

## The tension between speed and control

“Why can’t I just run all the tasks in my spec at once?” was one of the top questions we got after launching 6 months ago. The request made sense—specs often contain 5, 10, sometimes 20+ tasks. Clicking through each one individually felt tedious. Isn’t an agent supposed to help you be as hands-off as possible? Yes and no.

Our core belief with Kiro has always been that AI development works best when developers maintain visibility and control. We wanted you to watch what was happening, understand each task’s execution, and catch issues early. The alternative—letting an AI run through your entire codebase while you grab coffee—felt reckless. We did internal testing and noticed that at times the agent would actually work well autonomously. But other times, it would mess up and the user would spend too much time backtracking and figuring out where things went wrong and trying to fix the issues.

So we said no. And kept saying no. Even as the requests piled up.

## Building the foundation first

Instead of rushing to ship what users asked for, we focused on building the engine that would make run-all actually *safe*. Over the past several months, we’ve quietly shipped a series of features that fundamentally changed Kiro’s reliability:

- Property-Based Testing (PBTs) - “does this task do what I want it to do?”: We now generate property-based tests that validate not just that code runs, but that it meets the specification’s requirements. These aren’t simple unit tests—they're invariant checks that ensure your code behaves correctly across a range of inputs. With PBTs, the agent could check that the task implementation behaved as expected before moving on.
- Dev Servers and LSP Diagnostics - “does the implementation work in practice?”: Real validation environments where tasks are tested against running servers and analyzed with language server diagnostics. Your code gets validated for both runtime behavior and static correctness, catching issues before they reach your main branch.
- Subagents - “does the agent stay on track without getting lost in context rot?”: Specialized agents that handle specific tasks while maintaining their own local context. As your main agent progresses through a spec, subagents prevent it from getting overwhelmed by keeping context management distributed and focused.

Together, these features transformed Kiro from a tool that *generates* code to one that *validates* it. They gave us confidence that executing multiple tasks wouldn’t just be fast—it would be safe.

## Run all tasks: now available

Today, we’re shipping what you've been asking for: the ability to run all tasks in a spec with a single click.
The feature follows the spirit of what you’ve been asking for, but our implementation gives you the confidence to use it as often as you need to.

When you hit “Run all tasks” now, you're not just running code faster. You’re running it through a gauntlet of validation:

- Each task’s output is verified against property-based tests (PBTs)
- Code is validated against dev servers and checked with LSP diagnostics
- Subagents maintain focused, local context so your main agent stays effective across the entire spec
- You get real-time visibility into what’s happening at each step

The result? You get the speed of automated execution with the reliability of careful, watched development.

We think this is great for smaller feature specs where you do not want to handhold the agent. And as always, spending a bit of time up front validating the specs that Kiro came up with based on your prompts will help you ship the actual code you want that much faster overall.

“Run all tasks” isn’t just a button we added. It’s the culmination of months of work that makes batch execution actually trustworthy so you can save time and effort while running tasks instead of needing to fix a more complex mess after the fact.

---

“*Run all tasks” is available now for all Kiro users. *[Try it on your next spec](/downloads/)* and *[let us know what you think](https://discord.gg/kirodotdev)*.*

### Stop repeating yourself: why global steering is the AI context layer you’ve been missing

**You've told your AI assistant 47 times that you prefer functional React components. 23 times that you use Prettier with semicolons. And at least 15 times that your test files go in ****__tests__**** directories, not next to the source code.**

Sound familiar?

Here's the real cost: That's not just annoying—**it's killing your productivity.** Every time you set up a new project, you're spending 10-15 minutes re-explaining preferences you've already articulated dozens of times. For a developer working on 20 projects a year, that's **5+ hours of pure repetition.** For a team of 50? That's **250 hours annually** spent copy-pasting the same standards across workspaces.

And it gets worse: When context isn't consistent, neither is your code. One project gets your security standards. Another misses them because you forgot to paste that file. Your test coverage varies wildly. Your code style drifts. **Inconsistency compounds into technical debt.**

If you're using AI to code (and honestly, who isn't in 2025?), you've hit this wall: **every new project starts from zero.** The AI doesn't remember your preferences, your team's conventions, or your company's standards. You're stuck copy-pasting the same instructions into every workspace, or worse—typing them out manually every single time.

**This is the problem Kiro Global Steering solves.**

Think of Kiro Global Steering as your personal `.bashrc` for AI context—configuration that follows you everywhere, ready when you need it, without the repetition. Write your preferences once, and they become the foundation for every project you touch. No copying. No forgetting. No inconsistency.

**The impact? Developers save hours monthly. Teams achieve consistency automatically. Organizations enforce standards at scale.** And most importantly: your AI assistant finally understands you from day one, every single time.

## What is Steering, Anyway?

Before we dive into Global Steering, let's level-set on what steering actually does.

**Steering is persistent AI context.** It is a set of markdown files that tell AI agents about your preferences, standards, and decisions *before* they start working. Instead of explaining the same things in every conversation, you write it once in a steering file, and the AI reads it automatically as it starts working on your requests

### Current State: Workspace Steering

Right now, Kiro uses workspace-specific steering stored at:

This approach works well when you need to specify preferences on a per-project basis. But here's the problem...

But here's the problem: **Most of what you tell the AI isn't project-specific.**

Your coding style preferences are the same across all your projects. Your testing philosophy should be consistent everywhere. You need universal security standards. Why should you repeat those in every workspace?

## Enter Global Steering: Your Personal AI Configuration Layer

Global Steering lives in your home directory:

**It's persistent. It's universal. It follows you everywhere.**

Any markdown file you put here becomes available to Kiro across *all* your projects, unless explicitly overridden at the workspace level.

### What Belongs in Global Steering?

Think about what's consistent across your work, regardless of the project:

#### 🎨 Personal Coding Style

#### 🧪 Testing Philosophy

#### 🔒 Security Requirements

#### 📝 Documentation Standards

#### 🏗️ Architecture Principles

This pattern defines how you work, not what you're building.

## Real-World Scenario: Individual Developer

Let me show you how this works in practice.

### Meet Jane Doe

Jane is a freelance full-stack developer who works on customer projects using React and Node, open source contributions, and personal side projects. Every project has different business logic, but **her standards stay the same.**

### Jane’s Global Steering Setup

Jane’s `~/.kiro/steering/` folder:

**Key files:**

### Workspace-Specific Steering

Now Jane starts a new client project: an e-commerce platform.

Her project-specific steering files are located at `/.kiro/steering/`:

### How It Works Together

Jane asks Kiro: *"Create a new ProductCard component":*

**Kiro reads:**

1. Global Steering (~/.kiro/steering/) - style.md → Functional components, Prettier settings - accessibility.md → Semantic HTML, alt text requirements - testing.md → Test file location and coverage
2. Workspace Steering (/.kiro/steering/) - tech.md → Using Next.js, TypeScript, Tailwind - product.md → Product data structure and features - structure.md → Components go in src/components/

This will result in Kiro generating a functional React component with TypeScript using Tailwind CSS classes, proper semantic HTML and accessibility attributes, places it in the correct directory with a corresponding test file, while matching Jane's coding style, all automatically.

**All without Jane repeating her preferences.**

## Team Scenario: Organization-Wide Standards

Now let's scale this up. What happens when you have a team of 50 developers?

### Meet AnyCompany

AnyCompany has 8 development teams managing 30+ active repositories across mixed tech stacks (React, Vue, Python, Go) with strict security and compliance requirements.

**The challenge:** Every developer needs to follow company standards, but they're working on different projects with different technologies.

### AnyCompany's Global Steering Strategy

#### Deployment Approaches

Organizations have flexibility in how they distribute global steering files to their teams. The key constraint is that Kiro only reads global steering files from the `~/.kiro/steering/` directory, but the files themselves can originate from anywhere through copying or symlinking.

For teams using version control, AnyCompany maintains a shared repository containing their company-wide steering files for security policies, SOC2 and GDPR compliance requirements, code review standards, on-call procedures, accessibility requirements, and UI/UX brand guidelines. Developers clone this repository during onboarding and either copy the files directly to `~/.kiro/steering/` or create symlinks that automatically reflect updates when the central repository changes. A simple setup script automates this process, ensuring every developer gets the same baseline without manual copying.

For enterprises with Mobile Device Management tools like Jamf or Intune, the deployment can be fully automated. MDM scripts can directly populate `~/.kiro/steering/` by downloading files from internal servers, setting appropriate permissions, and enforcing that required files remain present. Alternatively, MDM can deploy files to a central location like `/opt/company/kiro-steering/` and create symlinks to `~/.kiro/steering/`, which provides centralized updates while keeping files in a managed location. This approach offers zero manual setup for developers, centralized policy management, automatic updates when policies change, and an audit trail for compliance.

### Real Team Example: Front-end Team

AnyCompany's frontend team adds their own layer:

#### Team-Shared Steering Repository (Front-end)

#### Individual Developer: John Doe

John is a frontend developer at AnyCompany.

**John's full steering setup:**

When John asks Kiro to build something, Kiro reads files with workspace steering taking precedence over global steering. Workspace steering is project specific and takes precedence when conflicts exist. Global steering includes John's personal preferences, team conventions, and company standards, and is used when no workspace override exists. As a result, John gets company security compliance automatically applied, frontend team standards that are shared across projects, personal workflow preferences that are individual to him, and project specific context from the current workspace. All of these layers work together seamlessly.

### Scenario: Polyglot Developer

Another scenario is if you work on multiple technology stacks: Frontend development with React and TypeScript, Backend services using Python and FastAPI, Mobile applications built with React Native, and Infrastructure managed through Terraform. A common problem across these ecosystems is that each has different conventions, making it easy to end up with inconsistent practices across your codebase.

The solution shown below demonstrates how you can specify standards across various coding languages, with language-appropriate implementation. Now your testing standards are consistent, but implementation varies appropriately by language.

**Global Steering solution:**

## General Steering Guidelines

### What NOT to Put in Steering

You should never include API keys or secrets, database credentials, internal URLs or endpoints, customer data or PII, or proprietary algorithms (if you plan to share steering files). This is because global steering files are plain text markdown that are often shared or synced, and they are not encrypted by default.

### What's Safe to Include

It's safe to include general security practices, code patterns and preferences, testing approaches, documentation standards, public API design principles, and framework and library choices in your steering files.

## Getting Started: Your First Global Steering File

Ready to try global steering and see it in action? Here is a simple example you can follow to see it for yourself.

### Step 1: Create Your First File

Pick the thing you repeat most often. For most developers, it's coding style:

### Step 2: Test It

Open a new project in Kiro and ask: *"Create a new component"*

Kiro should follow your style preferences from `~/.kiro/steering/style.md` without you mentioning them.

### Step 3: Expand Gradually

Add more files as you discover repeated patterns and build it organically as you notice repetition.

## Wrapping up

Now that you have a more efficient way to work with Kiro so that it understands your overall style and preferences by the use of [global steering](/docs/steering/), the only question left is: What global steering files are you going to start applying to your Kiro projects to save you hours of time and repetitive instruction?

Create your first global steering file today. Experience what it's like to never repeat yourself again.

**What will you put in your global steering? Share your setup with the hashtag #codewithkiro** or tag @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev).

### Teaching Kiro new tricks with agent steering and MCP

## Introduction

Over the past three years, I have helped hundreds of customers adopt AI tools for software development. Many of these customers have developed their own libraries, tools, and even domain-specific languages (DSLs). Whether it's a workflow automation language, a configuration syntax, or a rules engine, these customizations are the backbone of business operations. But what happens when you want your AI coding assistant to understand and work with these proprietary libraries?

In this post, I will explore how to teach [Kiro](/), an AI agent and development environment, to understand a library called MathJSON. While MathJSON is a fictional library created for this demonstration, it serves as a proxy for the workflow languages, configuration systems, and specialized notations that enterprises use daily. Throughout the post, I will discuss [steering](/docs/steering/) and [Model Context Protocol (MCP)](/docs/mcp/), and how to use these together to teach Kiro new skills.

## Meet MathJSON

For this post, I'll use MathJSON - a JSON-based mathematical expression language that uses proper mathematical terminology. Note that MathJSON was created for this post and I do not recommend that you use it in real world applications. Here's what makes it interesting:

### Key Characteristics

- JSON-based syntax for structured mathematical expressions
- Proper mathematical terminology (addend, minuend, multiplicand, etc.)
- Nested expressions for complex calculations
- Rich function library (trigonometry, logarithms, constants)
- File extension: .math

### Example Expression

This example calculates the area of a circle for a given radius passed as an environment variable: `pi * radius^2`

## Guiding Kiro with steering files

Steering gives Kiro persistent knowledge about your project through markdown files. These files are stored in `.kiro/steering/` and provide context and instructions for all interactions within a workspace. Steering files could include coding standards, project structure, and much more.

Your first thought might be to simply add the MathJSON documentation to the steering folder. I did exactly that, adding the `function_reference.md` file to my steering folder. This is a good start, but there are a few issues. First, the documentation is written for a human. As a result it is verbose and often repetitive. Second, it lacks specific best practices for Kiro to follow. Third, documentation copied to my project folder will inevitably be out of date. Let’s look at each of these issues and how to address them.

## Refining steering files

The first issue that we want to overcome is the verbosity of documentation. *Obviously, I am assuming that you have good documentation. If you do not, Kiro can help you generate it. *Often the documentation created for humans is too verbose to include in steering files. MathJSON is a trivial project I created for this post, yet it still has over 3500 lines of documentation across a half dozen markdown files. This is too much information to add to every conversation I have with Kiro.

Luckily, Kiro can refine your steering files for you. Simply open your steering file in Kiro and select the **Refine** button. Kiro will read the file and optimize it for you as seen in the following image.

Let’s look at one of the changes that Kiro made. In the original documentation, addition is described as follows.

Kiro refined this and replaced it with one line. Note that details like nested expressions are covered only once in the refined file rather than repeating it in the examples for each operation. Therefore, there is no need to repeat it here.

Overall, this is a great start. The steering file is now 102 lines, down from 3,500. If you do nothing else, use the refine option to optimize your steering files. However, we can continue to improve it.

## Defining best practices

The next issue that we want to overcome is the specificity of documentation. User documentation tends to be broad. It focuses on covering all the ways you can use the library or language. However, a steering file should be opinionated. Rather than telling Kiro how it **could** use MathJSON, I want to tell Kiro exactly how it **should** use MathJSON.

Kiro started to define best practices when it refined the documentation for me in the prior section. However, I will add an additional rule. Specifically, I want Kiro to validate and test all the code it writes. So, I will add a few new best practices.

Note that the steering file already includes instructions for using the command line tool. I am not repeating that but instructing Kiro when to use it. The steering file is starting to take shape, but how do we keep it up to date over time?

## Keeping knowledge up to date

The first issue that we want to overcome is the freshness of documentation. Over time, MathJSON is going to evolve and change. For example, I recently added support for trigonometry. I would prefer that Kiro has access to the original documentation rather than a copy that I must maintain in steering files. Enter Model Context Protocol (MCP).

For MathJSON, the GitHub repository is the source of truth. Therefore, I configured an MCP server for GitHub. Now, Kiro can read the latest docs when it needs to. Note that GitHub is just an example. If you keep your documentation in GitLab, Confluence, etc. there is likely an MCP server for that too.

You might be tempted to delete the steering file now that Kiro has direct access to the docs in GitHub. However, in practice, I have found that I need both. Imagine that I asked Kiro to `create a function to add two numbers`. There is nothing in that prompt to indicate that I want Kiro to use MathJSON, nor that the documentation for MathJSON is stored in GitHub. Kiro is likely to write the function in Python rather than MathJSON. The steering file helps Kiro connect the dots.

In the following example, you can see that I have updated my steering file to tell Kiro that we are using MathJSON and that the documentation is available in GitHub. In addition, I have told Kiro to use the GitHub MCP server to access the documentation.

Note that I am providing references to specific files. This is a performance optimization. Had I just provided a reference to the repo, Kiro would spend too much time exploring the repo and reading files.* *I also want to note that GitHub is not an ideal documentation repository. Kiro would benefit from chunking the documentation into topics and storing those chunks in a vector database. This would allow Kiro to access just the portion of the documentation it needs. However, this post is getting a bit long, so I’ll save that topic for another post.

## Asking Kiro to update its knowledge

At this point, my steering file mostly serves as a pointer to the documentation. However, I do still have some high-level documentation directly in my steering file along with the best practices section. More importantly, I ask Kiro to update the steering file periodically. Each time Kiro makes a mistake, or runs into an issue, I ask Kiro to make updates while the issue is still in context.

In the following example, you can see Kiro working through an environment variable formatting issue. When the linter identifies an issue, Kiro uses the MCP server to read the docs and fix the error.

As Kiro works through these issues, it learns new skills. However, that new knowledge is only retained for the duration of the conversation. Therefore, Kiro is likely to make the same mistake in a future session. This is a great opportunity to ask Kiro to update the steering files as seen in the following image.

After learning about MathJSON’s syntax for environment variables, Kiro added the following section to the steering file.

Over time, Kiro will continue to refine the guidance and expand its knowledge of my DSL and improve the code it writes.

## Bringing it all together

After a few iterations, Kiro is ready to author MathJSON. I’ll ask Kiro to create a function to model mortgage overpayment.

Kiro is now ready to generate MathJSON for me. Here is the MathJSON it generated for the mortgage overpayment calculation.

And of course, Kiro will follow the best practices defined in the steering file to lint and test the code that it wrote validating that the code is syntactically correct.

## Conclusion

Teaching Kiro to understand and work with custom libraries like MathJSON demonstrates the power of combining steering files with Model Context Protocol. By following the approach outlined in this post - refining documentation, establishing clear best practices, and leveraging MCP for up-to-date knowledge - you can teach Kiro to work with your custom libraries, languages and tools. [Get started with Kiro](/downloads/).

### This is fine... (really)

It’s been a whirlwind week for Kiro, our new agentic IDE. More than 100k developers have used it within the first week of preview, with even more on the waitlist. Those of you who have already gotten your hands on Kiro have loved it and you exceeded our expectations. We haven’t only been impressed by the number of users, but also by what you all have managed to build already.

While we tested Kiro a lot internally, we knew it would never be successful without feedback from the community. That’s why we launched it in preview— to gather feedback, learn, iterate, and improve. We knew we were on to something with specs and agent hooks but the one thing we underestimated was just how quickly you all would take to Kiro. We thought we would hit our preview capacity over the course of a few months, but we hit it in just a few days. That has led to some bottlenecks for users, which isn’t the experience we want, whether you’re using Kiro for the first time or the 50th time. This is why we implemented a temporary waitlist on new Kiro signups and now we’re iterating to incorporate the feedback we’re getting and refine the experience before we add more preview users.

If you’re using Kiro today, keep [sending us feedback](https://github.com/kirodotdev/Kiro/issues/new/choose) so we can make it better for everyone. If you’re on the waitlist, we’re working hard to get Kiro ready for even more of you.

Until then, [join us on Discord](https://discord.com/invite/kirodotdev) where we will be sharing updates. We’re working to improve everything about Kiro! We have a bunch of exciting updates on the horizon, and we’re planning to open up to more users soon. Stay tuned.

### Understanding Kiro's pricing: specs, vibes, and usage tracking

*Note as of August 15: In Spec mode, save your credits by clicking "Start task" rather than typing in chat. Using chat to direct spec mode uses vibe requests. See updated bullets below.*

*Read our *[latest blog post](/blog/free-until-september-15/)* on billing and pricing.*

---

Since announcing Kiro’s [new pricing tiers last week](/blog/pricing-waitlist-updates/), we've received a number of questions about the proposed pricing model. Three key questions emerged:

1. What constitutes a 'spec request' versus a 'vibe request'? Users want clearer definitions and examples.
2. How can I track my usage? Without usage tracking in the current editor, users are unsure if our plans meet their needs.
3. What happens when I exceed my tier limits? If I'm on Pro+ ($40) and need more capacity, do I have to jump to Power ($200)?

This blog post will answer all three questions and provide the added clarity you've been asking for.

## What constitutes a 'spec request' versus a 'vibe request'?

Many users have asked us why we're separating spec and vibe requests, and what exactly these requests mean in terms of usage. We chose the spec versus vibe model to mirror real-world usage patterns of Kiro and give you a predictable way to understand your costs. Let’s unpack what these requests are.

**Spec Requests **are when you execute tasks within Kiro's structured development workflow. Here's how it works: you start with vibe requests to create your requirements and design documents. After those have been generated, Kiro presents a list of tasks to start building the project. Each one of those tasks is roughly equivalent to a single spec request, although it can vary depending on complexity.

Here are some scenarios, *assuming a spec task has average complexity*:

- [Updated] Starting a task directly from your tasks.md file will be 1 spec request
- If you run multiple tasks at once (i.e., "Execute task 1-3), each task executed will be one spec request.
- [Updated] Executing subtasks consumes 1 spec request per subtask plus 1 vibe request for coordination (Task 2 with subtasks 2.1 and 2.2 = 2 spec requests + 1 vibe request)

**Vibe Requests** cover any agentic operation in Kiro that does not involve spec task execution. A vibe request represents one chat interaction with Kiro - typically one user prompt and the corresponding response (though this can increase depending on the complexity of the prompt). We've sized requests so that one vibe request typically equals one message or prompt from you, while one spec request equals executing a single task.

Here are some scenarios, *assuming a vibe request has average complexity*:

- Chatting in Kiro like "explain this code to me" is 1 vibe request
- [Updated] Creating and refining spec or steering documents consumes a minimum of 1 vibe request (may vary based on project context and complexity)
- [Updated] Triggering an agent hook consumes a minimum of 1 vibe request (may vary based on hook complexity and project context)
- Complex vibe prompts e.g. "build me an API that does X," could take multiple vibe requests to complete.

Providing these two dimensions gives you a clearer understanding of your usage compared to estimating interactions or tokens. We've also designed the tiers to encourage Kiro's spec-driven development approach because we think it helps developers move faster and write the right code to solve the right problem.  Research shows that addressing issues during the development phase is [5](https://www.cs.cmu.edu/afs/cs/academic/class/17654-f01/www/refs/BB.pdf) to [7](https://www.researchgate.net/figure/BM-System-Science-Institute-Relative-Cost-of-Fixing-Defects_fig1_255965523) times more costly than resolving them during the planning phase of the software development lifecycle. This principle holds true even with AI agents. When you take time to discuss requirements and design with Kiro during the planning phase, a single spec request will often accomplish what would otherwise require multiple vibe requests during implementation.

## How do I track my Kiro usage?

A second area of feedback was an ask for detailed usage tracking and transparency before committing to paid plans. When our pricing goes live later this month, all users will get usage dashboards that update after each request.

Through your IDE dashboard, as shown below, you'll be able to monitor both your Vibe and Spec request usage, track any overages, and view your remaining allocations for the current billing cycle. This transparency allows you to make informed decisions about your plan selection and optimize your usage patterns. For paid tier subscribers, the dashboard will also provide estimates of any potential overage charges, helping you better manage your costs.

## What happens when I exceed my tier limits?

A third area of feedback has been around how many requests you receive with the Kiro plans, and the gap between the Pro+ ($40) and Power ($200) tiers. Some of you expressed interest in affordable intermediate options that would better align with your usage patterns.

Our solution addresses this through a flexible overage option: if you’re on any of the Kiro paid tiers, you can opt to pay for additional requests at rates of $0.20/Spec request or $0.04/Vibe request. This gives you flexibility between tiers, allowing you to scale your usage without immediately upgrading to a higher plan level.

## Making the Most of Your Kiro Experience

We hope these answers help you better understand how to maximize value from Kiro and find the right option that fits how you work.

Coming soon, we'll publish another blog post that dives into FAQs about how subscriptions will work, plus a video that demonstrates the benefits of spec-driven development from a cost perspective. Join our [Discord](https://discord.com/invite/kirodotdev) to continue the discussion!

### Unlock your development productivity with Kiro and Model Context Protocol (MCP)

I’ve found [Kiro](/) to be a personal development accelerator through its built-in capabilities. Using tools to read and write files or execute bash scripts, Kiro turns ideas into reality through features like [spec-driven development](/docs/specs/), autopilot, and [agent hooks](/docs/hooks/). However, as part of a development team, there are times when the built-in tools aren't enough. This is where [Model Context Protocol (MCP)](/docs/mcp/) takes Kiro to the next level. Working on development teams, we often need additional interactions and data access, like:

- Internal knowledge base integration - Connecting to company documentation, wikis, and knowledge repositories.
- Custom API access - Interacting with internal services and organization-specific APIs.
- Project management tools - Integrating with Jira, Asana, GitLab, and other systems to provide ticket and task context.
- Database access - Database querying and analysis within the IDE.
- CI/CD pipeline integration - Connecting to GitLab, GitHub Actions, Jenkins, and other CI/CD tools for build and deployment status.
- Code quality tools - Linking to SonarQube, Code Climate, or similar tools for code quality insights.
- Monitoring systems - Accessing metrics and logs from Prometheus, Grafana, and other monitoring tools.
- Infrastructure management -Interacting with infrastructure-as-code tools and cloud resources.

## Enter Model Context Protocol (MCP)

MCP is a game-changing open source protocol from Anthropic that solves a critical challenge: giving AI models secure, consistent access to your tools and data, wherever they live. Think of it as a universal translator that lets Kiro seamlessly communicate with all your development tools and services.

## Getting Started with Kiro + MCP

Kiro has a built-in MCP client that can be used to extend its capabilities to communicate securely and flexibly with external data sources and tools. To enable one or more MCP servers within Kiro:

1. Set up MCP servers on your local machine
2. Add and configure the MCP servers within Kiro
3. Start using MCP server tools within the Kiro chat session

Kiro communicates with MCP servers through standard input/output (stdio) using a simple JSON-based request-response pattern. Here’s how it works:

Note that while MCP servers run on the same local machine as Kiro, they can communicate with both local data systems (such as PostgreSQL databases) and remote services (such as GitLab).

## Enabling Use of MCP Servers in Kiro

MCP servers in Kiro can be configured at two levels:

- Workspace - Specific to current project/workspace, stored in .kiro/settings/mcp.json.
- User - Applies across all projects/workspaces, stored in your home directory (~/.kiro/settings/mcp.json)

To configure a user-scoped MCP server:

- Select Kiro from the activity bar
- Expand MCP SERVERS
- Open either Workspace or User Config

## Bring GitLab’s Planning Capabilities to Kiro

Development teams commonly use centralized tools for collaboration, planning, and software management. GitLab, for example, is an all-in-one tool for planning, development, and delivery. In my developer workflow, I use GitLab not only to manage code and builds but also to plan tasks such as features and bugs.

If we drill into one of the features:

Instead of context switching, let’s get Kiro to read the issues from GitLab and implement them.

## Configure a GitLab MCP Server

For this blog post, I’m using an open-source MCP server for GitLab: [https://gitlab.com/fforster/gitlab-mcp](https://gitlab.com/fforster/gitlab-mcp) . The README contains instructions for configuring the GitLab MCP server, in my example I’ve built a binary from the source code.

After generating a [personal access token](https://docs.gitlab.com/user/profile/personal_access_tokens/) from my GitLab profile, I can configure my Kiro MCP Server user config as:

Note that the Kiro user configuration is located in .kiro/settings/mcp.json.

If the configuration is correct, Kiro will return the new tools available from the MCP server:

There are a number of tools that are useful here, such as **get_issue**, **list_project_issues. **Let’s explore how to use them.

## Syncing GitLab Issues with Kiro's Spec-driven Development

I want to leverage Kiro’s agent spec-driven development to implement the issues listed in GitLab. Now that I have the GitLab MCP server configured, I can use natural language to explain that I want Kiro to create requirements documents for all of the issues listed against my product.

Within the Kiro chat window we’ll select **Spec** as we want to implement the GitLab issues in a structured way. The next step is to prompt Kiro to create specs for the GitLab issues:

When encountering a new tool for the first time, such as **list_project_issues**, Kiro will prompt me to approve first before executing the request:

Note that the **autoApprove** setting within the MCP configuration can also be used to control whether Kiro automatically approves tool execution requests without prompting the user:

Once the issues have been retrieved from the GitHub project, Kiro begins by creating a spec for each GitLab issue:

Kiro has a specific menu where the specs are stored, these are also located in the .kiro directory within the project workspace:

From here, I can use Kiro to create a design document that includes details such as technical architecture decisions, system component interactions, data models and flows, API specifications, security considerations, and performance requirements.

The final step in this three-phase approach involves breaking down the design into actionable tasks with clear definitions of done and implementation details.

Once the planning for the GitLab issues is complete, the features can be built in a structured way by starting the tasks within the task list:

## Take Your Development to the Next Level

Kiro's MCP integration isn’t just another feature – it’s a fundamental shift in how AI can integrate with your development workflow. By connecting Kiro directly to your tools and services, you’ll spend less time context-switching and more time building.

Get started with Kiro for free or view the documentation to learn more about Kiro’s capabilities.

Read more about Model Context Protocol via the [user guide](https://modelcontextprotocol.io/introduction) and see the reference implementations on the [Model Context Protocol servers page](https://github.com/modelcontextprotocol/servers).

Can’t find an MCP server that meets your requirements? Consider creating your own MCP server with Kiro.

Let’s connect - tag @kirodotdev on [X](https://x.com/kirodotdev), [LinkedIn](https://www.linkedin.com/showcase/kirodotdev), or [Instagram](https://www.instagram.com/kirodotdev), and @kiro.dev on [Bluesky](https://bsky.app/profile/kiro.dev), and share what you’ve #builtwithkiro

### The wait(list) is over, get started with Kiro today

Since our launch 90 days ago, hundreds of thousands of developers have joined our waitlist to try Kiro out. **As of today, the waitlist is gone.** If you’re eager to try out our spec-driven approach to coding with AI, skip the rest of the blog and [sign up now.](/downloads/)

For a limited time only, when you sign up as a new user, you’ll get 500 free bonus credits that you can use within 30 days. For context, that’s [50% of the Kiro Pro plan](/pricing/). For those who are new, [here’s a more in-depth guide](/blog/new-pricing-plans-and-auto/) to how Kiro pricing works, but the tl;dr is:

- A single pool of credits that you can use for both vibe and spec-driven coding. Tasks consume credits at different rates based on complexity.
- Credits are metered in 0.01 increments so you can maximize your credit usage.
- Different models consume credits at different rates, with Auto, our agent, consuming 1X and Claude Sonnet-class models consuming 1.3X credits for the same prompt.

Kiro doesn’t support logging in via AWS IAM Identity Center yet, so if that’s your preference, reach out to your AWS account manager to learn how you can get access.

Over 100,000 developers like you started using Kiro within the first five days after launch, so you’re in good company. Here’s what their experience was like:

As a startup co-founder and CTO, time is the most important resource. Kiro justifies the use of my time for developing our business critical assets in-house.

Rolf Koski

CTO & Co-Founder

In my role designing AWS Cloud and AI solutions with Terraform and Python, spec-driven development with Kiro has brought code relevancy and quality to a whole new level. We've accelerated feature development dramatically, reducing time to customer value from weeks to days. We are excited to welcome Kiro as our newest team member.

Håkon Eriksen Drange

Principal Cloud Architect

Kiro is a strong ally for startups. It naturally turns overlooked docs and specs into robust assets, making growth smoother and future scaling more effective.

Kento Ikeda

Founder & Engineer

I use Kiro for everything - drafting new Terraform modules, tweaking container setups, even writing down random AI ideas at 2 am. But more than anything, it supports how I learn. I'm endlessly curious, and Kiro helps me stay in that learning loop—tinkering, breaking things, fixing them, and then allowing me to share what I learn back with the community.

Adit Modi

Solution Architect

I've been blown away by Kiro's capabilities. The agentic experience is really transformative. From the multimodal inputs that understand context to the complete lifecycle control within the IDE, it feels like I'm working with a senior developer.

Most tools are great at generating code, but Kiro gives structure to the chaos before you write a single line.

In roughly two days, I built a secure file sharing application from scratch. By simply sharing my requirements with Kiro, I was able to create a fully secure application that incorporates encryption and various security coding practices—no additional prompts needed.

I often forget to add unit tests, or update documentation when pushing changes, but with Kiro I can create a hook and it will automatically run those tasks in the background for me, never having to think twice.

Darya Petrashka

Senior Data Scientist

As a startup co-founder and CTO, time is the most important resource. Kiro justifies the use of my time for developing our business critical assets in-house.

Rolf Koski

CTO & Co-Founder

In my role designing AWS Cloud and AI solutions with Terraform and Python, spec-driven development with Kiro has brought code relevancy and quality to a whole new level. We've accelerated feature development dramatically, reducing time to customer value from weeks to days. We are excited to welcome Kiro as our newest team member.

Håkon Eriksen Drange

Principal Cloud Architect

Kiro is a strong ally for startups. It naturally turns overlooked docs and specs into robust assets, making growth smoother and future scaling more effective.

Kento Ikeda

Founder & Engineer

I use Kiro for everything - drafting new Terraform modules, tweaking container setups, even writing down random AI ideas at 2 am. But more than anything, it supports how I learn. I'm endlessly curious, and Kiro helps me stay in that learning loop—tinkering, breaking things, fixing them, and then allowing me to share what I learn back with the community.

Adit Modi

Solution Architect

I've been blown away by Kiro's capabilities. The agentic experience is really transformative. From the multimodal inputs that understand context to the complete lifecycle control within the IDE, it feels like I'm working with a senior developer.

Most tools are great at generating code, but Kiro gives structure to the chaos before you write a single line.

In roughly two days, I built a secure file sharing application from scratch. By simply sharing my requirements with Kiro, I was able to create a fully secure application that incorporates encryption and various security coding practices—no additional prompts needed.

I often forget to add unit tests, or update documentation when pushing changes, but with Kiro I can create a hook and it will automatically run those tasks in the background for me, never having to think twice.

Darya Petrashka

Senior Data Scientist

As a startup co-founder and CTO, time is the most important resource. Kiro justifies the use of my time for developing our business critical assets in-house.

Rolf Koski

CTO & Co-Founder

In my role designing AWS Cloud and AI solutions with Terraform and Python, spec-driven development with Kiro has brought code relevancy and quality to a whole new level. We've accelerated feature development dramatically, reducing time to customer value from weeks to days. We are excited to welcome Kiro as our newest team member.

Håkon Eriksen Drange

Principal Cloud Architect

Kiro is a strong ally for startups. It naturally turns overlooked docs and specs into robust assets, making growth smoother and future scaling more effective.

Kento Ikeda

Founder & Engineer

I use Kiro for everything - drafting new Terraform modules, tweaking container setups, even writing down random AI ideas at 2 am. But more than anything, it supports how I learn. I'm endlessly curious, and Kiro helps me stay in that learning loop—tinkering, breaking things, fixing them, and then allowing me to share what I learn back with the community.

Adit Modi

Solution Architect

I've been blown away by Kiro's capabilities. The agentic experience is really transformative. From the multimodal inputs that understand context to the complete lifecycle control within the IDE, it feels like I'm working with a senior developer.

Most tools are great at generating code, but Kiro gives structure to the chaos before you write a single line.

In roughly two days, I built a secure file sharing application from scratch. By simply sharing my requirements with Kiro, I was able to create a fully secure application that incorporates encryption and various security coding practices—no additional prompts needed.

I often forget to add unit tests, or update documentation when pushing changes, but with Kiro I can create a hook and it will automatically run those tasks in the background for me, never having to think twice.

Darya Petrashka

Senior Data Scientist

## 0.4.0 features, improvements, and fixes

During the past 90 days, we’ve been hard at work revamping our pricing model, building new specs and agent functionality, adding Claude Sonnet 4.5 support, unveiling our new agent Auto, and making many UX quality-of-life improvements.

Today, we are also releasing version 0.4.0 of the IDE, featuring useful improvements to specs, credit consumption visibility, better support for dev servers and trusted commands. In short:

- Spec MVP tasks: During spec creation, you can now mark tasks (including unit tests) as optional to prioritize core features while keeping comprehensive task lists handy.
- Per prompt credit consumption insights: You can now see how many credits each prompt consumed, right in the chat panel.
- Dev server integration: Kiro can now intelligently read the dev server output to catch more compile and runtime issues.
- Reference specs as context: bring existing specs as added context to your prompts
- Additional improvements for trusted commands, bug fixes and more - see the changelog for the full list of goodies shipping with 0.4.0

As always, we’re excited to hear your feedback [on our Discord](https://discord.gg/kirodotdev). Thank you for supporting us on this journey to reimagine how software gets built with AI. We can’t wait to see what you build.

[Download Kiro](/downloads/) now to get started!

### Changelog

Added support for Claude Opus 4.6 — Anthropic's most powerful model and the world's best for coding. Opus 4.6 excels on large-scale codebases and long-horizon projects, making it ideal for spec-driven development and sophisticated agents. Available with experimental support in both the [Kiro IDE](https://kiro.dev/) and [Kiro CLI](https://kiro.dev/cli/) for Pro, Pro+, and Power tier subscribers with a 2.2x credit multiplier. Restart your IDE to access it from the model selector.

This release brings powerful new ways to customize and extend Kiro's agentic capabilities. Define your own specialized subagents, import portable skill packages from the community, and intercept tool invocations with new hook triggers. Enterprise customers also get new governance controls for web tools.

## Custom Subagents

Define your own specialized agents to handle specific tasks in your workflow. Create a markdown file in **~/.kiro/agents** (global) or **.kiro/agents** (workspace) with a system prompt and optional attributes like model selection, tool access, and MCP server integration. Kiro automatically selects the right custom agent based on its description, or you can invoke one explicitly. [Learn more ->](https://kiro.dev/docs/chat/subagents/#custom-subagents)

## Agent Skills

Import and create portable instruction packages following the open [Agent Skills](https://agentskills.io/) standard. Skills bundle instructions, scripts, and templates that Kiro activates on-demand when relevant to your task. Share skills across projects or import them from the community. [Learn more ->](https://kiro.dev/docs/skills/)

## Pre and Post Tool Use Hooks

New hook triggers let you intercept agent tool invocations. Pre Tool Use hooks can block certain tools or provide additional context before execution. Post Tool Use hooks enable logging, code formatting, or follow-up instructions after a tool runs. Filter by tool categories (read, write, shell, web) or specific tool names with wildcard support. [Learn more -> ](https://kiro.dev/docs/hooks/types/#pre-tool-use)

## Web Tools Governance

Pro-tier customers using IAM Identity Center can now control web tools access for their organization. Administrators can disable web search and web fetch tools from the AWS console under Settings > Shared settings. [Learn more -> ](https://kiro.dev/docs/chat/webtools/)

### Improvements

### Fixes

This release adds Agent Client Protocol (ACP) support for integrating Kiro into ACP-compatible IDEs and clients, a Help Agent for instant CLI guidance, and a range of tool and configuration improvements.

## Agent Client Protocol (ACP) Support

ACP-compatible editors like JetBrains IDEs and Zed can now use Kiro as a custom agent. Run **kiro-cli acp** to start Kiro as an ACP-compliant agent that communicates over stdin/stdout using JSON-RPC. Kiro supports standard ACP methods plus extensions for slash commands, MCP tools, and session management. [Learn more -> ](https://kiro.dev/docs/cli/acp/)

## Help Agent

Get instant answers about Kiro CLI without leaving your conversation. The built-in Help Agent uses documentation to answer questions about commands, tools, settings, and configuration — and can even create config files in .kiro/ for you. Use **/help** to switch to the Help Agent, or **/help How do I configure MCP? to ask directly**. [Learn more ->](https://kiro.dev/docs/cli/chat/help-agent/)

## Enterprise Web Tools Governance

Administrators can now disable **web_search** and **web_fetch** tools organization-wide. Users see a notification in /tools when web access is disabled by their organization. [Learn more ->](https://kiro.dev/docs/cli/enterprise/settings/#web-tools)

## Subagent Access Control

New **availableAgents** and **trustedAgents** settings give fine-grained control over which agents can be spawned as subagents. Both support glob patterns like **test-***. [Learn more -> ](https://kiro.dev/docs/cli/chat/subagents/#configuring-subagent-access)

## Exit Codes for CI/CD

Kiro CLI now returns structured exit codes for automation. Use **--require-mcp-startup** to exit with code 3 when MCP servers fail to start — ideal for CI/CD pipelines that depend on MCP tools. [Learn more ->](https://kiro.dev/docs/cli/reference/exit-codes/)

### Improvements

### Fixes

This release introduces web tools for searching and fetching content from the internet, enhanced hooks with new action types, subagents for parallel task execution, and improved supervised mode with per-file review capabilities.

## Web tools

Kiro can now search the web and fetch content from URLs directly in chat. Use web tools to look up current documentation, find the latest library versions, or research solutions to technical problems. This keeps your development workflow in one place without switching to a browser.

## Contextual hooks

Introducing contextual hooks with two new triggers: Prompt Submit and Agent Stop. These hooks fire at key moments in the agent workflow, letting you inject context or run commands before the agent acts. Choose between Agent Prompt actions to instruct the agent with natural language, or Shell Command actions to run commands locally without consuming credits.

## Subagents

Introducing subagents for parallel task execution. Kiro can now run multiple tasks simultaneously or delegate to specialized subagents. Two built-in subagents are available: a context gatherer for exploring projects and a general-purpose agent for parallelizing tasks. Each subagent has its own context window, keeping the main agent context clean. Use subagents to investigate multiple data sources in parallel, analyze GitHub issues across repositories, or extend your context window limits without requiring summarization.

## Enhanced Supervised Mode

Supervised mode now offers granular control over code changes with per-file review capabilities. When Kiro makes changes to multiple files, you can review each file individually and selectively accept or reject changes. This turn-based approach works in both vibe chat and spec chat sessions, giving you full visibility into each modification.

### Improvements

### Fixes

### Patches

This release brings custom diff tools, built-in code intelligence for 18 languages, skills for progressive context loading, remote authentication, granular web_fetch tool permissions, and conversation compaction to keep long sessions running smoothly.

## Progressive Context Loading with Skills

Skills are a new resource type designed for large documentation sets. Only metadata (name and description) loads at startup — full content loads on demand when the agent needs it. Skill files require YAML frontmatter with descriptive metadata. Write specific descriptions so the agent reliably knows when to load the full content. [Learn more ->](https://kiro.dev/docs/cli/custom-agents/configuration-reference/#skill-resources)

## Custom diff tools

View code changes your way. Configure external diff tools like delta, difftastic, or VS Code instead of the built-in inline diff. Set your preference with `chat.diffTool` in your settings. Popular options include delta for syntax highlighting with side-by-side view, difftastic for structural diffs that understand code syntax, and GUI diff tools for visual comparison. [Learn more ->](https://kiro.dev/docs/cli/chat/diff-tools/)

## Precise Refactoring with AST Pattern Tools

New **pattern-search** and **pattern-rewrite** tools let the agent find and transform code using syntax-tree patterns rather than text regex. No more false matches on string literals or comments.

## Improved Code Intelligence

Out-of-the-box code understanding for 18 languages — no LSP setup required. Agents can now search symbols, navigate definitions, and perform structural code searches immediately. The new **/code overview** command gives you a complete picture of any workspace in seconds. Use **--silent** for cleaner output when diving into unfamiliar packages. Built-in support includes Bash, C, C++, C#, Elixir, Go, Java, JavaScript, Kotlin, Lua, PHP, Python, Ruby, Rust, Scala, Swift, TSX, and TypeScript. [Learn more ->](https://kiro.dev/docs/cli/code-intelligence/)

## Conversation Compaction

Free up context space with the **/compact** command. When you're approaching context limits, compaction summarizes your conversation history while preserving key information. Compaction also triggers automatically when your context window overflows. Configure retention with **compaction.excludeMessages** (minimum message pairs to keep) and **compaction.excludeContextWindowPercent** (minimum % to retain). Compaction creates a new session — resume the original anytime via **/chat resume**. [Learn more ->](https://kiro.dev/docs/cli/chat/context/#conversation-compaction)

## Granular URL Permissions for web_fetch tool

Control which URLs agents can access through your agent configuration. Use regex patterns to auto-allow trusted domains or block specific sites. Blocked patterns take precedence over trusted ones. URLs not matching trusted patterns will prompt for approval. [Learn more ->](https://kiro.dev/docs/cli/reference/built-in-tools/#web-search-and-fetch)

## Remote Authentication

Sign in with Google or GitHub when running Kiro CLI on remote machines. Whether you're connected via SSH, SSM, or containers, authentication now works with port forwarding. For Builder ID and IAM Identity Center, device code authentication works out of the box — just enter the URL and code in your local browser. [Learn more ->](https://kiro.dev/docs/cli/authentication/#sign-in-from-a-remote-machine)

### Improvements

### Fixes

This release introduces subagents for delegating complex tasks with live progress tracking, a built-in Plan agent for breaking down complex tasks into structured implementation plans, new grep and glob tools for fast file searching, multi-session support with an interactive session picker, and MCP registry support for governance.

## Subagents

Delegate complex tasks to specialized agents with live progress tracking. Subagents run autonomously with their own context, enabling parallel task execution while keeping the main agent context focused. A default subagent is included for general-purpose tasks. You can also spawn subagents using your own agent configurations, allowing you to create specialized subagents tailored to specific workflows. Subagents have access to core tools including file read/write, shell commands, and MCP tools.

This feature introduces a new built-in tool: **subagent**. If you have an existing agent configuration that restricts available tools, add **subagent** to your allowed tools list.

## Plan agent

The Plan agent is a specialized built-in agent that transforms ideas into structured implementation plans. Access it with **Shift + Tab** or the **/plan** command. Here's the workflow:

1. Requirements gathering - Structured questions with multiple choice options to refine your idea
2. Research & analysis - Explores your codebase using code intelligence, grep, and glob tools
3. Implementation plan - Creates detailed task breakdowns with clear objectives and demo descriptions
4. Handoff - Transfers the approved plan to the execution agent

The Planning agent operates in read-only mode—it can explore your codebase but cannot modify files, keeping focus on planning.

## Grep and Glob Tools

Two new built-in tools for fast file searching:

- grep - Fast content search using regex. Respects `.gitignore`. Use instead of `grep`, `rg`, or `ag` commands in bash.
- glob - Fast file discovery using glob patterns. Respects `.gitignore`. Use instead of `find` command in bash.

Both tools are trusted by default in the current working directory and can be configured with allowedPaths and deniedPaths in your agent configuration.

## Multi-Session Support

Work across multiple chat sessions with the new interactive session picker:

- kiro-cli chat --resume-picker - Open the session picker from command line
- kiro-cli chat --list-sessions - List all saved sessions
- /chat resume - Open session picker from within a chat

Sessions are automatically saved on every turn. The picker shows session name, last activity, and message preview.

## MCP Registry Support

MCP registry support adds governance capabilities for MCP tools. Organizations can manage and control which MCP tools are available, ensuring consistency and security across teams.

### Patches

We've added support for Claude Opus 4.5 to AWS IAM Identity Center users in both **us-east-1** and **eu-central-1** regions. Claude Opus 4.5 is available in both the [Kiro IDE](/docs/chat/model-selection/#claude-opus-45) and [Kiro CLI](/docs/cli/chat/model-selection/#claude-opus-45) for Pro, Pro+, and Power tier subscribers.

This release introduces Powers for dynamic MCP tool loading, conversation summarization to manage context windows, and slash commands for quick access to hooks and steering files.

## Powers

Introducing [Powers](/docs/powers/), a new way to give Kiro's agent instant expertise for any framework or tool. Powers package MCP servers, steering files, and hooks into reusable bundles that activate on-demand based on your conversation context. Instead of loading all MCP tools upfront and overwhelming your context window, powers load dynamically when you mention relevant keywords. Browse curated powers from launch partners including Datadog, Dynatrace, Figma, Neon, Netlify, Postman, Supabase, Stripe, and more—or [create your own](/docs/powers/create/).

## Summarization

Adds automatic [conversation summarization](/docs/chat/summarization/) to manage long conversations. When your conversation reaches 80% of the model's context window limit, Kiro automatically summarizes previous messages to bring context usage back below the limit. A new context usage meter in the chat panel shows what percentage of the model's context is being used.

## Slash commands

Introducing [slash commands](/docs/chat/slash-commands/) for quick access to hooks and steering files directly from the chat input. Type **/** to see available commands and execute them instantly. Hooks with manual triggers and steering files configured with manual inclusion appear in the slash command menu, letting you run tests, sync documentation, or pull in specific guidance on demand.

### Patches

This release introduces code intelligence through LSP integration, knowledge index with agent schema configuration, enhanced auto-compaction, and improved guardrails for file reading.

## Code Intelligence

Introducing [Code Intelligence](/docs/cli/code-intelligence/), bringing Language Server Protocol (LSP) integration to the Kiro CLI. The agent now has access to the same code understanding that powers Kiro IDE—go-to-definition, find references, hover information, and diagnostics. This enables more accurate code navigation, refactoring suggestions, and context-aware assistance across your entire codebase.

## Knowledge Index

Adds Knowledge Index with agent schema configuration for [Knowledge Bases](/docs/cli/experimental/knowledge-management/) and auto-indexing support. Define custom knowledge sources in your agent configuration to give it domain-specific context that automatically stays in sync with your codebase.

### Improvements

### Fixes

Kiro autonomous agent works independently on development tasks, from implementing features to fixing bugs. It operates asynchronously in isolated sandbox environments, learning from your code reviews and building deep understanding of your codebase and patterns.

Kiro autonomous agent is starting to roll out for individual developers in preview to Kiro Pro, Pro+, and Power subscribers. There's no cost during the preview period, and usage is subject to weekly limits. Teams can [join the waitlist](https://pages.awscloud.com/Kiro-autonomous-agent-contact.html) to get early access. [Learn more ->](https://kiro.dev/blog/introducing-kiro-autonomous-agent/)

### Claude Opus 4.5 support - Models

## Claude Opus 4.5 support

Added support for Claude Opus 4.5 - Anthropic's most intelligent model combining maximum capability with practical performance. Ideal for complex specialized tasks, professional software engineering, and advanced agents. Claude Opus 4.5 is available in both the [Kiro IDE](/docs/chat/model-selection/#claude-opus-45) and [Kiro CLI](/docs/cli/chat/model-selection/#claude-opus-45) for Pro, Pro+, and Power tier subscribers.

### Autopilot - IDE - Docs - Kiro

# Autopilot

---

## What is Autopilot mode?

Autopilot mode is Kiro's autonomous execution mode that allows the agent to make code changes across your codebase and complete complex tasks with minimal intervention. It's a key feature that enables Kiro to work more independently on your behalf.

## How it works

### Autopilot mode (default)

Kiro works autonomously to complete tasks end-to-end. It can create files, modify code across multiple locations, run commands, and make architectural decisions without asking for approval at each step. You maintain control through the ability to view all changes, revert everything, or interrupt execution at any time.

### Supervised mode

Kiro pauses after each turn that contains file edits, presenting changes for your review before continuing. This turn-based approach gives you full visibility into each modification and lets you guide the development process while maintaining code quality standards.

## Switching between modes

You can toggle between Autopilot and Supervised modes at any time using the autopilot switch in the chat interface. This flexibility allows you to use the appropriate level of control for different tasks.

## When to use each mode

### Autopilot mode is best for:

- Experienced users familiar with Kiro's capabilities
- Repetitive or well-defined tasks
- Projects where you want to move quickly
- Tasks spanning multiple files or requiring several steps

### Supervised mode is best for:

- New users getting familiar with Kiro
- Critical or sensitive codebases
- Learning how Kiro approaches problems
- When you want to carefully review each change
- Working with unfamiliar code or complex systems

You can toggle between these modes at any time based on your current needs and comfort level with the task at hand.

## Kiro's change management features

### In Autopilot mode

In Autopilot mode, Kiro works autonomously and can make multiple changes to your codebase without requiring approval for each individual action.
However, you still maintain control over these changes through several key features:

1. View All Changes

- You can see a comprehensive list of all modifications made by selecting the "View all changes" option in the Chat module
- This gives you visibility into everything Kiro has done across your codebase
- Changes are presented in a diff view that clearly shows what was added, modified, or removed

1. Revert All Changes

- If you're not satisfied with the changes Kiro has made, you can select "Revert"
- This will restore your files to their previous state in the filesystem locally
- This is essentially an "undo" function for all of Kiro's modifications
- Note that you can also revert to a checkpoint, which will revert both file changes as well as context additions

1. Interrupt Execution

- You can interrupt Autopilot mid-execution to regain manual control
- This stops Kiro from making further changes if you notice something going wrong

### In Supervised mode

In Supervised mode, Kiro yields for your approval after each turn that contains file edits. This turn-based approach works in both vibe chat and spec chat sessions.

1. Turn-based approval

- Kiro pauses after each turn containing file changes
- Review the changes before Kiro continues to the next step

1. Per-file review

- When multiple files are edited, review each file individually
- Accept or reject changes on a per-file basis

1. Selective approval

- Accept or reject individual files during review
- When you select Accept All, only non-rejected files are applied
- This lets you cherry-pick which changes to keep from a turn
- Rejecting a file and then selecting Accept All will apply the other changes but stop execution, allowing you to provide guidance before Kiro continues

1. Accept All / Reject All

- Accept All applies all pending changes and continues execution
- Reject All reverts all changes and lets you provide feedback for a different approach

### Chat - IDE - Docs - Kiro

# Chat

---

Kiro offers a chat panel where you can interact with your code through natural language conversations. Just tell Kiro what you need. Ask questions about your codebase, request explanations for complex logic, generate new features, debug tricky issues, and automate repetitive tasks—all while Kiro maintains complete context of your project.

## Key features

## Getting started

### Accessing chat

There are multiple ways to access the chat in your development environment:

1. Keyboard Shortcut: Press Cmd+L (Mac) or Ctrl+L (Windows/Linux) to open the chat panel
2. Command Palette: Press Cmd+Shift+P (Mac) or  Ctrl+Shift+P (Windows/Linux) and search for "Kiro: Open Chat"
3. Secondary Side Bar: Click the Kiro chat icon toggle using Cmd+Opt+B (Mac) or Ctrl+Alt+B in the top bar on the right to open the chat panel

### Your first conversation

Once the chat panel is open:

1. Type your question or request in natural language in the chat input
2. Press Enter to send your message
3. Kiro will analyze your request and respond appropriately

Example requests to get started:

**Ask about your code**

```
"Explain how authentication works in this project"

```

**Generate new code**

```
"Create a React component for a user profile page"

```

**Fix issues**

```
"Help me fix the error in this function"

```

### Exporting a conversation

To export a chat conversation with Kiro, right-click the tab of the conversation you wish to export and select **Export Conversation**. This will export the conversation in markdown (.md) format.

### Smart intent detection

Kiro intelligently analyzes your messages to understand whether you want information or action. When you ask questions like "How does this work?" or "What's the purpose of this code?",
Kiro recognizes this as an information request and responds with explanations and documentation without modifying your code. When you use directives like "Create a component" or "Fix this bug", Kiro identifies this as an action request and will propose or implement the necessary code changes, execute commands, or manage files accordingly. This seamless intent recognition allows for natural conversation without requiring explicit commands to switch between information and action modes.

## Context management

Kiro's power comes from its deep understanding of your codebase context. It automatically analyzes open files in the editor, including their dependencies and structure, but you can also explicitly provide additional context.

### Context providers

Use the `#` symbol in the chat input to access context providers:

| Provider | Description | Example |
| --- | --- | --- |
| #codebase | Allow Kiro to automatically find relevant files across your project | #codebase explain the authentication flow |
| #file | Reference specific files in your codebase | #auth.ts explain this implementation |
| #folder | Reference a specific folder and its contents | #components/ what components do we have? |
| #git diff | Reference the current Git changes | #git diff explain what changed in this PR |
| #terminal | Include recent output from your active terminal and command history | #terminal help me fix this build error |
| #problems | Include all problems in the current file | #problems help me resolve these issues |
| #url | Include web documentation | #url:https://docs.example.com/api explain this API |
| #code | Include specific code snippets in the context | #code:const sum = (a, b) => a + b; explain this function |
| #repository | Include a map of your repository structure | #repository how is this project organized? |
| #current | Reference the currently active file in the editor | #current explain this component |
| #steering | Include specific steering files for guidance | #steering:coding-standards.md review my code |
| #docs | Reference documentation files and content | #docs:api-reference.md explain this API endpoint |
| #spec | Reference all files from a specific spec (requirements, design, tasks) | #spec:user-authentication update the design file to include password reset flow |
| #mcp | Access Model Context Protocol tools and services | #mcp:aws-docs how do I configure S3 buckets? |

You can combine multiple context providers in a single request:

```
#codebase #auth.ts explain how authentication works with our database

```

The `#terminal` context provider is particularly powerful for debugging and troubleshooting. When you include `#terminal` in your message, Kiro can access your recent command history, outputs, and error messages to provide targeted assistance.

**Common scenarios:**

- Build failures: #terminal My build is failing, what's the issue?
- Test debugging: #terminal These tests aren't passing, help me understand why
- Git issues: #terminal I'm stuck on this merge conflict
- Dependency problems: #terminal npm install is throwing errors

Kiro can analyze the actual terminal output, understand error patterns, and suggest specific solutions based on what happened in your terminal session. For detailed examples and best practices, see the [Terminal Integration guide](/docs/chat/terminal).

## Sessions and history

Kiro maintains conversation history within sessions, allowing for continuous context-aware interactions.

### Managing sessions

- Create New Sessions: Start fresh conversations for different topics or projects. Click on + icon in the chat panel to start a new session
- Switch between Sessions: Easily navigate between ongoing conversations through the tab switcher
- View History: Access previous interactions and their outcomes through the History button
- Task Tracking: Monitor the progress of ongoing and completed tasks through the Task list button

### Execution history

Kiro maintains a detailed history of sessions that includes actions taken such as code changes, commands executed,
search results, file operations, and more. You can search, restore, or delete a specific session.

### Checkpoints - IDE - Docs - Kiro

# Checkpoints

---

Each time you send a prompt to Kiro, it creates a “checkpoint”. Checkpoints appear as markers in your chat history. You can hit **Restore** on a checkpoint marker to rewind both your codebase and Kiro’s context back to that point in time. Any changes made to your codebase by Kiro after that checkpoint are reverted, and any context additions (chat interactions) after that point are discarded as well.

Checkpoints act as a safety net that enables you to confidently explore multiple approaches to a problem, try different models for a given task, recover from mistakes or misunderstandings by the agent, etc.

Checkpoints work by snapshotting the contents of a file each time the Kiro agent modifies it using one of its built-in file modification tools, and then restoring that snapshot when you revert to that checkpoint.

Note that Kiro does not track any changes to a file made *outside* of the Kiro agent. This means that if Kiro snapshots a file and then you, for example, manually edit that same file or run a code formatting tool on it, when you revert to that checkpoint, your changes will be lost. Kiro also does not track file changes made by any MCP tools or bash commands that it may run as part of its execution.

### Reverts vs. checkpoints

Whenever the Kiro agent modifies one or more files and then completes its turn, immediately above the chat input box, you will see an option to **Revert** the changes made by the agent.

Reverts are similar to checkpoints, but differ in two key aspects. First, reverts only undo changes made by the *latest* turn of the agent, whereas checkpoints can undo changes made over multiple turns. Second, reverts only revert *file* changes, whereas checkpoints undo file changes as well as discard context additions past the checkpoint.

### Dev servers - IDE - Docs - Kiro

# Dev servers

---

## Overview

Dev server support allows the Kiro agent to run background processes to access long-running terminal commands and background processes. This transforms your development workflow by eliminating context switching and manual terminal management. Instead of juggling multiple terminal windows, starting servers manually, and constantly checking build output, you can ask Kiro to handle it all. Start a dev server, continue your conversation about implementing features, and ask Kiro to validate compilation—all without leaving the chat. You stay focused on building, not managing infrastructure.

## How it works

When you ask Kiro to run a long-running command, it automatically:

1. Creates a dedicated terminal with a descriptive name (e.g., "Kiro: npm run dev")
2. Starts the process in the background
3. Returns control immediately so you can continue working
4. Tracks the process so you can check its status or output anytime

Background processes run in dedicated terminals that are visible in your terminal list, show the command they're running (e.g., "Kiro: npm run dev"), and persist until you stop them or close Kiro.

## Starting a dev server

Simply ask Kiro to run a long-running command in natural language:

- "Start the development server"
- "Run npm run watch"
- "Start the webpack build watcher"

Kiro recognizes common long-running commands and automatically manages them as background processes. The process starts immediately in a dedicated terminal, and you can continue your conversation with Kiro while it runs.

### Process reuse

If you ask Kiro to start a process that's already running (same command in the same directory), it reuses the existing process instead of creating a duplicate. This prevents multiple instances of the same server or watcher from conflicting with each other.

## Monitoring process output

You can ask Kiro to check on your background processes at any time:

- "Check the output of the dev server"
- "What does the npm run watch process show?"
- "Are there any errors in the build watcher?"

Kiro reads the terminal output and can help you:

- Identify compilation errors and suggest fixes
- Confirm successful startup of servers
- Debug issues by analyzing error messages
- Monitor progress of long-running tasks

## Listing active processes

To see all your running background processes:

- "List all background processes"
- "What processes are running?"

Kiro shows you each process with its command, working directory, and current status.

## Stopping a process

When you're done with a background process:

- "Stop the development server"
- "Terminate the npm run watch process"
- "Kill all background processes"

Kiro terminates the process and closes its terminal, cleaning up resources.

## Automating with Steering

You can configure Kiro to automatically check background processes as part of your workflow using [steering rules](/docs/steering). For example:

```markdown
# Development Workflow

After making code changes:
1. Always check the output of the `npm run dev` process
2. Look for compilation errors or warnings
3. If errors exist, suggest fixes before proceeding

```

This ensures Kiro validates your changes against the dev server automatically, catching errors faster.

## Combining with code diagnostics

Background processes work alongside Kiro's code diagnostics tool to give you complete validation coverage. While your dev server or build watcher catches runtime compilation issues, diagnostics surface static analysis problems like type errors and lint warnings—all in one conversation.

Ask Kiro to check both at once: **"Check the build watcher output and show me any TypeScript errors"**

This dual-layer approach means you catch issues faster without switching between terminals and your IDE's problems panel. Everything you need to validate your changes is available through chat.

## Common use cases

**Development servers** - Keep your Next.js, React, or other framework dev server running while you code. Check output after changes to confirm successful compilation.

**Build watchers** - Run webpack, TypeScript, or other build tools in watch mode. Validate that your changes compile without errors.

**Test runners** - Start test watchers to get continuous feedback. Review results anytime to see which tests pass or fail.

## Troubleshooting

### Process won't start

If a background process fails to start, check the terminal output for error messages, verify the command is correct, and ensure dependencies are installed.

### Can't find process output

If Kiro can't read process output, make sure the process is still running by checking your terminal list.

### Multiple processes conflict

If you have port conflicts, list all running processes to identify duplicates and stop unnecessary ones. Kiro automatically reuses existing processes when possible.

### Diagnostics tool - IDE - Docs - Kiro

# Diagnostics tool

---

## Overview

Kiro's diagnostics tool helps the agent understand and work with your code by integrating with your installed IDE extensions. This integration provides real-time error detection, syntax validation, and code analysis that improves AI assistance quality.

## How it works

The diagnostics tool integrates with your installed IDE extensions to provide code analysis. When you have language extensions installed, Kiro can access:

- Real-time error detection - Syntax errors, type mismatches, and compilation issues
- Language-specific insights - Language semantics, imports, and dependencies
- Code quality analysis - Linting rules, style violations, and best practices
- Contextual awareness - Project structure, available APIs, and type definitions

## Getting started

1. Install Language Extensions for your programming languages. See our language-specific guides for recommended extensions:
  - Python Guide
  - TypeScript/JavaScript Guide
  - Java Guide
2. Open a file in your target language to activate the language server

The tool works automatically during agent execution - no additional configuration needed.

## Troubleshooting

If the agent isn't detecting code issues:

- Check Extension Status: Verify the extension is enabled in the Extensions panel
- Review Output Panel: Look for error messages from language servers
- Reload Window: Use the command palette to reload if the language server isn't starting
- Update Extensions: Keep extensions current for the latest capabilities

## Next steps

- Explore our language guides for language-specific setup
- Learn about combining diagnostics with dev servers for a complete development workflow

### Model selection - IDE - Docs - Kiro

# Model selection

---

Kiro provides multiple powerful AI agent options to handle your development tasks: **Auto**, **Claude Sonnet 4.0**, **Claude Sonnet 4.5**, **Claude Opus 4.5**, and **Claude Haiku 4.5**. Each offers distinct advantages depending on your needs and usage patterns.

## Available models

### Auto (recommended)

Auto is Kiro's default intelligent model router that combines multiple frontier models with advanced optimization techniques.

**Key benefits:**

- Cost-effective – Approximately 23% less expensive than direct Sonnet 4 usage
- Smart routing – Automatically chooses the optimal model for each task
- Consistent quality – Delivers Sonnet 4-level results across different task types
- Plan efficiency – Makes your usage limits go further

#### What model does Auto use?

Auto uses best in class LLM models (Claude Sonnet 4 and alike) to provide you the best quality for the type of tasks assigned to the agent. We maintain a very high bar to ensure that the quality of what is offered under Auto compares to or exceeds the quality of separate models made available to our users.

### Claude Sonnet 4.0

Direct access to Anthropic's Claude Sonnet 4.0 model for users who prefer consistent model selection or have specific requirements for using this particular model.

**Key benefits:**

- Predictable behavior – Same model for all interactions
- Direct access – No routing or optimization layers
- Full control – Complete transparency in model selection

### Claude Sonnet 4.5

Anthropic's best model for complex agents and coding, with the highest intelligence across most tasks.

**Key benefits:**

- Coding excellence – Advanced state-of-the-art on SWE-bench Verified
- Agent capabilities – Extended autonomous operation for hours with effective tool usage
- Enhanced reasoning – Improved planning, system design, and security engineering

### Claude Opus 4.5

Anthropic's most intelligent model combining maximum capability with practical performance. Ideal for complex specialized tasks, professional software engineering, and advanced agents.

Claude Opus 4.5 is available exclusively to Pro, Pro+, and Power tier subscribers.

**Key benefits:**

- Maximum intelligence – Step-change improvements in reasoning, coding, and problem-solving
- Practical performance – More accessible price point than previous Opus models
- Complex reasoning – Better balance of tradeoffs and ambiguity across multiple systems
- Production-ready – Handles the most sophisticated software development challenges

### Claude Haiku 4.5

Anthropic's fastest and most intelligent Haiku model with near-frontier performance. Delivers intelligence matching Sonnet 4 at significantly lower cost and faster speed.

**Key benefits:**

- Near-frontier intelligence – Matches Sonnet 4 performance across reasoning and coding
- Blazing speed – More than twice the speed of Sonnet 4
- Cost-effective – Near-frontier intelligence at one-third the cost
- Extended thinking – First Haiku model with advanced reasoning capabilities

## Cost comparison

Understanding the credit consumption differences:

| Model | Credit Usage | Example Task Cost |
| --- | --- | --- |
| Claude Haiku 4.5 | 0.4x | 4 credits |
| Auto | 1.0x | 10 credits |
| Claude Sonnet 4.0 | 1.3x | 13 credits |
| Claude Sonnet 4.5 | 1.3x | 13 credits |
| Claude Opus 4.5 | 2.2x | 22 credits |

## Choosing the right model

### Haiku 4.5

Consider using Haiku 4.5 when:

- Speed is critical – You need fast responses for interactive experiences
- Cost efficiency matters – Near-frontier intelligence at one-third the cost
- High-volume processing – Cost-effective intelligence for large-scale deployments
- Real-time applications – Fast turnaround for user-facing features

### Auto

Consider using Auto when:

- Cost efficiency matters – You want to maximize your plan's value
- General development work – Most coding, debugging, and planning tasks
- Variable task types – Working on diverse projects with different requirements
- Plan optimization – You want your limits to stretch further

### Sonnet 4.0 & Sonnet 4.5

Consider using Sonnet 4.0 or Sonnet 4.5 when:

- Consistency is critical – You need predictable model behavior
- Specific requirements – Your workflow depends on Sonnet 4's particular capabilities
- Model transparency – You prefer knowing exactly which model handles each request
- Budget flexibility – Higher costs aren't a primary concern

### Opus 4.5

Consider using Opus 4.5 when:

- Maximum intelligence needed – Most complex specialized tasks requiring top-tier reasoning
- Professional software engineering – Sophisticated production development challenges
- Advanced agents – Long-running autonomous tasks with complex decision-making
- Critical implementations – High-stakes features where quality is paramount

## How to switch models

### In the chat interface

1. Access model selector
  - Look for the model dropdown in the chat interface
  - Default selection is Auto
2. Choose your model
  - Select Haiku 4.5 for fast, cost-effective tasks
  - Select Auto for intelligent routing
  - Select Claude Sonnet 4.0 for direct access
  - Select Claude Sonnet 4.5 for the latest Anthropic model
  - Select Claude Opus 4.5 for complex production tasks
3. Confirmation
  - Your selection applies to subsequent messages
  - Current conversation context is maintained

## Best practices

### Maximizing efficiency

- Start with Auto – Use it as your default for most tasks
- Use Haiku for speed – Near-frontier intelligence with fast responses and lower cost
- Use Sonnet for agents – Best for complex coding and autonomous workflows
- Reserve Opus for maximum intelligence – Use for the most complex specialized tasks
- Monitor usage – Track how different models affect your plan consumption
- Experiment – Try different models for similar tasks to compare results

### Cost management

- Plan accordingly – Factor model choice into your tier selection
- Track patterns – Understand which tasks benefit most from each model
- Optimize workflows – Adjust development practices based on model strengths
- Consider overages – Enable if you need flexibility beyond plan limits

### Agent Notifications - IDE - Docs - Kiro

# Agent Notifications

---

Kiro agent notifications provide native system notifications for important agent execution events. These OS-level notifications ensure you stay informed about agent progress even when Kiro is running in the background or you're working in other applications.

You can also configure usage notifications to help you monitor your credit consumption and avoid unexpected charges. For more information, see [Managing proactive usage notifications](/docs/billing/proactive-usage-notifications).

### Agent notification types

- Action Required - Agent needs user input or approval to continue (e.g., permission to run shell commands)
- Success - Agent execution completes successfully (e.g., spec task completion, code generation finished)
- Failure - Agent execution encounters an error or fails (e.g., spec creation failure)

### Configuring agent notifications

1. Open Settings: Command Palette (⌘/Ctrl + Shift + P).
2. Search for Agent: Notifications. The various Agent notification types will be listed.
3. Select the specific Agent notification types that you'd like to enable.

You can disable notifications by unselecting the checkbox next to each notification type.

### Troubleshooting agent notifications

#### Agent notifications not appearing

1. Check notification settings - Ensure notifications are enabled in Kiro settings
2. Verify system permissions - Grant notification permissions to Kiro in your OS settings
3. Check Do Not Disturb - Ensure your system's Do Not Disturb mode isn't blocking notifications
4. Focus state - Remember that notifications are suppressed when Kiro is focused (if enabled)
5. Restart if needed - Restart Kiro if notifications stop working after system changes

### Slash commands - IDE - Docs - Kiro

# Slash commands

---

Slash commands let you run [hooks](/docs/hooks) and pull in [steering files](/docs/steering) on demand, directly from the chat. Type `/` in the chat input to see available commands and execute them instantly.

## Command types

### Hooks

[Hooks](/docs/hooks) with manual triggers appear in the slash command menu. When you select a hook, Kiro executes it immediately in your current session. Here are some examples of hooks you might create:

| Command | Description |
| --- | --- |
| /sync-source-to-docs | Syncs source file changes to documentation |
| /run-tests | Executes your configured test suite |
| /generate-changelog | Creates changelog from recent commits |

### Steering files

[Steering files](/docs/steering) configured with [manual inclusion](/docs/steering#manual-inclusion) appear as slash commands. Unlike always-on steering that's automatically included in every conversation, manual steering files let you pull in specific guidance only when you need it. When selected, the file's contents are added to your current conversation context. Here are some examples:

| Command | Description |
| --- | --- |
| /accessibility | Accessibility guidelines for UI components |
| /code-review | Code review checklist and feedback principles |
| /performance | React and Next.js performance optimization tips |
| /refactor | Refactoring rules and common patterns |
| /testing | Testing standards and Jest/RTL conventions |

## How it works

### Adding hooks

To add a hook as a slash command, set its trigger type to **Manual**. See [Hook types](/docs/hooks/types) for details.

### Adding steering files

To add a steering file as a slash command, set `inclusion: manual` in the frontmatter. See [Steering](/docs/steering#manual-inclusion) for configuration options.

### Using slash commands

1. Type / in the chat input field
2. Browse or search the available commands
3. Select a command and press Enter

## Best practices

- Use descriptive names — Clear names like /run-e2e-tests or /accessibility make commands easy to find
- Context switching — Create steering files for different workflows (frontend, backend, testing) and switch between them as needed
- Combine with # providers — Slash commands work alongside context providers for maximum control

### Subagents - IDE - Docs - Kiro

# Subagents

---

Subagents allow Kiro to run multiple tasks in parallel, or delegate specific tasks to subagents that specialize in those tasks. Kiro will automatically launch subagents as appropriate. You can also launch subagents manually by instructing Kiro to do so via a prompt such as "Run subagents to...".

Kiro has two built-in subagents: a "context gathering" subagent used to explore a project and gather relevant context, and a "general purpose" subagent used for parallelizing all other tasks.

Subagents run in parallel; however, the main Kiro agent will wait until all subagents have completed before proceeding. Each subagent has its own context window, ensuring that the main agent context is not polluted by the subagent's execution. Subagents automatically return their results back to the main agent once they finish.

[Steering files](/docs/steering/) and [MCP servers](/docs/mcp/) work in subagents exactly as they do in the main agent. However, subagents do not have access to [Specs](/docs/specs/), and [Hooks](/docs/hooks/) will not trigger in subagents.

You can significantly speed up development by leveraging subagents to perform multiple tasks simultaneously. In the following example, subagents are used to fetch and analyze several tickets in parallel. Not only is this faster than analyzing the tickets sequentially, the tool call and ticket details stay within each subagent and do not pollute the main agent's context.

## Custom subagents

You can define your own custom agent by creating a markdown (.md) file in `~/.kiro/agents` (global) or `<workspace>/.kiro/agents` (workspace scope). Enter the prompt for the custom agent in the body of the markdown file, and define additional attributes as YAML front matter.

For example, to create a simple "code reviewer" custom agent, create `~/kiro/agents/code-reviewer.md` with the following content:

```markdown
---
name: code-reviewer
description: Expert code review assistant.
tools: ["read", "@context7"]
model: claude-sonnet-4
---

You are a senior code reviewer.

## Your Responsibilities
- Review code for correctness, performance, and security
...

```

### Invocation

When launching subagents, Kiro will automatically select the appropriate custom agent configuration for each subagent, based on the `description` field. You can also explicitly ask Kiro to use a specific subagent, for example: "Use the code-reviewer subagent to find performance issues in my code".

### Attributes

Below is a list of attributes you can use in the frontmatter. The **name** attribute is mandatory; all others are optional.

| Attribute | Description | Example value | Default value, if omitted |
| --- | --- | --- | --- |
| name | Name of the agent | code-reviewer | Name of the .md file |
| description | Description of the agent | Expert code review assistant | No description |
| tools | List (array) of tools the agent can access | ["@builtin", "@context7"] | No tools |
| model | The model to use | claude-sonnet-4 | LLM currently selected in chat |
| includeMcpJson | If true, then all MCP tools are included | true | false |
| includePowers | If true, then all MCP tools in Powers are included | true | false |

In the **tools** field, you can use the following:

- read: all built-in file read tools
- write: all built-in file write tools
- shell: all built-in shell command-related tools
- web: all built-in web tools
- spec: all built-in spec-related tools (only valid in Spec mode)
- @builtin: all built-in tools
- @<mcp_server>: all tools from a specific MCP server, e.g., @figma
- @<mcp_server>/<tool>: a specific tool from a specific MCP server, e.g., @figma/get_figjam

Wildcarding is supported, e.g., `tools: ["*"]` to include all built-in and MCP tools, or `tools: ["@figma/*"]` to include all tools from the **figma** MCP server.

### Summarization - IDE - Docs - Kiro

# Summarization

All language models have a "context window", which is the maximum amount of text that the model can handle at one time. The context window length varies by model.

When you have a conversation with Kiro, it remembers and sends all previous messages in that conversation as context to the model, so the model can take those into account when generating its latest response. As your conversation gets long, it will start to bump up against the model's context window limit. When this happens, Kiro will automatically summarize all the messages in the conversation to bring the context length back below the limit.

You can use the context usage meter in the chat panel to stay informed on what percentage of the model's context limit is being used. When usage reaches 80% of the model's limit, Kiro will automatically summarize the conversation.

---

### Terminal integration - IDE - Docs - Kiro

# Terminal integration

---

## Overview

Transform your development workflow with Kiro's terminal integration. Instead of memorizing command syntax or switching between windows, describe what you want to accomplish and Kiro translates your requests into executable commands, maintains context across operations, and provides a secure approval system that keeps you in control while managing dependencies, navigating git workflows, or exploring your codebase.

## Getting started

Simply describe what you want to do in natural language. For example:

- "Install the project dependencies"
- "Check the git status"
- "Find all TypeScript files in the src folder"
- "Run the development server"

Kiro translates your request into the appropriate terminal command and asks for your approval before executing. You'll review the suggested command and choose to Modify, Reject, Run, or Run and Trust, then see the output directly in chat.

Long-running commands like [Dev Servers](/docs/chat/dev-servers) are automatically managed by Kiro, running in dedicated terminals without blocking your workflow.

## How it works

When Kiro suggests a command, you have four options:

- Modify - Edit the command before running
- Reject - Cancel execution
- Run - Execute once
- Run and Trust - Execute and trust similar commands in the future

## Command approval and security

For security, Kiro asks for approval before running any command. You can control this behavior through two complementary systems: trusted commands and command denylists.

### Trust commands

You can streamline the approval process by configuring which commands to trust automatically. Trusted commands use **prefix matching** to automatically approve commands that start with specific patterns.

The trust system puts responsibility on you to carefully configure trusted command patterns. Commands with potentially dangerous operations (like `rm -rf`) will be accepted if they match your trusted patterns and are not in the denylist.

Kiro trusted commands uses string prefix matching to determine if a command should be automatically trusted. You can configure trusted commands in `Settings → Kiro Agent: Trusted Commands` at both the user level (global across all workspaces) and workspace level (specific to your current project).

### Exact matching

Checks for the exact base string.

If you have trusted commands list as `["npm install", "git status"]`:

| Command | Result |
| --- | --- |
| npm install | ✅ Trusted and runs automatically |
| git status | ✅ Trusted and runs automatically |
| npm install --save | ❌ Requires approval (not exact match) |
| git status --short | ❌ Requires approval (not exact match) |

### Partial wildcard matching

Uses `*` to match variations of a specific command.

If you have trusted commands list as `["npm install *"]`:

| Command | Result |
| --- | --- |
| npm install | ✅ Trusted (matches "npm install *") |
| npm install --save | ✅ Trusted (matches "npm install *") |
| npm install express | ✅ Trusted (matches "npm install *") |
| npm run build | ❌ Requires approval (doesn't start with "npm install ") |
| npm test | ❌ Requires approval (doesn't start with "npm install ") |

### Full wildcard matching & complex commands

Uses `*` to trust any command string that starts with the specified prefix. The trust system only checks the beginning of the command string - if it matches, the entire command is trusted, including any chained commands, pipes, or redirects that follow.

If you have trusted commands list as `["npm *", "git *"]`:

| Command | Result |
| --- | --- |
| npm install | ✅ Trusted (matches "npm *") |
| npm install --save | ✅ Trusted (matches "npm *") |
| npm run build | ✅ Trusted (matches "npm *") |
| npm run build \| tee log | ✅ Trusted (starts with "npm ") |
| npm install && docker build . | ✅ Trusted (starts with "npm ") |
| git add . && git commit -m "update" | ✅ Trusted (starts with "git ") |
| docker build . | ❌ Requires approval (no matching prefix) |

### Universal trust

Using wildcards (*) in trusted commands is an over-permissive configuration. This automatically approves all terminal commands without review, which can pose significant security risks including data loss, system modifications, or unauthorized access. Only use wildcards if you completely trust the environment and understand all potential commands.

If you have trusted commands list as `["*"]`:

| Command | Result |
| --- | --- |
| Any command | ✅ Trusted - use with extreme caution |

### Command denylist

The command denylist provides a security layer that prevents auto-approval of commands containing specific patterns, regardless of your trust settings. This system uses **substring matching** - if any denied string appears anywhere in the command, it will require manual approval.

You can configure the denylist in `Settings → Kiro Agent: Command Denylist` at both user and workspace levels.

The denylist is checked **before** trust settings. Even if you trust all commands with `["*"]`, denied commands will still require manual approval.

The denylist uses substring matching to find dangerous patterns anywhere in the command:

If you have command denylist as `["rm -rf", "sudo", "--force"]`:

| Command | Result |
| --- | --- |
| npm install | ✅ Auto-approved (no denied patterns) |
| rm -rf /tmp/cache | ⚠️ Requires approval (contains "rm -rf") |
| sudo npm install | ⚠️ Requires approval (contains "sudo") |
| git push --force | ⚠️ Requires approval (contains "--force") |
| git push --force-with-lease | ⚠️ Requires approval (contains "--force") |
| npm install && rm -rf node_modules | ⚠️ Requires approval (contains "rm -rf") |

Consider adding these patterns to your denylist for enhanced security:

```json
{
  "kiroAgent.commandDenylist": [
    "rm -rf",
    "sudo",
    "chmod 777",
    "eval",
    "curl | sh",
    "wget | sh",
    "> /dev/",
    "mkfs",
    "dd if="
  ]
}

```

### How denylist and trust work together

The command approval system evaluates commands in this order:

1. Denylist check (highest priority) - If the command contains any denied pattern, manual approval is required
2. Trust check - If the command matches a trusted pattern, it's auto-approved
3. Default - If neither applies, manual approval is required

For example with configuration:

```json
{
  "kiroAgent.trustedCommands": ["npm *", "git *"],
  "kiroAgent.commandDenylist": ["--force", "sudo"]
}

```

| Command | Evaluation | Result |
| --- | --- | --- |
| npm install | Matches trust "npm *", no denied patterns | ✅ Auto-approved |
| git status | Matches trust "git *", no denied patterns | ✅ Auto-approved |
| npm install --force | Matches trust "npm *", but contains "--force" | ⚠️ Requires approval (denylist) |
| sudo npm install | Matches trust "npm *", but contains "sudo" | ⚠️ Requires approval (denylist) |
| git push --force | Matches trust "git *", but contains "--force" | ⚠️ Requires approval (denylist) |
| docker build . | No trust match, no denied patterns | ⚠️ Requires approval (default) |

Use the denylist to block dangerous patterns globally, then use trusted commands to streamline your common workflows. This provides both security and convenience.

## Using terminal context

Reference recent output from your active terminal in your conversations with `#terminal`. **Important: #terminal always refers to the currently active/visible terminal window.** If you have multiple terminals open, make sure the terminal you want to reference is active before using `#terminal` in your chat.

This feature allows Kiro to analyze command results, debug errors, and suggest solutions based on your actual terminal session.

```
#terminal analyze the error from the last npm run build

```

Kiro maintains awareness of command history and outputs, enabling:

- Error Analysis - Understanding why commands failed with specific error messages
- Output Interpretation - Explaining complex command results and logs
- Follow-up Actions - Suggesting next steps based on actual results
- Pattern Recognition - Identifying recurring issues across multiple commands
- Environment Debugging - Helping resolve system and dependency conflicts

## Troubleshooting

For issues with terminal integration and manual setup instructions, see the [Shell Integration troubleshooting guide](/docs/troubleshooting/#shell-integration-issues).

### Vibe vs Spec sessions - IDE - Docs - Kiro

# Vibe vs Spec sessions

---

## What is a Vibe session?

Vibe sessions are interactive Q&A-focused sessions in Kiro that are designed for quick questions, explanations, and building projects through a more conversational approach.

### How to access

You can switch between Vibe sessions and Spec sessions using the session picker when you launch a new session. This allows you to choose the interaction style that best suits your current task.

### When to Vibe

1. Interactive Q&A Format: Vibe sessions are optimized for back-and-forth conversations about code, allowing you to ask questions and get immediate responses.
2. Quick Assistance: They're ideal for getting quick answers to coding questions, explanations of code behavior, or understanding concepts without going through a formal specification process.
3. Contextual Understanding: Like other Kiro sessions, Vibe sessions leverage context providers to understand your codebase, but with a focus on explanation rather than extensive code generation.
4. Flexible Approach: Vibe sessions offer a more fluid, less structured approach compared to Spec sessions, making them suitable for exploratory coding and learning.

## What is a Spec session?

A Spec session guides you through a structured approach to complex development tasks in Kiro that formalizes the software development process. It transforms high-level ideas into detailed implementation plans with systematic execution and clear tracking.

### How to access

You can switch between Spec sessions and Vibe sessions using the session picker when you launch a new session. For complex development tasks, Spec sessions provide the structure needed to ensure thorough implementation.

### When to Spec

1. Complex Development Tasks: Use Spec sessions for building complex features, entire applications, or significant refactoring that requires careful planning and execution.
2. Structured Approach: When you need a methodical, step-by-step approach to development with clear documentation of requirements and implementation details.
3. Team Collaboration: For projects where multiple team members need to understand the implementation plan and track progress against specifications.
4. Documentation Needs: When you want to generate detailed documentation alongside your code implementation for future reference or knowledge sharing.

### Web tools - IDE - Docs - Kiro

# Web tools

---

Web access capabilities enable Kiro agent to access current information from the internet in real-time. This feature enables you to get up-to-date answers about topics that may have changed since the model's training data was created. These tools have been designed to not reproduce meaningful chunks of text and it should not be able to access webpages behind paywalls, authentication, and similar access restrictions. Search results may vary over time as internet content changes. Some content may not be accessible through web search due to various restrictions or the nature of the content.

| Tool | Description |
| --- | --- |
| web_search | Tool for searching the web |
| web_fetch | Tool for fetching content from a URL |

You are responsible for your use of output that incorporates web search or grounded information. You will know when your output includes grounded information from citations or links to the source material. You must retain and display these citations and links in the output if you display the grounded output to a downstream user. If you don't want Kiro to use these tools, create a custom agent that [excludes](/docs/cli/custom-agents/configuration-reference/#tools-field) these tools. Citations are provided for output that incorporates web search or grounded information. You can follow a provided citation to the source page.

In the following demo, the agent automatically uses the `web_search` tool to search the web and return up-to-date results for a query, instead of relying on possibly outdated information in the model's training data. It then uses the `web_fetch` tool to retrieve the latest contents at a specific URL.

### Limitations

- Size: 10MB maximum per page fetch
- Timeout: 30 seconds per request
- Redirects: Maximum 10 redirects followed
- Content type: Only text/html pages supported
- Retries: 3 automatic retry attempts on failure

### Governance

Pro-tier customers using IAM Identity Center as the sign-in method can control web tools access for users within their organization. Web tools are enabled in Kiro by default; however, administrators can disable them from the AWS console.

This restriction is enforced on the client side. Be aware that your end users could circumvent it.

## Disabling web tools for your organization

To disable both the web fetch and web search tools for all Kiro IDE users in your account or organization:

1. Open the Kiro console
2. Choose Settings
3. Under Shared settings, toggle Web search and web fetch tools to Off

### Codebase indexing - IDE - Docs - Kiro

# Codebase indexing

---

Kiro automatically indexes your codebase and documentation to provide intelligent code suggestions, navigation, and context-aware assistance. This guide explains how indexing works and how to manage it.

## When indexing occurs

### Automatic indexing

Kiro performs indexing automatically in these scenarios:

1. Project Import: When you first open a project in Kiro, it automatically begins indexing all files in your workspace
2. File Changes: When new files are created or added to your project, they are automatically indexed
3. External Changes: When files are modified outside of Kiro (e.g., through git operations), they are re-indexed

### Manual indexing

You can trigger indexing manually when needed using the Command Palette (`Cmd+Shift+P` on macOS or `Ctrl+Shift+P` on Windows/Linux).

## Available indexing commands

Kiro provides several commands to manage indexing through the Command Palette:

Loading image...

### Codebase indexing

- Kiro: Codebase Force Re-Index: Forces a complete re-indexing of your entire codebase. Use this when:
  - You suspect the index is corrupted or incomplete
  - Major structural changes have been made to your project
  - Kiro's code suggestions seem outdated
- Kiro: Rebuild codebase index: Completely rebuilds the codebase index from scratch. This is more thorough than force re-indexing and should be used when:
  - The index appears severely corrupted
  - You're experiencing persistent issues with code navigation or suggestions

### Documentation indexing

- Kiro: Docs Index: Initiates indexing of documentation files in your project
- Kiro: Docs Force Re-Index: Forces a complete re-indexing of all documentation files

## Monitoring indexing progress

You can monitor the indexing process through the Kiro Logs panel:

1. Access the Output panel in Kiro
2. Select "Kiro Logs" from the dropdown menu
3. View real-time indexing progress and status updates

Loading image...

The logs show:

- When indexing starts and completes
- Number of files found and processed
- Progress percentage for large codebases
- Completion time for indexing operations

## Indexed content

Kiro indexes various types of content to provide intelligent assistance:

- Source Code: All programming language files in your workspace
- Documentation: Markdown, MDX, and other documentation formats
- Configuration: Project configuration files and manifests
- Dependencies: Package definitions and dependency information

The indexed data enables features like:

- Intelligent code completion
- Cross-file navigation
- Context-aware suggestions
- Documentation lookup
- Code refactoring assistance

### Custom extension registry - IDE - Docs - Kiro

# Custom extension registry

---

By default, Kiro uses the extension marketplace at [https://open-vsx.org](https://open-vsx.org). You can configure Kiro to use a different extenson registry, for example, a private registry for your organization that contains a limited set of vetted extensions.

## Configuring a different extension marketplace

Locate the `product.json` file on disk. The exact location depends on the platform:

- macOS: /Applications/Kiro.app/Contents/Resources/app/product.json
- Windows: C:\Program Files\Kiro\resources\app\product.json
- Linux: /usr/lib/code/product.json

Open the `product.json` file in an editor, and locate the `extensionsGallery` property. Within that property, update `serviceUrl`, `itemUrl`, and `resourceUrlTemplate` to point to your private registry, instead of `https://open-vsx.org`.

For example, if your custom registry is hosted at [https://registry.example.com](https://registry.example.com), update the `extensionsGallery` property to look like this:

```json
"extensionsGallery": {
    "serviceUrl": "https://registry.example.com/vscode/gallery",
    "itemUrl": "https://registry.example.com/vscode/item",
    "resourceUrlTemplate": "https://registry.example.com/vscode/unpkg/{publisher}/{name}/{version}/{path}",
    "controlUrl": "",
    "recommendationsUrl": "",
    "nlsBaseUrl": "",
    "publisherUrl": ""
}

```

To configure all Kiro installs in your organization to use a custom extension registry, use an endpoint management, Mobile Device Management (MDM) solution, or similar to make the above update to `product.json` across all your devices.

### Kiro Interface - IDE - Docs - Kiro

# Kiro Interface

---

Kiro's interface is designed to provide a seamless coding experience with AI assistance integrated throughout.

## Main interface components

Kiro's interface is divided into the following main components:

1. Editor - The central workspace where you write and edit code.
2. Chat Panel - A dedicated panel for interacting with AI, including asking questions, requesting code modifications, and receiving AI responses.
3. Views - The sidebar contains specialized views for managing project files, searching, and source control.
4. Status Bar - Provides information about the current file, Git status, and error/warning counts.
5. Command Palette - A quick access tool for executing common actions and accessing AI tools.

Loading image...

### Editor

The central workspace where you write and edit code. Features include:

- Syntax highlighting for multiple languages
- Line numbers and error indicators
- Code folding for better organization
- Multiple tabs for working across files
- Split view support for side-by-side editing

### Chat panel

You can use the chat panel to:

- Ask questions about your code
- Request code generation or modifications
- Get help with debugging and troubleshooting
- Ask for code reviews and optimization suggestions
- Include context with # commands (e.g., #File, #Folder)
- Generate boilerplate code and templates

**To move the chat panel to the opposite side of the IDE**

In the top menu bar, choose **View** > **Appearance** > **Move Primary Side Bar Right**.

### Views

The sidebar contains several specialized views:

- Explorer - Navigate your project file structure, see Git status indicators, and access special sections for Specs and MCP servers.
- Search - Perform global search and replace operations across your entire project.
- Source Control - Manage Git operations, view changes, and handle commits with AI-generated commit messages.
- Run and Debug - View variables, call stacks, and manage breakpoints during debugging sessions.
- Extensions - Install and manage IDE extensions.
- Kiro - A dedicated view for AI-specific features:
  - Specs overview and management
  - Agent Hooks management
  - Agent Steering configuration
  - MCP (Model Context Protocol) servers

### Status bar

Located at the bottom of the interface, the status bar provides:

- Current file information
- Git branch and sync status
- Error and warning counts
- Agent status indicators

### Command palette

Access Kiro's commands quickly by pressing `Cmd+Shift+P` (Mac) or `Ctrl+Shift+P` (Windows/Linux) to:

- Execute common actions
- Access MCP tools
- Configure settings
- Run agent hooks

## Navigation tips

- Use keyboard shortcuts for faster navigation
- Leverage the command palette for quick access to features
- Pin frequently used files for easy access
- Use split views for comparing or referencing code
- Configure workspace settings for personalized experience

### Keyboard Shortcuts - IDE - Docs - Kiro

# Keyboard Shortcuts

---

Kiro IDE provides a wide range of keyboard shortcuts to help you work efficiently. This guide covers the most important shortcuts organized by category.

## General

| Shortcut (Mac) | Shortcut (Windows/Linux) | Description |
| --- | --- | --- |
| Cmd+Shift+P | Ctrl+Shift+P | Open Command Palette |
| Cmd+K Cmd+S | Ctrl+K Ctrl+S | Open Keyboard Shortcuts |
| Ctrl+` | Ctrl+` | Toggle Terminal |
| Cmd+N | Ctrl+N | New File |
| Cmd+W | Ctrl+W | Close Tab |
| Cmd+S | Ctrl+S | Save |
| Cmd+Shift+S | Ctrl+Shift+S | Save As |
| Cmd+Z | Ctrl+Z | Undo |
| Cmd+Shift+Z | Ctrl+Shift+Z | Redo |

## Navigation

| Shortcut (Mac) | Shortcut (Windows/Linux) | Description |
| --- | --- | --- |
| Cmd+P | Ctrl+P | Quick Open File |
| Cmd+O | Ctrl+O | Open File |
| Cmd+K Cmd+O | Ctrl+K Ctrl+O | Open Folder |
| Cmd+Shift+O | Ctrl+Shift+O | Go to Symbol |
| Ctrl+G | Ctrl+G | Go to Line |
| Cmd+F | Ctrl+F | Find |
| Cmd+Shift+F | Ctrl+Shift+F | Find in Files |
| Cmd+B | Ctrl+B | Toggle Sidebar |
| Cmd+\ | Ctrl+\ | Split Editor |
| Cmd+1/2/3 | Ctrl+1/2/3 | Focus Editor Group |
| Ctrl+Shift+G | Ctrl+Shift+G | Open Source Control |

## Editing

| Shortcut (Mac) | Shortcut (Windows/Linux) | Description |
| --- | --- | --- |
| Cmd+X | Ctrl+X | Cut |
| Cmd+C | Ctrl+C | Copy |
| Cmd+V | Ctrl+V | Paste |
| Cmd+/ | Ctrl+/ | Toggle Comment |
| Option+Up/Down | Alt+Up/Down | Move Line Up/Down |
| Cmd+Shift+K | Ctrl+Shift+K | Delete Line |

## AI features

| Shortcut (Mac) | Shortcut (Windows/Linux) | Description |
| --- | --- | --- |
| Cmd+L | Ctrl+L | Open Chat Session |
| Cmd+I | Ctrl+I | Inline Chat |
| F5 | F5 | Start Debugging |

## Custom shortcuts

You can customize keyboard shortcuts in Kiro by using the following instructions:

1. Open the Command Palette (Cmd+Shift+P / Ctrl+Shift+P).
2. Search for Keyboard Shortcuts.
3. Select Preferences: Open Keyboard Shortcuts.
4. Select the command that you want to modify.
5. Choose the pencil icon and enter your preferred shortcut.

This allows you to create a personalized workflow that matches your preferences and habits from other editors.

### Kiroignore - IDE - Docs - Kiro

# Kiroignore

---

The `.kiroignore` file prevents Kiro from reading specific files in your workspace. Using familiar gitignore syntax, you define patterns for files that should remain private—credentials, secrets, or content you prefer to keep out of agent context.

## Why use .kiroignore?

- Security - Prevent Kiro from accessing files containing credentials, API keys, or other sensitive data
- Privacy - Exclude confidential information from AI interactions
- Compliance - Ensure Kiro doesn't access files that shouldn't be shared with external services
- Focus - Keep Kiro's context relevant by excluding large files or build artifacts

## Setting up workspace ignore

To exclude files in a specific project:

1. Create a .kiroignore file in your project root (or any subdirectory)
2. Add patterns for files you want to exclude:

```bash
# Secrets and credentials
.env
.env.*
!.env.example
*.pem
*.key

# Private directories
secrets/
private/

```

1. Open Settings (Cmd+, on Mac or Ctrl+, on Windows/Linux)
2. Search for Agent Ignore Files (setting: kiroAgent.agentIgnoreFiles)
3. Add .kiroignore to the array

Kiro will now skip any files matching your patterns.

Start with credentials and secrets—these are the highest priority files to protect. You can always expand your patterns as your project evolves.

### Setting options

The `kiroAgent.agentIgnoreFiles` setting accepts an array of filenames:

- Use multiple ignore file types simultaneously: [".gitignore", ".kiroignore"]
- Set to [] to disable workspace-level ignore files

### Subdirectory ignore files

Like `.gitignore`, you can place `.kiroignore` files in subdirectories to override or extend patterns from parent directories. Patterns in subdirectory ignore files take precedence for files within that subdirectory.

## Global ignore files

Kiro automatically honors global ignore files if they exist—no configuration needed:

- ~/.kiro/settings/kiroignore - Your global Kiro ignore patterns
- Git's global ignore file (configured via core.excludesfile in your git config) - only applied in git repositories

Use global ignore files for patterns you want applied across all your projects.

## Pattern syntax

`.kiroignore` uses standard gitignore syntax:

| Pattern | Effect |
| --- | --- |
| file.txt | Ignore specific file |
| *.log | Ignore by extension |
| folder/ | Ignore directory |
| **/temp | Ignore in any subdirectory |
| !keep.txt | Don't ignore (negation) |

You cannot re-include a file if a parent directory is excluded. For example, if you ignore `secrets/`, adding `!secrets/public.txt` won't work. To include specific files from a directory, use more specific patterns instead of excluding the entire directory.

## Examples

### Protecting API keys and secrets

```bash
# Environment files with credentials
.env
.env.local
.env.production

# Keep the template accessible
!.env.example

# Certificate and key files
*.pem
*.key
*.p12
credentials/

```

### Excluding build artifacts and data files

```bash
# Build outputs
dist/
build/
.next/

# Data files
*.sql
*.dump
data/exports/

```

### Team compliance setup

```bash
# Customer data directories
customer-data/
pii/

# Audit and compliance docs
compliance/internal/
audit-reports/

```

Use `.kiroignore` when you need different rules for agent access vs. version control, or to block files that are tracked in git but shouldn't be read by Kiro.

## Best practices

- Use comments to document why files are ignored—helpful for team members
- Test patterns by asking Kiro to read an ignored file—it will indicate access is blocked
- Review patterns periodically as your project structure evolves
- Coordinate with your team on global patterns for consistent behavior across workspaces

### Multi-root Workspaces - IDE - Docs - Kiro

# Multi-root Workspaces

---

A typical Kiro workspace contains a single “root” folder, e.g., `/users/bob/my-project`. However, Kiro also supports workspaces that contain multiple roots, e.g., a single workspace that contains both `/users/bob/my-project` and `/shared/utils/crypto` as top-level folders.

You can create a multi-root workspace from a single-root workspace by using **File > Add Folder to Workspace...** and selecting another folder, or by dragging and dropping another folder from OS X Finder or Windows File Explorer into the Explorer view in Kiro.

For single-root workspaces, Kiro stores and retrieves artifacts such as specs, steering files, hooks, etc. from the `.kiro` subfolder under that single root, e.g., in `/users/bob/my-project/.kiro` . For multi-root workspaces, Kiro supports storing and retrieving these artifacts from the `.kiro` subfolder under *each* of the root folders. The exact behavior of Kiro in a multi-root workspace scenario is described below.

## Core functionality

Kiro will resolve file paths intelligently across the root folders as it navigates and updates your multi-root workspace.

[Codebase Indexing](/docs/editor/codebase-indexing/) and Repository Maps will work seamlessly in multi-root workspaces. Both indices will contain code from all the root folders, and can be referenced in prompts exactly as in the single-root workspace scenario.

When adding a file to context using the [#file](/docs/chat/#context-providers) context provider, in cases of ambiguity where there are multiple files with that same name in different root folders, Kiro will display a list of matching files along with their path so you can select the correct one.

## Specs

Kiro will retrieve all [spec](/docs/specs/) files from the `.kiro` subfolder under each of the root folders, and display them as a unified list in the **Specs** section of the Kiro panel. The name of the containing root folder is displayed next to each spec.

You can ask Kiro to work on a spec defined under any of the root folders. When creating a new spec, Kiro will determine the appropriate root folder to place the spec into.

## Steering files

Kiro will retrieve all [steering](/docs/steering/) files from the `.kiro` subfolder under each of the root folders, and display them as a unified list in the **Agent Steering** section of the Kiro panel, under the **Workspace** group. The name of the containing root folder is displayed next to each workspace steering file.

Steering files with the “[Always Included](/docs/steering/#always-included-default)” directive are always loaded, regardless of the specific root folder the agent is working on. However, those with a “[Conditional Inclusion](/docs/steering/#conditional-inclusion)” directive are loaded only if the agent is working on a file defined in that same root (and the file, of course, matches the inclusion pattern).

When creating a new workspace steering file, you will be prompted to pick the root folder to save the steering file into.

## Hooks

Kiro will retrieve all [hooks](/docs/hooks/) from the `.kiro` subfolder under each of the root folders, and display them as a unified list within the **Agent Hooks** section of the Kiro panel. The name of the containing root folder is displayed next to each hook.

Hooks (File Create, File Save, and File Delete) will be triggered only when the agent modifies files located in the same root folder where the hook is defined.

When creating a new hook, you will be prompted to pick the root folder to save the hook into.

## MCP servers

Kiro will retrieve all [MCP server](/docs/mcp/) definitions from the `.kiro` subfolder under each of the root folders, and display them as a unified list in the **MCP Servers** section of the Kiro panel.

All MCP servers defined in all the roots are initialized at startup. In case two root folders define an MCP server with the same name, the server definition in the last defining root is used. The servers are launched with the first root folder as their current working directory, regardless of the root folder that a server was defined in.

When you click on the **Open MCP config** button in the **MCP Servers** section of the Kiro panel, you are shown the user-level (global) MCP configuration file by default, and you can then click on the **Workspace Config** button to view the workspace-level configuration. When you click on that button in a multi-root workspace, you will be prompted to pick the root folder for which to view the MCP configuration.

### Source Control - IDE - Docs - Kiro

# Source Control

---

Kiro's Source Control view provides comprehensive Git integration with AI-enhanced features to streamline your version control workflow.

## Commit message generation

Kiro automatically generates meaningful commit messages based on your staged changes using AI analysis of your code modifications.

### How to generate commit messages

1. Stage your changes in the Source Control panel
2. Click 🪄 button next to the commit message input field
3. Review the generated message - Kiro analyzes your changes and creates a descriptive commit message
4. Edit if needed - You can modify the generated message before committing
5. Commit your changes using the generated or edited message

**Tip:** You can set up a custom keyboard shortcut for `Kiro: Generate Commit Message` in your keyboard settings for faster access.

### Message format

Kiro follows the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) format with detailed body sections:

```
<type>(<scope>): <subject>

- First change or addition
- Second change or improvement
- Third change if applicable
- Why this change was needed (if relevant)

```

### Conventional commit types

- feat: New features
- fix: Bug fixes
- docs: Documentation changes
- style: Formatting changes
- refactor: Code restructuring
- test: Adding/updating tests
- chore: Maintenance tasks
- perf: Performance improvements
- ci: CI/CD changes

### Example

```
feat(docs): add comprehensive Source Control documentation
- Create new documentation page for Source Control features
- Update interface documentation to link to Source Control page
- Provide detailed explanation of AI-powered commit message generation
- Describe diff context provider and commit message generation process

```

## Git diff context provider

You can include your current git changes in any chat conversation by typing `#Git Diff`. This allows Kiro to see your staged and unstaged changes, making it easier to get contextual help with your modifications.

### Example usage

```
Hey Kiro, can you fix the merge conflicts? #Git Diff

```

## Troubleshooting

### Git operations failing

- Check your Git configuration and credentials
- Ensure you have proper permissions for the repository

### Enterprise billing - IDE - Docs - Kiro

# Enterprise billing

---

When you subscribe your team to Kiro, you can choose from the following service tiers:  **Kiro Pro**, **Kiro Pro+**, and **Kiro Power**. Depending on usage patterns, higher level tiers will give users more credits to use with Kiro.

Credits are consumed fractionally based on each request. Simple edits and shorter prompts will use fewer credits than complex, lengthy tasks. This means that fractional credits will give you more value from your credit allocation.

## Tier comparison

| Tier | Credits | Overage |
| --- | --- | --- |
| Pro | 1,000 | Opt-in |
| Pro+ | 2,000 | Opt-in |
| Power | 10,000 | Opt-in |

You are billed monthly for each user that you subscribe to Kiro. For more information, see [Kiro pricing](https://kiro.dev/pricing/).

## I've subscribed a user twice. Will I be double-billed?

It depends.

If a user is subscribed twice *under the same Kiro profile* (for example, in two different groups), then you will *not* be charged twice. Instead, you will pay the subscription price of the highest tier assigned to the user. Example: If Alice is subscribed at the Pro tier in group A, and the Pro+ tier in group B, then you will pay the Pro+ tier price for Alice.

If a user is subscribed twice under *different Kiro profiles* (for example, in two different AWS Regions), then you will be charged twice. Example: If Bob is subscribed in Profile A in Europe (Frankfurt) and Profile B in US East (N. Virginia), then you will be charged twice for Bob.

## Proration considerations

- If you unsubscribe a user mid-month, you will pay for the last month in full. The cancellation takes effect at the beginning of the following month.
- If you upgrade a subscription mid-month, you will be refunded for the lower-tier subscription, and you will be charged in full for the higher-tier subscription.
- If you downgrade a subscription mid-month, you will pay in full for the higher-tier subscription, and you will be charged for the lower-tier subscription starting the following month.

## Viewing your bill

- You can view your bill in the AWS console's Billing and Cost Management service. The Kiro expenses are listed on the Charges by service tab, under Kiro. For more information about the Billing and Cost Management service, see What is AWS Billing and Cost Management? in the AWS Billing User Guide.
- You can identify the cost of Kiro subscriptions for specific users with resource IDs through AWS Billing and Cost Management. To do so, in the Billing and Cost Management console, under Data Exports, create either a standard data export or a legacy CUR export with the Include resource IDs option selected. To learn more, refer to Creating data exports in the AWS Data Exports User Guide.

### Concepts - IDE - Docs - Kiro

# Concepts

---

## AWS IAM Identity Center

An AWS service that provides a central place to manage user identities of Kiro subscribers.

## AWS region

A physical location around the world where AWS clusters its data centers. There are two AWS Regions relevant to Kiro administrators:

- The Region where your IAM Identity Center instance is enabled. This is where user identities are managed, and where subscriptions are stored.
- The Region where your Kiro profile is created. This is where data is stored, and might be different from your IAM Identity Center instance's Region.

For more information about Regions, see [Supported Regions](../supported-regions).

## Group

A collection of users within IAM Identity Center. When you subscribe a group to Kiro, the users within it are individually subscribed. (There is no concept of a group subscription.)

## Kiro console

A console within the AWS console where you create and manage Kiro subscriptions and control settings. The Kiro console appears as **Kiro** in the drop-down list of AWS services.

## Kiro credits

A unit of consumption that measures usage of Kiro's AI-powered features. Credits are spent when you interact with AI capabilities and are replenished based on your subscription tier.

## Kiro enterprise user

A user that you have added and subscribed to a Kiro subscription tier through the AWS console, capable of accessing Kiro through IAM Identity Center.

## Kiro profile

The management abstraction that defines and enforces administrative settings and subscriptions to enterprise users in a given AWS account and Region. A Kiro profile corresponds to a combination of an AWS account (management or member) and the Region for that account. This implies that you can only have one profile for each AWS account in a given Region. You set up Kiro profiles through the Kiro console.

## Kiro subscription tier

A distinctive pricing plan with a predetermined number of Kiro credits.

### Viewing Kiro usage on the dashboard - IDE - Docs - Kiro

# Viewing Kiro usage on the dashboard

---

Available only for Kiro admins, the Kiro dashboard summarizes useful data about how your subscribers use the Kiro IDE and Kiro CLI.

Kiro generates and displays new metrics on an hourly basis for the most part. The only section that is not updated hourly is the **Active users** widget, which is updated daily according to the coordinated universal time (UTC) clock.

## View the dashboard

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console.
3. From the navigation pane, choose Dashboard.
4. (Optional) Filter the information by date range or programming language.

- If the Dashboard link is not available in the navigation pane, see Troubleshoot the dashboard.
- If you'd like to send user metrics to a daily report with a per-user breakdown of their Kiro usage, see View per-user activity in Kiro.
- For information about specific metrics, see Dashboard metrics or choose the help link at the top-right of the dashboard page.

## Disable the dashboard

You might want to disable the Kiro dashboard if you have concerns about data privacy, page load times, or other potential issues. When you disable the dashboard, the dashboard page (and any links to it) will no longer be available in the Kiro console.

For more information about the dashboard, see [viewing usage metrics (dashboard)](/docs/enterprise/monitor-and-track/dashboard/#dashboard-metrics).

#### To disable the dashboard

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console.
3. Choose Settings, and in the Kiro Settings section, disable Kiro usage dashboard.

## Troubleshoot the dashboard

If the Kiro dashboard page is not available, do the following:

- Verify your permissions. To view the dashboard, you need the following permissions:

For more information about permissions, see Policy: Allow administrators to configure Kiro and subscribe users.
  - q:ListDashboardMetrics
  - codewhisperer:ListProfiles
  - sso:ListInstances
  - user-subscriptions:ListUserSubscriptions
- Verify your settings. In the Kiro console, choose Settings and make sure that the Kiro usage dashboard toggle is enabled.

## Dashboard metrics

The following table describes the metrics shown in the Kiro dashboard.

| Metric name | Description |
| --- | --- |
| Total subscriptions per tier | Shows the total subscriptions broken down by subscription tier (Pro, Pro+, Power). Displays both per-group breakdown and total counts across all groups in the current AWS account, as well as subscriptions in member accounts if you're signed in to a management account for which organization-wide visibility of subscriptions has been enabled. |
| Active subscriptions per tier | Shows the total active subscriptions broken down by subscription tier (Pro, Pro+, Power).Active subscriptions are those belonging to users who have started using Kiro in their integrated development environment (IDE) or CLI. You are being charged for these subscriptions. For more information about active subscriptions, see Subscription statuses. |
| Pending subscriptions per tier | Shows the total pending subscriptions broken down by subscription tier (Pro, Pro+, Power).Pending subscriptions are those belonging to users who have not yet started using Kiro. You are not being charged for these subscriptions. For more information about pending subscriptions, see Subscription statuses. |
| Active users | Shows the number of unique users actively utilizing Kiro on a daily, weekly, and monthly basis. Includes breakdowns by:- Client type (IDE vs. CLI)- Subscription tier (Pro, Pro+, Power) |
| Credits consumed | Shows total Kiro credits consumed with time-based views (daily, weekly, monthly). Includes breakdowns by:- Subscription tier (Pro, Pro+, Power)- Client type (IDE vs. CLI) |

### Onboarding quickstart - IDE - Docs - Kiro

# Onboarding quickstart

---

## Audience

Read this page, and the **Enterprise** section, if you're an administrator who wants to onboard your team to Kiro and manage their subscriptions.

For detailed onboarding instructions, see [Subscribe your team to Kiro](../subscribe).

## To onboard your team to Kiro

1. Create an AWS account if you don't have one already (see Create an AWS account).
2. Sign in to your AWS account. You can sign in as an AWS root user or as a user with a privileged role. Alternatively, allow adminitrators to use Kiro with minimum permissions.
3. Enable AWS IAM Identity Center in your AWS account. Add users to its directory, or connect it to an external identity provider (IdP). If this is your first time setting up an IAM Identity Center instance, see Getting started with IAM Identity Center.
4. Create a Kiro profile and subscribe users. Within the AWS console, navigate to the Kiro console and use the available UI to create a profile and subscribe users. The profile is the glue that ties your user identities with their Kiro subscriptions and settings. Once your Kiro profile is created and connected, you can import your users and groups and subscribe your team to Kiro.
5. Have users check their email. Within 24 hours of being subscribed, users should receive an email that contains download instructions for the Kiro IDE and Kiro CLI, as well as sign-in instructions.

### How Kiro works with identity and access management (IAM) - IDE - Docs - Kiro

# How Kiro works with identity and access management (IAM)

---

To access the Kiro console and perform tasks related to your Kiro subscription, you need permissions provisioned through AWS Identity and Access Management (IAM). AWS IAM is an AWS service that helps an administrator securely control access to AWS resources and is available at no additional charge.

To enable access, you can create an identity-based policy with the necessary permissions and attach it to the IAM identity that is configuring Kiro subscriptions. For more information, see [Identity-based policies for Kiro](#identity-based-policies-for-kiro).

In addition, Kiro uses AWS IAM service-linked roles. A service-linked role is a unique type of IAM role that is linked directly to Kiro, rather than to an identity, and they are automatically created for you when you subscribe. For more information, see [Service-linked roles for Kiro](#service-linked-roles-for-kiro).

## Identity-based policies for Kiro

Identity-based policies are JSON permissions policy documents that you can attach to an identity, such as an IAM user, group of users, or role. These policies control what actions users and roles can perform, on which resources, and under what conditions.

To subscribe users and configure your subscription, you need the permissions defined in Allow administrators to configure and subscribe to Kiro in the console.

To learn how to create an identity-based policy, see [Define custom IAM permissions with customer managed policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_create.html) in the *AWS IAM User Guide*.

### Policy: allow administrators to configure Kiro and subscribe users

The following example policy grants permissions to perform actions in the Kiro console. The Kiro console is where you subscribe users to Kiro, configure Kiro’s integration with AWS IAM Identity Center and AWS Organizations, and manage subscription settings. This policy also includes permissions to create and configure customer managed KMS keys.

## Service-linked roles for Kiro

A service-linked role is a unique type of IAM role that is linked directly to Kiro. Service-linked roles are predefined by AWS and include all the permissions that Kiro requires to call other AWS services on your behalf.

A service-linked role makes setting up Kiro easier because you don’t have to manually add the necessary permissions. Kiro defines the permissions of its service-linked roles, and unless defined otherwise, only Kiro can assume its roles. The defined permissions include the trust policy and the permissions policy, and that permissions policy cannot be attached to any other IAM entity.

You can delete a service-linked role only after first deleting their related resources. This protects your Kiro resources because you can't inadvertently remove permission to access the resources. For more information about service-linked roles, see the [AWS IAM User Guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html#id_roles_terms-and-concepts).

There are two service-linked roles that will be created for you when you subscribe with Kiro enterprise:

- AWSServiceRoleForUserSubscriptions
- AWSServiceRoleForAmazonQDeveloper

### Service-linked role: AWSServiceRoleForUserSubscriptions

Kiro uses the service-linked role named **AWSServiceRoleForUserSubscriptions**. This role grants permissions for Kiro to access your IAM Identity Center resources in order to automatically update your subscriptions.

The AWSServiceRoleForUserSubscriptions service-linked role trusts the following services to assume the role:

- user-subscriptions.amazonaws.com

The role permissions policy named AWSServiceRoleForUserSubscriptions allows Kiro to complete the following actions on the specified resources:

- Action: identitystore:DescribeGroup on *
- Action: identitystore:DescribeUser on *
- Action: identitystore:IsMemberInGroups on *
- Action: identitystore:ListGroupMemberships on *
- Action: organizations:DescribeOrganization on *
- Action: sso:DescribeApplication on *
- Action: sso:DescribeInstance on *
- Action: sso:ListInstances on *
- Action: sso-directory:DescribeUser on *

You must configure permissions to allow your users, groups, or roles to create, edit, or delete a service-linked role. For more information, see [Service-linked role permissions](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create-service-linked-role.html#service-linked-role-permissions) in the *AWS IAM User Guide*.

### Service-linked role: AWSServiceRoleForAmazonQDeveloper

Kiro uses the service-linked role named **AWSServiceRoleForAmazonQDeveloper**. This role grants permissions for Kiro to access data in your account to calculate billing, provides access to create and access security reports in Amazon CodeGuru, and emit data to CloudWatch.

The AWSServiceRoleForAmazonQDeveloper service-linked role trusts the following services to assume the role:

- q.amazonaws.com

The role permissions policy named AWSServiceRoleForAmazonQDeveloper allows Kiro to complete the following actions on the specified resources:

- Action: cloudwatch:PutMetricData on AWS/Q CloudWatch namespace

You must configure permissions to allow your users, groups, or roles to create, edit, or delete a service-linked role. For more information, see [Service-linked role permissions](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create-service-linked-role.html#service-linked-role-permissions) in the *AWS IAM User Guide*.

### Managing service-linked roles

You don't need to manually create a service-linked role. When you create a profile for Kiro in the AWS Management Console, Kiro creates the service-linked role for you. If you delete this service-linked role, and then need to create it again, you can use the same process to recreate the role in your account.

You can also use the IAM console or AWS CLI to create a service-linked role with the `q.amazonaws.com` service name. For more information, see [Creating a service-linked role](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html#create-service-linked-role) in the *AWS IAM User Guide*. If you delete this service-linked role, you can use the same process to create the role again.

Kiro does not allow you to edit the AWSServiceRoleForUserSubscriptions or AWSServiceRoleForAmazonQDeveloper service-linked roles. After you create a service-linked role, you cannot change the name of the role because various entities might reference the role. However, you can edit the description of the role using IAM. For more information, see [Editing a service-linked role](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html#edit-service-linked-role) in the *AWS IAM User Guide*.

If you no longer need to use a feature or service that requires a service-linked role, we recommend that you delete that role. That way you don’t have an unused entity that is not actively monitored or maintained. However, you must clean up the resources for your service-linked role before you can manually delete it. Use the IAM console, the AWS CLI, or the AWS API to delete the service-linked roles. For more information, see [Deleting a service-linked role](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html#delete-service-linked-role) in the *AWS IAM User Guide*.

Note: If Kiro is using the role when you try to delete the resources, then the deletion might fail. If that happens, wait for a few minutes and try the operation again.

### Supported regions for Kiro service-linked roles

You can use the AWSServiceRoleForUserSubscriptions and AWSServiceRoleForAmazonQDeveloper roles in the following AWS Regions. For more information on Regions, see [AWS Regions and endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the *AWS General Reference*.

| Region name | Region identity |
| --- | --- |
| US East (N. Virginia) | us-east-1 |
| Europe (Frankfurt) | eu-central-1 |

### Monitoring and tracking - IDE - Docs - Kiro

# Monitoring and tracking

Monitoring is an important part of maintaining the reliability, availability, and performance of Kiro and your other AWS solutions. Kiro includes the following features to help you track and record user activity:

- A dashboard shows you aggregate user activity metrics of Kiro subscribers. For more information, see Viewing Kiro usage on the dashboard.
- User activity reports show you what individual users are up to in Kiro. For more information, see Viewing per-user activity.
- Prompt logs provide you with a record of all the prompts that users enter into the Kiro chat in their integrated development environment (IDE). For more information, see Logging users' prompts.

AWS also provides the following tools and features to monitor and record Kiro activity:

- AWS CloudTrail captures API calls and related events made by or on behalf of your AWS account and delivers the log files to an Amazon Simple Storage Service (Amazon S3) bucket that you specify. You can identify which users and accounts called AWS, the source IP address from which the calls were made, and when the calls occurred.
- Amazon CloudWatch monitors your AWS resources and the applications you run on AWS in real time. You can collect and track metrics, create customized dashboards, and set alarms that notify you or take actions when a specified metric reaches a threshold that you specify. For example, you can have CloudWatch track the number of times that Kiro has been invoked on your account, or the number of daily active users.

---

### Logging user prompts - IDE - Docs - Kiro

# Logging user prompts

---

Kiro admins can enable the logging of all inline suggestions and chat conversations that users have in the Kiro IDE. These logs can help with auditing, debugging, analytics, and ensuring compliance.

## About prompt logs

With prompt logging enabled, Kiro will log both the user prompts and Kiro's responses. Kiro stores the logs in an Amazon S3 bucket of your choice in your own account. For examples and explanations of log file contents, see [prompt log examples](#prompt-log-examples).

There is no charge for the prompt logging feature other than the storage cost of the Amazon S3 bucket used to hold the logs, and a small fee for the optional KMS key used to encrypt the bucket.

## Enabling prompt logging

### Prerequisites

- Create an Amazon S3 bucket to hold the prompt logs. The bucket must:
  - Be in the AWS Region where the Kiro profile was installed. This profile was installed when you subscribed users to Kiro Pro for the first time. For more information about this profile and the Regions where it's supported, see Concepts and Supported Regions.
  - Be in the AWS account where users are subscribed.
  - Have a bucket policy like the one that follows. Replace bucketName, Region, accountId, and prefix with your own information.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "KiroLogsWrite",
      "Effect": "Allow",
      "Principal": {
        "Service": "q.amazonaws.com"
      },
      "Action": [
        "s3:PutObject"
      ],
      "Resource": [
        "arn:aws:s3:::bucketName/prefix/*"
      ],
      "Condition": {
        "StringEquals": {
          "aws:SourceAccount": "111122223333"
        },
        "ArnLike": {
          "aws:SourceArn": "arn:aws:codewhisperer:us-east-1:111122223333:*"
        }
      }
    }
  ]
}

```

To learn about protecting the data in your Amazon S3 bucket, see [Protecting data with encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingEncryption.html) in the *Amazon Simple Storage Service User Guide*.

### To enable prompt logging

1. Open the Kiro console.
2. Choose Settings.
3. Look for Kiro Settings > Logging.
4. Toggle the switch for Log Kiro prompts with metadata.
5. Under Amazon S3 location, enter the Amazon S3 URI that you will use to receive the logs. Example: s3://amzn-s3-demo-bucket/kiro-prompt-logs/

## Prompt log examples

This section provides examples of prompt logs generated by Kiro.

Following each example is a table that describes the log file's fields.

### Inline suggestions log example

The following example shows a log file that is generated when a user accepts an inline suggestion.

```json
{
  "records": [
    {
      "generateCompletionsEventRequest": {
        "leftContext": "import * cdk from 'aws-cdk-lib';\r\nimport * s3 from 'aws-cdk-lib/aws-s3';\r\nimport { Stack, StackProps } from 'constructs';\r\nexport class MyStack extends Stack {\r\n  constructor(scope: cdk.App, id: string, props?: StackProps) {\r\n    super(scope, id, props);\r\n\r\n    new s3.Bucket(this, 'XXXXXXXX', {\r\n      versioned: true\r\n    });\r\n  }\r\n ",
        "rightContext": "",
        "fileName": "cdk-modified.ts",
        "customizationArn": null,
        "userId": "d-92675051d5.b8f1f340-9081-70ad-5fc5-0f37151937a6",
        "timeStamp": "2025-01-06T15:09:16.412719Z"
      },
      "generateCompletionsEventResponse": {
        "completions": ["synth() {\n    return cdk.App.prototype.synth.apply(this, arguments);\n  }"],
        "requestId": "797c70ee-abc9-4cc7-a148-b9df17f6ce48"
      }
    }
  ]
}

```

The following table describes the fields in the log file for inline suggestions.

| Field name | Description |
| --- | --- |
| records | Top-level field that contains a set of inline suggestions, also known as inline completions. |
| generateCompletionsEventRequest | Describes the request for an inline code suggestion. The request is made by Kiro, on behalf of the user. |
| leftContext | Indicates the code before the cursor that Kiro is using for context to generate an inline suggestion. |
| rightContext | Indicates the code after the cursor that Kiro is using for context to generate an inline suggestion. |
| fileName | Indicates the name of the file in which an inline suggestion was requested. |
| userId | Indicates the user ID of the user who requested an inline suggestion. |
| timeStamp | Indicates the date and time that the inline suggestion was requested. The timestamp is in Coordinated Universal Time (UTC). |
| generateCompletionsEventResponse | Describes the inline suggestion generated by Kiro. |
| completions | Indicates the inline suggestion that Kiro provided and that the user accepted. |
| requestId | The ID of the inline request that uniquely identifies the event. |

### Chat log example

The following example shows a log file that is generated when a user chats using Kiro in their IDE.

```json
{
  "records": [
    {
      "generateAssistantResponseEventRequest": {
        "prompt": "Can you explain how to set up object-level access control in an S3 bucket using AWS CDK?",
        "chatTriggerType": "MANUAL",
        "customizationArn": null,
        "userId": "d-92675051d5.b8f1f340-9081-70ad-5fc5-0f37151937a6",
        "timeStamp": "2025-01-06T15:05:56.313070Z"
      },
      "generateAssistantResponseEventResponse": {
        "assistantResponse": "I'll explain how to set up object-level access control for an S3 bucket using AWS CDK...",
        "followupPrompts": "How can you implement multi-factor authentication for S3 bucket access using AWS CDK?",
        "messageMetadata": {
          "conversationId": "491bd3cd-d70d-40c0-a452-5ef3f0878422",
          "utteranceId": null
        },
        "codeReferenceEvents": [],
        "supplementaryWebLinksEvent": [
          {
            "uri": "https://docs.aws.amazon.com/AmazonS3/latest/API/s3_example_s3_Scenario_ManageACLs_section.html",
            "title": "[1] Manage access control lists (ACLs) for Amazon S3 buckets using an AWS SDK",
            "snippet": "The following code example shows how to manage access control lists (ACLs) for Amazon S3 buckets..."
          }
        ],
        "requestId": "dad38fc0-815c-45f7-970a-db916cb7f131"
      }
    }
  ]
}

```

| Field name | Description |
| --- | --- |
| records | Top-level field that contains a set of prompts and responses. |
| generateAssistantResponseEventRequest | Describes the prompt entered by the user in the chat window in their IDE. |
| prompt | Indicates the prompt the user entered into the chat window. |
| chatTriggerType | MANUAL indicates that the user entered a prompt into the chat window, or clicked on one of the suggested questions in the chat window. INLINE_CHAT indicates that the user entered a prompt into the small input screen in the main coding window. |
| userId | Indicates the user ID of the user who entered the prompt. |
| timeStamp | Indicates the date and time that the user entered the prompt. The timestamp is in universal time (UTC). |
| generateAssistantResponseEventResponse | Describes the response generated by Kiro. |
| assistantResponse | Indicates the response that Kiro provided to the user's prompt. |
| followupPrompts | Indicates the follow-up example prompts that were displayed to the user at the end of the response. |
| messageMetadata | Describes metadata associated with the response. |
| conversationId | Indicates the conversation ID of the response. The conversation ID groups together messages in a chat session. |
| utteranceId | Indicates the utterance ID of the response. An utterance ID is a label that distinguishes one prompt from another within a dialogue or data set. |
| codeReferenceEvents | Describes links to code references included in the response. |
| supplementaryWebLinksEvent | Indicates the links that were displayed to the user at the end of the response. |
| requestId | The ID of the response that uniquely identifies the event. |

### Settings - IDE - Docs - Kiro

# Settings

---

An administrator can control the following settings in a [Kiro profile](../concepts/#kiro-profile).

| Setting | Description |
| --- | --- |
| Encryption key | By default, Kiro uses an AWS managed key to encrypt your data at rest. For some features, instead of using an AWS managed key, you can use your own key. This is known as a customer-managed key. To specify a customer-managed key, enable Encryption key and use the available UI to specify a new or existing key. For details about which features' data can be encrypted with a customer managed key, see Encryption at rest. |
| Include suggestions with code references | Kiro learns, in part, from open-source projects. Sometimes, Kiro suggests code that is similar to publicly available code. When you enable Include suggestions with code references, Kiro will include information about the source used to generate a suggestion. |
| Kiro usage dashboard | Enable Kiro usage dashboard to display a dashboard on the Kiro console's main page. For more information about the dashboard, see Viewing Kiro usage on the dashboard. |
| Kiro user activity report | Enable Kiro user activity report to allow Kiro to collect user activity telemetry of individual Kiro subscribers in your organization and present that information in a report. For more information, see Viewing per-user activity. |
| Prompt logging | Enable Logging to allow Kiro to record all inline suggestions and chat conversations that users have in the Kiro IDE. For more information, see Logging users' prompts. |
| Member account subscriptions | If you are a management account administrator within an organization managed by AWS Organizations, you can configure Kiro to display Kiro subscriptions from both management and member accounts in a single, unified list on the Subscriptions page of the Amazon Q console (not the Kiro console) while signed in to your management account. This organization-wide visibility eliminates the need to sign in to multiple accounts to track your subscriptions. To have all Kiro subscriptions be displayed in the Amazon Q console, enable the Member account subscriptions setting. This setting is only visible when signed in to the AWS console as a management account administrator. |
| Model Context Protocol (MCP) | Enable the Model Context Protocol (MCP) setting to allow Kiro subscribers to use MCP servers. |
| Web Tools | Enable Web Tools to allow Kiro subscribers to use the web_search and web_fetch tools for searching the web and fetching content from URLs. When disabled, these tools are hidden from users and a notification appears in /tools. |
| Overages | Enable Overages to allow Kiro subscribers to continue working when they exceed their plan limits. For more information see Enabling overages for Kiro users. |

## Web tools

The **Web Tools** setting controls whether users can use the `web_search` and `web_fetch` tools for searching the web and fetching content from URLs.

To disable both the web fetch and web search tools for all Kiro users in your account or organization:

1. Open the Kiro console
2. Choose Settings
3. Under Shared settings, toggle Web search and web fetch tools to Off

When web tools are disabled, users see a notification in `/tools` indicating that web access has been disabled by their administrator.

### Subscribing your team to Kiro - IDE - Docs - Kiro

# Subscribing your team to Kiro

---

## Prerequisites

Before you begin, make sure you have the following:

- An AWS account - You can create an AWS account if you do not have one already.
- AWS permissions - As a Kiro admin, you must have the permissions to access the Kiro console in AWS in order to subscribe and manage Kiro users. The minimum permissions you'll need are described in Policy: Allow administrators to configure Kiro and subscribe users.
- AWS IAM Identity Center - You must have an instance of IAM Identity Center set up in your AWS account, with the identities of the users you want to subscribe to Kiro. Your IAM Identity Center instance must be in a supported AWS Region.
- Users and groups - You can add users and groups to IAM Identity Center's built-in directory, or to an external identity provider (IdP) that is connected to IAM Identity Center. For more information, see Getting started with IAM Identity Center.

## Create the Kiro profile

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console.
3. Make sure you are in your preferred supported AWS Region to create the Kiro profile and store user data.
4. Choose the Sign up for Kiro button.
5. Review the contents of the Create Kiro profile dialog box then choose Enable. The Kiro profile is created.
6. (Optional) Edit the profile with a different name or description as needed in the Settings page.

## Subscribe your team to Kiro

1. Switch to the Kiro console if you're not there yet.
2. Make sure you're in the AWS Region where you created the Kiro profile.
3. In the Users & Groups page, choose the Users or Groups tab.
4. Choose the Add user or Add group button. A dialog box appears where you can select the Kiro subscription tier (Pro, Pro+, Power) with details about each tier.
5. Choose the desired subscription tier and choose Continue.
6. In the search bar, search for a group or a user you want to subscribe to the selected tier, or select one from the drop down.
7. The group or user will auto-populate with what is available in the IAM Identity Center.
8. Select them and choose Assign. Users or groups are now subscribed.

### Managing Kiro subscriptions - IDE - Docs - Kiro

# Managing Kiro subscriptions

---

## Change Kiro subscription plans

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console. If you don't see it, you might be in the wrong AWS Region.
3. In the Users & Groups page, choose the Users or Groups tab.
4. Choose the user or group whose subscriptions you want to upgrade or downgrade.
5. Choose Change plan then choose the new plan. Select Continue to finish.
6. If it is a higher tier plan, changes will happen immediately. If it is a lower tier plan, changes happen at the beginning of the following month.

To learn about what's offered at each subscription tier, see [Enterprise billing](../billing).

## Unsubscribe Kiro users

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console. If you don't see it, you might be in the wrong AWS Region.
3. In the Users & Groups page, choose the Users or Groups tab.
4. Choose the user or group whose subscriptions you want to cancel.
5. Choose Deactivate plan. Review the contents of the Unsubscribee dialog box then choose Unsubscribe.

After users unsubscribe, their subscriptions are marked as **Canceled**. They will lose access
immediately and can no longer access paid Kiro features.

## Enable overages for Kiro users

You might want to enable overages to give users the ability to continue working when they exceed their plan limits. Enabling overages has the following advantages:

- Uninterrupted productivity – When a user exceeds their plan's quota, they can continue working without disruption. The productivity benefits of continued access might outweigh the additional costs.
- Better usage pattern insights – Users get more accurate data about their actual usage, which helps in right-sizing future subscription needs.

By default, overages are *disabled*. Once enabled, overages become available to all users and groups in the profile. To enable overages:

1. Sign in to the AWS Management Console.
2. Switch to the Kiro console. If you don't see it, you might be in the wrong AWS Region.
3. Choose Settings.
4. Find the Kiro settings section.
5. Turn on Overages.

Setting custom caps for overages is not yet supported (coming soon).

## Subscription statuses

You can view the status of your users' subscriptions on the **Subscriptions** page of the Kiro console. The statuses on the **User** tab are:

- Active – The user is subscribed to Kiro. You will be charged for active user subscriptions in the group.
- Canceled – The user subscription was canceled by an administrator. Unsubscribed users in the group can no longer access paid Kiro features. For more information, see Unsubscribe Kiro users.
- Pending – The user is subscribed but has not activated their subscription. You are not being charged for this subscription and there will be no data under Last active column.

There are no statuses on the **Groups** tab since subscriptions are assigned to users, not groups.

### Supported regions - IDE - Docs - Kiro

# Supported regions

---

There are two AWS Regions relevant to Kiro administrators:

- The Region where your IAM Identity Center instance is enabled. This is where user identities are managed, and where subscriptions are stored.
- The Region where your Kiro profile is created. This is where data is stored and inference is done, and might be different from your IAM Identity Center instance's Region.

## Supported Kiro console and Kiro profile regions

The **Kiro** **console** and **Kiro profile** are supported in the following Regions:

- US East (N. Virginia)
- Europe (Frankfurt)

## IAM identity center regions supported by Kiro

The users that you want to subscribe to Kiro must have identities in an IAM Identity Center instance (or a connected identity provider) in one of the following Regions:

- US East (Ohio)
- US East (N. Virginia)
- US West (N. California)
- US West (Oregon)
- Asia Pacific (Mumbai)
- Asia Pacific (Osaka)
- Asia Pacific (Seoul)
- Asia Pacific (Singapore)
- Asia Pacific (Sydney)
- Asia Pacific (Tokyo)
- Canada (Central)
- Europe (Frankfurt)
- Europe (Ireland)
- Europe (London)
- Europe (Paris)
- Europe (Stockholm)
- South America (São Paulo)

### Viewing per-user activity - IDE - Docs - Kiro

# Viewing per-user activity

---

You can configure Kiro to collect user activity telemetry of individual Kiro subscribers in your organization and present that information in a report. The report gives you insights into how specific users are using Kiro.

## About the report

Kiro generates the user activity report every day at midnight (00:00) Coordinated Universal Time (UTC), and saves it in a CSV file at the following path:

`s3://bucketName/prefix/AWSLogs/accountId/KiroLogs/  by_user_analytic/Region/year/month/day/00/accountId_by_user_analytic_timestamp.csv`
The CSV file is laid out as follows:

- Each row shows a user who interacted with Kiro that day.
- Each column shows a metric, as described in User activity report metrics. Metrics are calculated based on the user telemetry collected over the course of the day.

If more than 1,000 users interact with Kiro during the day, Kiro splits the data into several CSV files containing 1,000 users each. Files are suffixed with `part_1`, `part_2`, and so on.

When you enable user activity reports, Kiro collects user telemetry and stores it in the S3 bucket in your account. This is controlled at the administrator level and can't be configured by users.

## Enable user activity reports

Use the following instructions to enable user activity reports.

#### Prerequisite

Create an Amazon S3 bucket to hold the user activity report CSV file. The bucket must:

- Be in the AWS Region where the Kiro profile was installed. This profile was installed when you subscribed IAM Identity Center workforce users to Kiro Pro for the first time. For more information about this profile and the Regions where it's supported, see Kiro profile and Supported Regions.
- Be in the AWS account where users are subscribed. If users are subscribed in multiple AWS accounts, then you must create buckets in each of those accounts. Cross-account buckets are not supported.
- (Optional but recommended) Be different from the bucket you might be using for logging users' prompts.
- Include a prefix, also known as a subfolder, where Kiro will save the CSV file. The CSV file cannot be saved in the root of the bucket.
- Have a bucket policy like the one that follows. Replace bucketName, Region, accountId, and prefix with your own information.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "KiroLogsWrite",
      "Effect": "Allow",
      "Principal": {
        "Service": "q.amazonaws.com"
      },
      "Action": [
        "s3:PutObject"
      ],
      "Resource": [
        "arn:aws:s3:::bucketName/prefix/*"
      ],
      "Condition": {
        "StringEquals": {
          "aws:SourceAccount": "111122223333"
        },
        "ArnLike": {
          "aws:SourceArn": "arn:aws:codewhisperer:us-east-1:111122223333:*"
        }
      }
    }
  ]
}

```

To learn about protecting the data in your Amazon S3 bucket, see [Protecting data with encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingEncryption.html) in the *Amazon Simple Storage Service User Guide*.

#### To enable user activity reports

1. Sign in to the AWS console.
2. Switch to the Kiro console. To use the Kiro console, you must have the permissions defined in Policy: Allow administrators to configure Kiro and subscribe users.
3. Choose Settings.
4. Under Kiro user activity reports, choose Edit.
5. Toggle Collect granular metrics per user.
6. Under S3 location, enter the Amazon S3 URI that you will use to hold the CSV reports. Example: s3://amzn-s3-demo-bucket/user-activity-reports/

## User activity report metrics

The following table describes the metrics that are included in the user activity reports generated by Kiro.

| Metric name | Description |
| --- | --- |
| Chat_AICodeLines | Lines of code suggested by Kiro and accepted by the user. This metric includes code that was generated through the Kiro chat (not inline chat) and inserted into the IDE. |
| Chat_MessagesInteracted | Number of chat messages where the user has interacted positively with Kiro. Examples of positive interactions: clicking a link, inserting a suggestion, and upvoting a response from Kiro. This metric includes messages that were generated by Kiro chat (not inline chat). |
| Chat_MessagesSent | Number of messages sent to and from Kiro. This metric includes the user prompts and Kiro responses in the Kiro chat (not inline chat). |
| CodeFix_AcceptanceEventCount | Number of code fixes suggested by Kiro and accepted by the user. This metric applies to code fixes generated through the code review feature. |
| CodeFix_AcceptedLines | Lines of code suggested by Kiro and accepted by the user. This metric applies to lines of code generated through the code review feature. |
| CodeFix_GeneratedLines | Lines of code suggested by Kiro. This metric applies to lines of code generated through the code review feature. |
| CodeFix_GenerationEventCount | Number of code fixes suggested by Kiro. This metric applies to code fixes generated through the code review feature. |
| CodeReview_FailedEventCount | Number of code issues that were found but for which Kiro could not suggest a code fix. This metric applies to code issues generated using the code review feature. |
| CodeReview_FindingsCount | Number of code issues found by Kiro. This metric applies to code issues found using the code review feature. |
| CodeReview_SucceededEventCount | Number of code issues that were found and for which Kiro was able to generate a suggested code fix. This metric applies to code issues found using the code review feature. |
| Dev_AcceptanceEventCount | Number of code features suggested by Kiro and accepted by the user. This metric applies to code features generated through the /dev command. |
| Dev_AcceptedLines | Lines of code suggested by Kiro and accepted by the user. This metric applies to lines of code generated through the /dev command. |
| Dev_GeneratedLines | Lines of code suggested by Kiro. This metric applies to lines of code generated through the /dev command. |
| Dev_GenerationEventCount | Number of code features suggested by Kiro. This metric applies to code features generated through the /dev command. |
| DocGeneration_AcceptedFileUpdates | Number of file updates suggested by Kiro and accepted by the user. This metric applies to file updates generated through the /doc command. |
| DocGeneration_AcceptedFilesCreations | Number of file creations suggested by Kiro and accepted by the user. This metric applies to file creations generated through the /doc command. |
| DocGeneration_AcceptedLineAdditions | Lines of documentation additions suggested by Kiro and accepted by the user. This metric applies to documentation generated through the /doc command. |
| DocGeneration_AcceptedLineUpdates | Lines of documentation updates suggested by Kiro and accepted by the user. This metric applies to documentation generated using the /doc command. |
| DocGeneration_EventCount | Number of times the user engaged with Kiro using the /doc command. |
| DocGeneration_RejectedFileCreations | Number of file creations suggested by Kiro and rejected by the user. This metric applies to file creations generated through the /doc command. |
| DocGeneration_RejectedFileUpdates | Number of file updates suggested by Kiro and rejected by the user. This metric applies to file updates generated through the /doc command. |
| DocGeneration_RejectedLineAdditions | Lines of documentation additions suggested by Kiro and rejected by the user. This metric applies to documentation generated through the /doc command. |
| DocGeneration_RejectedLineUpdates | Lines of documentation updates suggested by Kiro and rejected by the user. This metric applies to documentation generated using the /doc command. |
| InlineChat_AcceptedLineAdditions | Lines of code additions suggested by Kiro and accepted by the user. This metric includes code additions generated through the inline chat (not Kiro chat). |
| InlineChat_AcceptedLineDeletions | Lines of code deletions suggested by Kiro and accepted by the user. This metric includes code deletions suggested through the inline chat (not Kiro chat). |
| InlineChat_AcceptanceEventCount | Number of inline chat (not Kiro chat) suggestions that were accepted by the user. |
| InlineChat_DismissalEventCount | Number of inline chat (not Kiro chat) suggestions that were abandoned by the user. By 'abandoned', we mean that the code suggestion was displayed but the user kept typing or performing other operations in their IDE, and did not explicitly accept or reject the code suggestion. |
| InlineChat_DismissedLineAdditions | Lines of code additions suggested by Kiro and abandoned by the user. By 'abandoned', we mean that the code suggestion was displayed but the user kept typing or performing other operations in their IDE, and did not explicitly accept or reject the code suggestion. This metric includes code additions generated through the inline chat (not Kiro chat). |
| InlineChat_DismissedLineDeletions | Lines of code deletions suggested by Kiro and abandoned by the user. By 'abandoned', we mean that the code suggestion was displayed but the user kept typing or performing other operations in their IDE, and did not explicitly accept or reject the code suggestion. This metric includes code deletions suggested through the inline chat (not Kiro chat). |
| InlineChat_EventCount | Number of inline chat (not Kiro chat) sessions that the user engaged in. |
| InlineChat_RejectedLineAdditions | Lines of code additions suggested by Kiro and rejected by the user. This metric includes code additions generated through the inline chat (not Kiro chat). |
| InlineChat_RejectedLineDeletions | Lines of code deletions suggested by Kiro and rejected by the user. This metric includes code deletions suggested through the inline chat (not Kiro chat). |
| InlineChat_RejectionEventCount | Number of inline chat (not Kiro chat) suggestions that were rejected by the user. |
| Inline_AICodeLines | Lines of code suggested by Kiro and accepted by the user. This metric includes code that was accepted as inline suggestions. |
| Inline_AcceptanceCount | Number of inline suggestions accepted by the user. |
| Inline_SuggestionsCount | Number of inline suggestions displayed to the user. |
| TestGeneration_AcceptedLines | Lines of code suggested by Kiro and accepted by the user. This metric applies to lines of code generated through the /test command. |
| TestGeneration_AcceptedTests | Number of unit tests suggested by Kiro and accepted by the user. This metric applies to unit tests generated through the /test command. |
| TestGeneration_EventCount | Number of times the user engaged with Kiro through the /test command. |
| TestGeneration_GeneratedLines | Lines of code suggested by Kiro. This metric applies to lines of code generated through the /test command. |
| TestGeneration_GeneratedTests | Number of unit tests suggested by Kiro. This metric applies to unit tests generated through the /test command. |
| Transformation_EventCount | Number of times the user engaged with Kiro through the /transform command, excluding the times when the user transformed code on the command line. |
| Transformation_LinesGenerated | Lines of code suggested by Kiro. This metric applies to code generated through the /transform command, excluding code transformed on the command line. |
| Transformation_LinesIngested | Lines of code provided to Kiro for transformation. This metric applies to code that is provided through the /transform command, excluding code provided for transformation on the command line, or for an SQL conversion. |

### Authentication methods - IDE - Docs - Kiro

# Authentication methods

---

Kiro supports the following authentication providers:

- GitHub: Seamless integration with your GitHub account
- Google: Sign in with your Google credentials
- AWS Builder ID: Quick setup for individual developers
- AWS IAM Identity Center: Enterprise-grade authentication

Users that have a paid Kiro subscription and access it through a social login provider (like GitHub or Google) or through AWS Builder ID are considered *individual subscribers*. We may use certain content from Kiro Free Tier and Kiro individual subscribers for service improvement. For more information on service improvement and how to opt out, see [Service improvement](/docs/privacy-and-security/data-protection/#service-improvement).

Kiro is an AWS application that works as a standalone agentic IDE without needing to set up an AWS account. You can download and use Kiro immediately without any external account setup - it handles AI interactions and code assistance directly through the application itself. Whether you're developing with other AWS services or not, you can leverage Kiro's full capabilities to enhance your development workflow.

## Available authentication methods

### GitHub

Use the following instructions to sign in to Kiro using GitHub.

**To sign in with GitHub**

1. In Kiro, choose Sign in with GitHub. You will be redirected to your default web browser to complete the sign in process.
2. Enter your username or email address and your password and then choose Sign in.
3. Choose Authorize kirodotdev to authorize the Kiro App with your GitHub account.

### Google

Use the following instructions to sign in to Kiro using Google.

**To sign in with Google**

1. In Kiro, choose Sign in with Google. You will be redirected to your default web browser to complete the sign in process.
2. Choose a Google account that you’d like to use with Kiro.
3. Choose Continue to authorize the Kiro App with your Google account.

### AWS Builder ID

Use the following instructions to sign in to Kiro using AWS Builder ID.

**To sign in with AWS Builder ID**

1. In Kiro, choose Login with AWS Builder ID. You will be redirected to your default web browser to complete the sign in process.
2. Enter your email address and then choose Next.
3. Enter your password and then choose Sign in.
4. Choose Allow access to authorize the Kiro App.

### AWS IAM Identity Center

Use the following instructions to sign in to Kiro using AWS IAM Identity Center.

**To sign in with AWS IAM Identity Center**

1. In Kiro, choose Sign in with AWS IAM Identity Center.
2. In Start URL, enter the start URL provided by your admin or help desk.
3. In Region, enter the AWS Region that hosts the identity directory, and then choose Continue.

## Troubleshooting authentication issues

If you encounter problems during the authentication process, such as browser redirect failures or sign-in errors, check our [troubleshooting guide](/docs/troubleshooting/#authentication-issues) for platform-specific solutions and common fixes.

## Next steps

- Review FAQ
- Explore Agent features
- Get started with Kiro

### Your first project - IDE - Docs - Kiro

# Your first project

---

This guide walks you through Kiro's essential features by working with a real project. You'll learn how to use steering files, specs, hooks, and MCP servers to enhance your development workflow.

## Prerequisites

Before starting, ensure you have:

- Installed Kiro.
- A project to work with (either an existing project or a new one)
- Basic familiarity with your project's structure and technology stack

## Open your project

1. Launch Kiro and open your project:
  - Use File > Open Folder to select your project directory
  - Or drag and drop your project folder into Kiro
  - Or go to the command line and run kiro . from your project directory
2. Access the Kiro Panel:
  - Click the Kiro Ghost icon in the activity bar (left sidebar)
  - This panel provides access to all of Kiro's AI-powered features
3. Start a Chat Session:
  - The chat pane should be open by default
  - This opens Kiro's conversational interface where you can interact with the AI

## Set up Steering files

Steering files provide context about your project, helping Kiro understand your codebase, conventions, and requirements.

To get started choose `Generate Steering Docs` from the Kiro pane. Kiro generates project steering documents for you stored in `.kiro/steering/` that guide Kiro's behavior. They contain information about:

- Your product and its purpose
- Technical stack and frameworks
- Project structure and conventions

You can also create custom steering files by clicking the `+` button in the steering section and add things like coding standards, and workflows, and team best practices. Learn about steering [here](/docs/steering/).

## Build features with Specs

Specs transform high-level feature ideas into detailed implementation plans through three phases:

1. Requirements - User stories with acceptance criteria in EARS notation
2. Design - Technical architecture and implementation approach
3. Tasks - Discrete, trackable implementation steps

### Create your first Spec

1. Start a New Spec:
  - In your chat session, click the Spec button
  - Choose the + button in the Kiro panel's Specs section
2. Enter a feature description:
  - Describe your feature in natural language
  - Example: "Add a user authentication system with login, logout, and password reset functionality"
3. Follow the Guided Workflow:
  - Requirements Phase: Kiro will help structure your requirements using EARS notation
  - Design Phase: Technical architecture and component design will be documented
  - Implementation Phase: Discrete tasks will be generated for execution

### Execute Spec tasks

Once your spec is complete:

1. Review Generated Tasks in the tasks.md file
2. Execute Tasks by clicking on individual task items
3. Track Progress as tasks automatically update to "In Progress" and "Done"

## Automate workflows with Hooks

Agent Hooks eliminate manual work by automatically executing predefined actions when:

- Files are created, saved, or deleted
- Manual triggers are activated
- Specific file patterns are modified

To get started:

1. Access Hook Creation:
  - Navigate to the Agent Hooks section in the Kiro panel
  - Click the + button to create a new hook
2. Define Hook Behavior:
  - Describe what you want automated in natural language
  - Example: "When I save a React component file, automatically create or update its corresponding test file"
3. Configure Hook Settings:
  - Event Type: Choose from File Created, File Saved, File Deleted, or Manual Trigger
  - File Pattern: Specify which files should trigger the hook (e.g., src/**/*.tsx)
  - Instructions: Define the specific actions to perform

## Extend capabilities with MCP

Model Context Protocol (MCP) allows Kiro to:

- Access specialized knowledge bases and documentation
- Integrate with external APIs and services
- Use domain-specific tools and utilities
- Connect to databases and cloud services

### Set up MCP

1. Open the Kiro panel by clicking the Kiro Ghost icon in the activity bar. First enable MCPs, and then click the edit button (pencil icon) next to MCP in the panel
2. By default, Kiro ships with the fetch MCP server in the JSON file. Flip it to disabled=false to connect to it.
3. You can also Add any MCP Server by asking Kiro to add a new server or editing the JSON file directly:
json{
  "mcpServers": {
    "web-search": {
      "command": "uvx",
      "args": ["mcp-server-brave-search"],
      "env": {
        "BRAVE_API_KEY": "your-api-key-here"
      },
      "disabled": false,
      "autoApprove": ["search"]
    }
  }
}

### Use MCP tools

Once configured, you can use MCP tools in several ways:

- Direct Questions
  - Ask questions that leverage the MCP server's capabilities:
  - Example: Search for the latest React 18 best practices
- Explicit Tool Usage
  - Reference specific MCP tools with the #MCP context provider
  - Example: #[fetch] fetch Use the web search to find examples of TypeScript generic constraints`
- Integration with Other Features
  - Combine MCP with hooks and specs:
  - Example: Create a hook that uses the web search MCP to find relevant documentation when I create new component files

## Next steps

Now that you've experienced Kiro's core features:

- Try the Interactive Tutorial: Work through our hands-on game development tutorial
- Learn more about specs: Check out the specs documentation to learn more about the concepts and how they work
- Join the Community: Connect with other Kiro users and share your experiences on our Discord server

### Installation - IDE - Docs - Kiro

# Installation

---

## Download Kiro

Getting started is simple:

1. Go to kiro.dev and download the installer
2. Open the downloaded file and follow the installation instructions for your operating system (Windows, macOS, or Linux).
3. Open Kiro IDE and start coding!

## First run

1. When you open Kiro for the first time you will be asked to login with a provider of your choice that include social and AWS login options. Learn more about the auth methods.
2. Once logged in, you can choose to import your VS Code settings and extensions. If you're using another editor, you can skip this step. Select your preferred theme from the available options, then allow Kiro to set up shell integration, enabling the agent to execute commands on your behalf.
3. Finally, you'll arrive at the welcome page. Open a project to get started and proceed with your first project.

## Language support

Kiro supports most popular programming languages. We have guides that help set up your environment and best practices for the following languages:

- TypeScript and JavaScript
- Java
- Python

### Setting up for development on spirit of Kiro - IDE - Docs - Kiro

# Setting up for development on spirit of Kiro

---

## Setup local development environment

First, you need to launch a local copy of the game client and server, connected to
an AWS account. This way, when you use Kiro to modify the codebase, you can make
sure that your changes actually work.

#### Clone the Repository

Clone the [open source code repository](https://github.com/kirodotdev/spirit-of-kiro) and switch to the `challenge` branch:

```bash
git clone git@github.com:kirodotdev/spirit-of-kiro.git
cd spirit-of-kiro/
git checkout challenge

```

After you clone, check out a few key files to understand the project:

- architecture.md - An overview of the architecture
- appsec-overview.md - Details about how specific components of the game fit together.

#### Prerequisite Dependencies

You'll need the following dependencies installed:

- Docker Desktop or Podman
(recommended).
- AWS Setup:
  - An AWS account
  - The AWS CLI installed locally
  - Configure authentication to AWS
- AWS Bedrock model access to one or more of:
  - Amazon Nova Pro
  - Anthropic Claude Sonnet 3.7
  - Anthropic Claude Sonnet 4

#### Verify Dependencies

Run the dependency check script to verify everything is set up correctly:

```sh
./scripts/check-dependencies.sh

```

Loading image...

#### Deploy Cognito User Pool

Deploy an Amazon Cognito user pool for authentication (available in AWS Free Tier):

```bash
./scripts/deploy-cognito.sh game-auth

```

You can substitute 'game-auth' with your own custom CloudFormation stack name.

Loading image...

#### Build and Launch

Build and launch the game stack using either Docker or Podman:

```bash
podman compose build &&
podman compose up \
  --watch \
  --remove-orphans \
  --timeout 0 \
  --force-recreate

```

The first time you run this command it may take a couple minutes. Subsequent
runs should complete in seconds.

Loading image...

If this is your first time using Podman, you will need to
run `podman machine init && podman machine start` before using Podman.

After completion, you should see the game containers running in your container interface.
The following example shows the Podman UI:
Loading image...

You can use `Control + C` or `Command + C` to stop the entire stack.

When using Podman, on some operating systems the virtual machine can experience a
time desync issue on system sleep. This will cause issues with the applications
ability to communicate with AWS. If you encounter this you can fix it with
the following command:

```sh
podman machine ssh sudo systemctl restart chronyd.service

```

#### Bootstrap database

When your stack launches locally, it also launches [DynamoDB local](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html),
a special container that imitates the DynamoDB AWS service, but running
locally on your own machine. The game is expecting several
tables to be created in this DynamoDB container.

While the game stack is still running, open a new terminal and use the
following commands to automatically create the necessary tables:

```sh
podman exec server mkdir -p /app/server/iac &&
podman cp scripts/bootstrap-local-dynamodb.js server:/app/ &&
podman cp server/iac/dynamodb.yml server:/app/server/iac/ &&
podman exec server bun run /app/bootstrap-local-dynamodb.js

```

Loading image...

The DynamoDB database is persisted across restarts, by saving it to
the file `docker/dynamodb/shared-local-instance.db`. If you wish
to clear it out or change the structure of a table, then delete this
file, restart the game stack, and rerun this database bootstrap command.

#### Test it out

It’s time to verify that everything is working properly. Try the following command
first to make sure that the game server is running locally:

```sh
curl localhost:8080

```

You should see the response `OK`

Next open your web browser and put the following address into the address bar:

```
localhost:5173

```

You should see the homepage of the game client. Create an account and start playing.

## Game guide

Here are some basic things to try in the game:

- WASD to move around, E to interact
- Pull random items using the red "PULL" lever
- Pick up items and carry them around with E. Throw a held item with T.
Hint: Items can be thrown out the door at the bottom.
- Carry an item to the workbench and use E to put it on the workbench.
Drag items around to move them up to the tool wall on the back, or
down to the working area at the bottom. Click an item on the tool wall
to cast one of it's "quirks", then select one or more targets for the
"quirk". Both the tool and the targets will transform based on the quirk.
Get creative with this, there are near infinite possibilities, and you
can make some truly bizarre things.
- If you are smashing items or otherwise cutting or breaking them into
pieces, and there are a lot of items in the working area of the workbench
they will overflow and fall off onto the ground around the workbench.
Try not to let the ground get too messy!
- The chest is for storage when you have too many items.
- When an item is thrown out the door at the bottom of the shop keeper
will judge it and you'll get money for it. He likes items that are fun,
unusual, in good condition, or that seem like rare collectables.
- The computer shows items that have been discarded or given to the
appraiser, both by yourself and by other players. This serves as a
randomized “shop” where you can indirectly buy from other players,
or buy back things you lost.

Done playing with your copy of the game? Let's get to work on the first task:

[Steering Kiro, and improving the game homepage](../01-improve-the-homepage)

### Steering Kiro, and improving the game homepage - IDE - Docs - Kiro

# Steering Kiro, and improving the game homepage

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

#### Understand the problem

Load up `localhost:5173` in your browser to see the home page.
As you can see this homepage starts out very minimalistic.
There are no graphics, explanations of what the game is, and there
is no marketing copy. This is a perfect task for "vibe coding".

#### Setup Kiro steering files

But before we "vibe" we must prepare. Because this game is fairly complex,
it will be very useful to prepare Kiro to properly understand
what the project is, what tech it utilizes, and how to navigate the
code.

Use `Control/Command + Shift + P` to open the command palette,
then search for the word “Steering”. Select the option
“Kiro: Generate project steering documents”

Loading image...

The Kiro agent will go to work exploring key files from the repository
and creating some “steering” files that describe the project purpose,
structure, and tech. These files will help guide all future runs of
the agent interactions, making them faster and more accurate.

Loading image...

Take a moment to look at the `.kiro` folder that has been created.
You should see a few files:

- product.md - Describes what the project is. This helps Kiro
understand the big picture view of what is going on when you ask
it to do something.
- tech.md - Describes all the tech used in this project. This helps
Kiro stick to your existing tech choices, instead of recommending divergent
options.
- structure.md - Describes key folders and areas of the project. This
helps Kiro get to the right place faster when it is working.

#### Make some improvements

Now that the steering files are setup, try a basic “vibe coding” prompt
like “I want you to make my homepage better.”

The game client is being served by Vite, so you will be able to see changes
reflected in real time as Kiro makes modifications to the page.

#### Get creative!

Ask Kiro a question like:

```
Give me 20 potential themes for a game landing page. 

```

Then ask Kiro to reimagine the landing page in that theme.

AI can be very imaginative, and is perfect for prototyping designs,
even if you don’t yet have a solid plan in your head. Try out asking it to make the home page have different styles such as: "Apple product
marketing page", "Retro", or "Startup" and/or ask for specific features that you want on the page like a "carousel", "quotes", or "animations".

In this module we learned two core concepts:

1. Steering files help guide an AI through your project. Your first
step should always be to collect and setup this basic context for
the AI.
2. AI can be very creative, and it significantly lowers the barrier to
experimentation. Try out several different prototypes very quickly,
then throw away takes you don't like.

Let's move on to the next task:

[Fixing a subtle physics bug](../02-physics-bug)

### Investigating and fixing a subtle bug with physics - IDE - Docs - Kiro

# Investigating and fixing a subtle bug with physics

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

In the previous module we completed [a simple task to improve the game's
home page](../01-improve-the-homepage), but this was mostly just HTML and CSS task. Let's try
working with some more complex JavaScript code that is part of the
game engine core.

#### Understand the problem

Players of the game report that sometimes game physics go haywire
and items bounce really high. One player has provided the following
recording:

Loading image...

#### Ask Kiro to investigate

Try a prompt that describes the issue in as much detail as
you can:

```
When something is moving or colliding, and the player tabs out then back in, the items do a tremendous bounce. Players report "items go haywire".

```

Kiro will start investigating project files, and will
identify the cause. For example:

> The problem is in the physics-system.ts file. When a user tabs out and back in, the lastTimestamp value becomes stale, and when the animation frame resumes, the calculated deltaTime can be extremely large (several seconds instead of milliseconds). This large delta is then used in physics calculations, causing objects to move much farther than they should in a single frame, resulting in the "haywire" behavior.

#### Dig deeper

Based on your initial description, Kiro probably coded
a basic fix right away. However, we aren't done yet.

Try asking Kiro:

```
What other potential solutions or mitigations should I consider?

```

You may be surprised to see the AI come up with many additional
potential fixes beyond what it originally implemented.

#### Explore even deeper

Now that you have the model into a specific latent space of exploring
potential improvements to the game's physics system it is a great
time to ask a question like:

```
Do you see anything else that looks like it could be improved?

```

Large language models contain an incredible breadth of knowledge.
However, they require a human to push the model a
bit further to unlock the true potential. Don't stop prompting on
the first answer. Ask questions like "why?", "what else?", and
"what then?"

In this module we learned one key AI engineering concept:

Don't just treat AI as a task solving machine. Use the AI's depth and breadth of knowledge to explore gaps in your own knowledge.

Let's move on to the next task:

[Fixing an interactions bug across several files](../03-interactions-bug)

### Fixing a complex issue across multiple files - IDE - Docs - Kiro

# Fixing a complex issue across multiple files

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

In previous modules we:

- Wrote HTML and CSS to improve the homepage
- Fixed a physics bug in the core of the game's physics engine

Both of these tasks were fairly self contained. Let's try something
a bit more complicated, spanning multiple files.

#### Understand the problem

Players of the game report that sometimes the "E" prompt
doesn't work as expected. This seems to happen when standing
near walls:

Loading image...

In this recording you can see that the "E" prompt
disappears even though the player is close enough to the
chest and to the item.

Try asking Kiro to solve this. For example:

```
Sometimes when the player is closer to the wall than to an
interactive object like an item or the chest, then the interact
prompt does not appear over the interactive object.

```

#### Think about the proposed solution

Kiro should be able to correctly identify the issue. The function
which finds which object is nearest to the player is not filtering out
walls, therefore when the player is close to a wall it marks
the wall as the nearest object, even though the wall is not
actually interactive.

Loading image...

The model has proposed to fix the bug by introducing a check to exclude
objects that have a physics mass of `Infinity`. While this
technically works to solve the problem in the short term, is this
the best fix? What if there are non interactive objects that have
a finite mass? Or what if there are objects that have an `Infinity`
mass but are still interactive?

This proposed code solution is adding logic triggered by a property
whose semantic meaning is not directly related to that logic.
While this fix works temporarily, the overloaded behavior will
absolutely break or cause subtle bugs later on.

When using an AI, you must stay mentally engaged.
Don't just blindly accept the first AI suggestion. Think about
best practices and simpler solutions that the AI might have
overlooked.

#### Refactoring across the project

Instead of trying to treat this as a problem entirely self contained
in the file `game-object-system.ts`, let's do a bigger refactor.
Everywhere that game objects are created, we should probably
indicate up front whether the created object is intended to be
interactive.

Try a prompt like:

```
In #GameObject add a new required property `interactive`.
In #updatePlayerProximity filter out non interactive objects
All calls to #addObject throughout the code need to set interactive to true or false

```

Try using `#` to bring up the context picker. You can
reference types, classes, functions, and other code primitives
in your prompt, increasing the accuracy of results by ensuring
that the model can jump straight to looking at the right context.

Your results should look something similar to this:

Loading image...

Instead of one change, there are 22 changes spanning many files
in the project. This refactor will ensure that the
API for game objects contains proper semantic meaning for
expressing whether an object is intended to be interactive.

The LLM will be able to utilize this semantic meaning going
forward, any time it needs to implement a feature.

In this module you have learned three key concepts:

1. Check AI generated code prior to moving on. While code may
work fine today, you still need to think a few steps ahead,
because the LLM is only thinking about the problem it sees
right now.
2. When prompting in Kiro, use the context picker to mention
specific functions, classes, or types in your code. This
enhances model context, and produces more accurate results.
3. Naming is important. Make sure that the "API" for your code
has accurate semantic meaning. Avoid overloading properties
with multiple types of behavior that aren't directly related
to their semantic meanings.

Let's move on to the next task:

[Vibe refactoring is 50% of vibe coding](../04-dry-code-refactor)

### Vibe refactoring is 50% of vibe coding - IDE - Docs - Kiro

# Vibe refactoring is 50% of vibe coding

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

In previous modules we:

- Wrote HTML and CSS to improve the homepage
- Fixed a physics bug in the core of the game's physics engine
- Fixed an interactions bug through an logic refactor

Now it's time to explore a hidden truth about vibe coding. If
at least half of your prompts aren't "vibe refactors" you are probably
messing up.

#### Understand the problem

AI is very good at using example context to implement new solutions.
Unfortunately, this tends to lead to a lot of duplicated code.
In the previous module we started looking at the "E" prompt.
It's time to take an even closer look.

Try a prompt like:

```
Where is the interact prompt implemented in the components?

```

You should see that Kiro locates multiple copies of the
interact prompt:

> The interact prompt is consistently implemented across multiple interactive game objects (Computer, Workbench, Chest, Garbage, GameItem, PullLever, Dispenser)

If you open these files: `Computer.vue`, `Workbench.vue`, `Chest.vue`, etc you will notice that each component has a very similar implementation of the interact prompt with similar CSS.

But then if you move the ghost around the game play area, you will
also notice subtle differences. For example, the size of the pull
lever's interact prompt is slightly different from the size of the workbench interact prompt.

We can improve the code by removing duplication. There's a repeated pattern here - it would be better if we refactored the interact prompt into a single component that could be shared across all these components.

#### Do a refactor

Let's ask Kiro to refactor this. Open a file that contains
an "E" prompt such as "Chest.vue". Then try a prompt like:

```
I want to DRY the "interact-prompt" into a separate component
with standardized styles, reused across my components

```

Loading image...

Kiro uses your currently open files as context. Consider opening relevant files prior to sending a prompt.

#### Verify the results

Kiro should discover all the components that have an "interact-prompt"
element and refactor them to make use of a new shared component instead:

Loading image...

Things to check for:

- The original implementation has interact prompts with different
locations relative to the parent component: above, left, right, etc.
Did that get lost in the refactor?
- There were two different approaches to ensuring that the interact
prompts text stayed at an appropriate size, no matter what the screen
dimension was. Which approach, if any, did the AI model choose?

Trust, but also verify. While AI models can do a fantastic job
at refactoring, its always necessary to double check generated
code to ensure that functionality did not degrade during that
refactor.

#### Find more to do

Try asking Kiro:

```
Look through my components. Do you see any things that should
be refactored or opportunities to implement best practices?

```

AI models are trained via reinforcement learning to
be friendly and compliant. Therefore a model will rarely,
if ever, initiate criticism or question what you ask it to do.
Models will do as you ask, even if what you asked was
flawed.

However, you can still use AI as a code reviewer or critic by explicitly asking it to tell you what it sees wrong or in need of improvement.

In this module you have learned two key concepts:

- Vibe coding works, but just like regular coding, it requires
regular refactors. Do "vibe refactoring" as well.
- AI won't directly contradict you or push back on your
asks, but that doesn't it isn't capable of seeing the
mistakes. You just need to ask it to double check the work.

Let's move on to the next task:

[Using specification for complex work](../05-using-specs-for-complex-work)

### Using specifications for complex work - IDE - Docs - Kiro

# Using specifications for complex work

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

In previous modules we:

- Wrote HTML and CSS to improve the homepage
- Fixed a physics bug in the core of the game's physics engine
- Fixed an interactions bug through an logic refactor
- Did a DRY refactor across many components

So far we've mostly done minor modifications and refactors, but what about
more complex new features? Kiro is here to help with that too.

#### Understand the problem

You may notice that on the login page of the game there is no "Forgot Password"
link. The game is using [Amazon Cognito](https://aws.amazon.com/cognito/) for authentication, however
the implementation is currently still fairly minimal.

In order to send password reset emails, Cognito requires the email to
be verified, so we also need to implement email verification as well.

So we are looking at a tree of tasks that need to be completed:

- Email verification implementation
  - Frontend client side components
  - Backend server routes and Cognito integration
- Password reset implementation
  - Frontend client side screens
  - Backend server routes and Cognito integration

#### Ask for a specification

Try the following prompt in Kiro:

```
I need a specification for email verification and password reset

```

Kiro will go to work collecting information about the project
and designing a specification for this complex task.

#### Review requirements

Kiro will expand your initial ask into a detailed set of
requirements based on user stories. In most cases these
user stories, and the resulting requirements, will help
expand vague asks and highlight edge cases that you might
not have initially expected:

Loading image...

After you read through the requirements you can either
provide detailed feedback on how to rewrite the requirements
or you can just type something like "LGTM" in the prompt
to move on.

#### Review design

Now Kiro will compare the existing code to the
requirements and start imagining how to fit these requirements
into the codebase:

Loading image...

In the upper right corner of the design doc you can click
the "Preview" button to open a rendered copy of the design
document. This will properly show the flow diagram.

The design document likely includes some example code snippets
that are similar to what Kiro plans to write to solve this
problem. Don't worry too much about the specifics of this code.
Think of it more as pseudocode that is imagining the API.
The actual implementation may end slightly different.

After you read through the design document you can either
provide detailed feedback on how to rethink the design
or you can just type something like "LGTM" in the prompt
to move on.

#### Review tasks

Kiro will use the requirements and design document to plan
a series of tasks to execute. Think of each of these tasks
as a step along the journey towards the new feature.

Loading image...

The task list may not match up with your
preferred order of operations when vibe coding. For example,
the task list often has test development last, while you may
prefer test driven development.

You can use steering files to modify Kiro behaviors.
For example, try creating a file `.kiro/steering/specs.md` with
instructions to always write tests first before writing code.

You can either provide feedback in the prompt to
modify the task list, or type something like "LGTM" to
move on.

#### Work on a task

To start working on a task, click the "Start Task" link
above the task. Kiro will go to work on that task.

Loading image...

You will likely still need to review, test, and iterate
on generated code for each task, even though the task list
marks the task as "Task completed".

#### Specification as history

You may have noticed that specifications are stored
under `.kiro/specs`. By design, you should commit these
specification files to the repo, alongside the code.

Over time, you can accumulate a large collection of
specification documents that describe the intent and
design behind the code.

This will serve as a guide for future developers,
as well as a reference for Kiro if it ever
needs to revisit these features.

In this module you have learned two key concepts:

- While vibe coding is fun, sometimes you need to build
something a bit more complex. Then it is helpful to use
Kiro specifications to plan the requirements, design the
implementation, and lay out a series of steps for the
implementation.
- Steering files aren't just to teach Kiro about the project,
they can also be used to modify Kiro's behavior, such as
adjusting how it plans tasks.

Let's move on to the next task:

[Managing assets with agent hooks](../06-managing-assets-with-agent-hooks)

### Managing assets with hooks - IDE - Docs - Kiro

# Managing assets with hooks

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

In previous modules we:

- Wrote HTML and CSS to improve the homepage
- Fixed a physics bug in the core of the game's physics engine
- Fixed an interactions bug through an logic refactor
- Did a DRY refactor across many components
- Built a more complex feature using specifications

Now we are going to use Kiro to setup an automation that will help
remove boilerplate work involved with coding this game.

#### Understand the problem

Open the file `client/src/systems/preloader-system.ts`.
This file is a standalone system which ensures that all the
game assets are preloaded prior to the game starting. It has
a few clever features like initiating the predownload while the
user is still on the authentication screen, and detecting
new assets to load via server events.

But the preloader system also relies on a list of static assets
that is imported from `/client/src/assets/index.ts`. The
preloader system is fully decoupled from the game components
themselves. This is a clean design that ensures that individual
game components don't have to manually implement calls to
the preloader.

However it introduces a potential issue: a developer could
add a new game component, with new asset(s), and forget to add them
to the list of static assets for the preloader. Let's
add an automated hook that can help avoid this, while also
saving the game devs some time.

#### Create an asset indexer hook

Click the ghost icon in your IDE sidebar to open the Kiro panel.
Locate the "Agent Hooks" section and click the plus icon to
start writing a new hook.

Let's use a custom prompt for the hook. You can type in natural
language to describe what you want to happen. For example:

```
When a file is created in the assets folder, 
ensure that the assets folder index.ts file is
appropriately updated

```

Loading image...

Kiro will expand your natural language query into an agent
hook configuration for the behavior you described. The hook
will be stored in your `.kiro/hooks` folder. It should
look something like this:

Loading image...

```json
{
  "name": "Image Asset Indexer",
  "description": "Automatically adds references to newly added image files in the assets folder to the index.ts file",
  "version": "1",
  "when": {
    "type": "fileCreated",
    "patterns": [
      "client/src/assets/*.png",
      "client/src/assets/*.jpg",
      "client/src/assets/*.jpeg",
      "client/src/assets/*.gif",
      "client/src/assets/*.svg"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "A new image file has been added to the assets folder. Please update the index.ts file in the assets folder to include a reference to this new image. First, check the current structure of the index.ts file to understand how images are referenced. Then add an appropriate export statement for the new image file following the existing pattern. Make sure to maintain alphabetical order if that's the current convention."
  }
}

```

#### Create an asset removal hook

Now that we have an example template for an agent hook, you can also
create new hooks manually by just creating new files in the `.kiro/hooks` folder.

Let's try this out by cloning the asset indexer hook and editing it into
an asset removal hook. Copy the existing hook and paste it as `image-asset-remover.kiro.hook` with
content like this:

```json
{
  "name": "Image Asset Remover",
  "description": "Automatically removes references to newly deleted image files in the assets folder to the index.ts file",
  "version": "1",
  "when": {
    "type": "fileDeleted",
    "patterns": [
      "client/src/assets/*.png",
      "client/src/assets/*.jpg",
      "client/src/assets/*.jpeg",
      "client/src/assets/*.gif",
      "client/src/assets/*.svg"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "An image file has been removed from the assets folder. Please update the index.ts file in the assets folder to remove any references to this removed image."
  }
}

```

Loading image...

You should now have two hook configurations, and two hooks
showing up under "Agent Hooks" in the Kiro panel.

#### Test the hooks out

Drag and drop an image file into the `client/src/assets` folder.
You will see the asset indexer hook go to work.

Loading image...

Then delete that asset from the folder.

Loading image...

To view the agent messages for a hook, click the
"Task list" button at the top of chat panel and click
on an active "Current Task". Or you can click the
"History" button to go back and view the agent messages
for a hook that has already completed.

In this module you learned how to create and configure agent hooks
to help automate common tasks in your project. These hooks
can be used both to save time, and increase accuracy of boilerplate
tasks.

Let's move on to the next task:

[Extending Kiro with MCP](../07-extending-kiro-with-mcp)

### Extending Kiro with MCP - IDE - Docs - Kiro

# Extending Kiro with MCP

---

This module assumes you have already launched the game locally, by
following [the setup instructions](../00-setup).

In previous modules we:

- Wrote HTML and CSS to improve the homepage
- Fixed a physics bug in the core of the game's physics engine
- Fixed an interactions bug through an logic refactor
- Did a DRY refactor across many components
- Built a more complex feature using specifications
- Setup an automation for asset management using agent hooks

Now it's time to customize Kiro itself, to adjust it's behavior for
more advanced use cases. To do this, we are going to add some new
abilities to Kiro via [Model Context Protocol](https://modelcontextprotocol.io/introduction) (MCP).

#### Setup an MCP server

Kiro comes with built-in MCP support. Click the Kiro "ghost" tab
and look for "MCP Servers" on the list. Click "+" to start
adding an MCP server.

Loading image...

Modify the contents of the `mcp.json` file that is opened. Because this
guide is using Podman throughout, we are going to run the MCP server
as a container using Podman. This will help keep the MCP server isolated
from our host machine:

```json
{
  "mcpServers": {
    "memory": {
      "enabled": true,
      "command": "podman",
      "args": [
        "run",
        "-i",
        "--rm",
        "-v",
        "memories:/memories",
        "--env",
        "MEMORY_FILE_PATH=/memories/memory.json",
        "mcp/memory"
      ],
      "autoApprove": [
        "create_entities",
        "create_relations",
        "add_observations",
        "delete_entities",
        "delete_observations",
        "delete_relations",
        "read_graph",
        "search_nodes",
        "open_nodes"
      ]
    },
    "sequentialthinking": {
      "command": "podman",
      "args": [
        "run",
        "-i",
        "--rm",
        "mcp/sequentialthinking"
      ],
      "autoApprove": [
        "sequentialthinking"
      ]
    }
  }
}

```

This configuration adds two new MCP servers to Kiro.

The first MCP server contains tools for tracking and querying long term memories.
The memories will be stored in a local Podman volume, and can therefore persist
across Kiro sessions. You can even reuse these memories from outside of Kiro
or bring in memories that were generated from other external sources.

The second server helps Kiro to extend it's thinking and spend more time
planning prior to getting to work on a task.

#### Add memories to Kiro

You can now modify Kiro's behaviors to make use of the new MCP server tools.

Create a file at `.kiro/steering/behavior.md`

Put the following content into the file:

```md
  Each time you start working, put a `user_request`
  type entity into the knowledge graph using the `create_entities` tool.
  After you work, add observations to that entity
  about what you did, how many files you touched, how many lines, etc.

```

Now ask Kiro to do something in the project:

```
Rewrite the README.md as if it was written by a pirate.

```

Loading image...

Now you can use a followup prompt to query the knowledge graph:

```
Search nodes for user_request and write me
a commit message based on what you see

```

Example output:

```md
docs: transform README.md with pirate-themed language
- Rewrote entire README.md in pirate style
- Added nautical references and pirate slang throughout
- Maintained all original information and links
- Changed section titles to pirate-appropriate terms
- Added humorous pirate expressions and threats
- Preserved functionality while enhancing user experience with thematic language

```

#### Modify thinking behavior

Modify the file at `.kiro/steering/behavior.md`

Put the following content into the file:

```md
When planning how to do something, use the sequentialthinking tool to plan the next several steps.

```

Now try asking the chat:

```
Let's do something super cool in this project

```

Loading image...

#### Find more MCP servers

- Awesome MCP Servers
- AWS MCP Servers

In this module you have learned the basics of how to extend Kiro with
additional context sources, tools, and behaviors. There are countless
MCP servers available, and they can be combined together in fascinating
ways to augment Kiro's abilities to work on your project.

Go have fun!

Onward to the [conclusion](../99-conclusion)

### Conclusion - IDE - Docs - Kiro

# Conclusion

---

In this guide you got hands on with a range of Kiro features
including:

- Steering files, to guide AI agents through a complex project
- Basic vibe coding, for bug fixes and simple changes or refactors
- Specification driven development, to plan the requirements, design, and tasks for large changes
- Hooks, for when you want to automate common boilerplate tasks in your project
- MCP, for when you want to extend Kiro with new abilities and behaviors

## Next steps

Although you have completed this guide, there is still plenty
to build. Check out [the game roadmap](https://github.com/kirodotdev/spirit-of-kiro/blob/main/docs/ROADMAP.md)
for ideas. See if you can build any of these new features
using Kiro, and open a PR back to the project to contribute!

### Guides - IDE - Docs - Kiro

# Guides

---

### Java - IDE - Docs - Kiro

# Java

---

Kiro provides powerful AI-assisted development capabilities for Java projects, helping you write, debug, and maintain Java code more efficiently.

## Prerequisites

Before diving into Java development with Kiro, ensure you have:

- Java Development Kit (JDK): Install the latest LTS version (JDK 17 or newer recommended). We recommend Amazon Corretto for a free, production-ready distribution of OpenJDK.
- Build Tool: Maven or Gradle for dependency management and build automation.
- Git: For version control and collaboration.

## Extensions

Kiro supports extensions from Open VSX that can enhance your Java development experience. Here are some helpful extensions you can install:

- Extension Pack for Java: Popular extensions for Java development in Visual Studio Code. Includes Language Support for Java, Debugger for Java, Test Runner for Java, Maven for Java, Project Manager for Java, and IntelliCode.
- Spring Boot Extension Pack: A collection of extensions for Spring Boot development including Spring Boot Tools, Spring Initializr Java Support, and Spring Boot Dashboard.
- Gradle for Java: Manage Gradle projects, run Gradle tasks and provide better Gradle file authoring experience in Kiro.
- Maven for Java: Manage Maven projects, run Maven tasks and provide better Maven project authoring experience in Kiro.
- Markdown Preview Enhanced: For viewing and editing markdown files with live preview.

You can install these extensions in Kiro by using the Extensions panel and searching for the extension names listed above.

## Working with your environment

With Kiro, you can leverage the chat capabilities to setup a new project or work on an existing one.

### Project configuration and structure

Kiro can help you set up and maintain configuration files for your Java projects, and organize your project following Java best practices.

- Initialize configuration files: Ask Kiro to initialize default configuration files based on the project.
- Create project structure: Ask Kiro to create the structure of your project based on needs and best practices.
- Environment setup: Get help configuring your Java development environment.

Example prompts:

```
"Create a new Maven project for a Spring Boot application"
"Set up a Gradle build file with JUnit 5 and Mockito dependencies"
"Configure a multi-module Maven project structure"
"Help me install and configure the latest JDK for my operating system"
"Set up a Spring Boot project with proper layered architecture"
"Create a pom.xml with Spring Security and JPA dependencies"

```

### Code analysis and refactoring

Kiro can analyze your Java code to identify issues and suggest improvements:

- Code Quality Analysis: Ask Kiro to review your code for potential bugs, performance issues, or style issues.
- Refactoring Assistance: Get help extracting methods, renaming variables, or restructuring code.
- Design Pattern Implementation: Kiro can help implement common design patterns in your Java code.

Example prompts:

```
"Analyze this method for potential bugs or performance issues"
"Refactor this code to use the Builder pattern"
"Convert this imperative code to use Java Streams"

```

### Debugging assistance

When you encounter errors in your Java code:

- Error Explanation: Kiro can explain cryptic error messages in plain language
- Solution Suggestions: Get actionable fixes for common errors
- Runtime Debugging: Kiro can help set up debugging configurations

Examples:

```
"Explain this NullPointerException in my code"
"Help me debug this ConcurrentModificationException"
"Analyze this stack trace and suggest a fix"

```

## Steering

[Steering](/docs/steering) allows you to provide Kiro with project specific context and guidelines. Kiro can generate steering files which you can refine:

1. Product brief (product.md) - Contains information about the product, its purpose, and key features
2. Technical Stack (tech.md) - Details the technologies, frameworks, and development guidelines
3. Project Structure (structure.md) - Provides information about how the project is organized

For Java projects, you can create additional custom steering files to provide more specific guidance:

### Creating custom steering files

Use the following instructions to add new steering documents to your project.

**To add new steering documents**

1. Navigate to the Kiro view in the sidebar.
2. In the Agent Steering section, choose the + button to create a new steering file.
3. Enter a name for your file with a descriptive title.
4. Add your custom steering content following markdown conventions.

Custom steering files are stored in the `.kiro/steering/` directory and are automatically recognized by Kiro during interactions.

### Project-specific conventions

Create a `java-conventions.md` steering file to define your team's specific practices and architectural decisions:

```markdown
# Java Project Conventions

## Architecture Patterns
- Use hexagonal architecture for complex domains
- Implement CQRS for read/write separation when needed
- Apply Domain-Driven Design principles for business logic

## Testing Strategy
- Write unit tests for all business logic
- Use TestContainers for integration tests
- Maintain 80% code coverage minimum
- Follow the AAA pattern (Arrange, Act, Assert)

## Error Handling
- Use custom exceptions for business logic errors
- Implement global exception handlers with @ControllerAdvice
- Log errors with correlation IDs for traceability
- Return consistent error response formats

## Performance Guidelines
- Use connection pooling for database access
- Implement caching strategies for frequently accessed data
- Use async processing for long-running operations
- Monitor and optimize database queries

```

This type of steering provides Kiro with context about your specific architectural decisions and practices, rather than basic code formatting which is better handled by automated tools like Checkstyle or Spotless.

### Framework specific guidelines

For Spring Boot projects, create a `spring-boot-patterns.md` steering file:

```markdown
# Spring Boot Development Guidelines

## Component Structure
- Use @RestController for REST endpoints
- Use @Service for business logic
- Use @Repository for data access
- Use @Component for other beans

## Dependency Injection
- Prefer constructor injection over field injection
- Use final fields for injected dependencies
- Avoid circular dependencies

## API Design
- Follow REST principles for endpoint design
- Use appropriate HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate HTTP status codes
- Use DTOs for request/response objects

```

These steering files help Kiro generate code that follows your team's specific conventions and best practices.

## Agent hooks

Kiro's [agent hooks](/docs/hooks) can automate common Java development tasks. For example, you can create hooks that:

- Automatically generate JUnit tests when you save a Java file
- Run code quality checks with Checkstyle or SpotBugs
- Check for outdated Maven or Gradle dependencies
- Generate or update JavaDoc comments for public methods
- Validate Spring Boot configuration files
- Format code with Google Java Format or similar tools

## MCP servers

Kiro's support for Model Context Protocol (MCP) servers enhance your Java development experience by providing specialized tools and capabilities. For a complete guide on setting up and using MCP, see the [MCP documentation](/docs/mcp).

#### Maven MCP server

The Maven MCP server allows you to manage Maven projects directly within Kiro:

```json
{
  "mcpServers": {
    "maven": {
      "command": "uvx",
      "args": ["maven-mcp-server@latest"]
    }
  }
}

```

With this server configured, you can:

- Run Maven commands with Kiro
- Get AI powered explanations for build issues
- Manage dependencies and project configuration

Example usage:

```
"Run Maven tests for my project"
"Add Spring Boot starter dependencies to my pom.xml"

```

#### Additional useful MCP servers

Explore more MCP servers in the [AWS MCP Servers](https://awslabs.github.io/mcp/) and [Awesome MCP Servers](https://github.com/punkpeye/awesome-mcp-servers) collection.

## Debugging issues

When you encounter issues, Kiro can help diagnose and fix them:

1. Inline Chat:
  - Type Cmd/Ctrl + I to open the inline chat.
  - Ask Kiro to explain specific errors or suggest fixes for the current code.
2. Add to Chat:
  - Type Cmd/Ctrl + L to add the current file to the chat.
  - Ask Kiro to analyze the entire file for potential issues or improvements.
3. Quick Fix:
  - Hover on an error or warning, then select Quick fix and Ask Kiro.
  - Kiro will automatically add the code to the chat and start debugging.

## Resources

- Java Documentation
- Spring Framework Documentation
- Spring Boot Documentation
- Maven Documentation
- Gradle Documentation

### Language support - IDE - Docs - Kiro

# Language support

---

Kiro provides powerful AI-assisted development capabilities for your projects, helping you write, debug, and maintain code more efficiently. The following guides will help you get started creating with Kiro.

### Learn by playing - IDE - Docs - Kiro

# Learn by playing

---

In this guide, you will learn how to use Kiro by completing tasks
in the [codebase](https://github.com/kirodotdev/spirit-of-kiro) for a sample video game called Spirit of Kiro.

95% of the code for Spirit of Kiro has been written by prompting Kiro.
You are going to be using Kiro to fix bugs and add features to the game to
complete it.

Loading image...

Spirit of Kiro is an infinite crafting game in which you can:

1. Discover unique, randomly generated objects
2. Utilize these items on each other via simulated interactions like "cut",
"paint", "glue", "enchant". Item's combine, break apart, and change in
response to these interactions.
3. Sell your resulting creations to an AI appraiser.

Every object in the game is generated by AI. Interactions between objects
are also simulated by AI. This gives Spirit of Kiro infinite replayability
and potential.

In the following diagram you can see how the game's core crafting mechanic works. The
player has discovered two items: a spoon, and a glass jar of vegetables. The player
can use the spoon to extract a sample of the vegetables.

Loading image...

While the game’s core loop is complete, the game is not quite done yet. There is an
[extensive roadmap for the game](https://github.com/kirodotdev/spirit-of-kiro/blob/main/docs/ROADMAP.md),
full of additional ideas to build, and there a few bugs that have been left in the
game on purpose so you can try out solving them using Kiro.

In this guide you will learn to use Kiro by completing a series of tasks
on a `challenge` branch of the open source code for this game. Ready to get started?
Let's go!

#### Setup

First, we ensure that you have an AWS account. We setup a Cognito user
pool for authentication, build and launch the game stack using a
Docker Compose file, then bootstrap DynamoDB tables. Then we verify
that the game runs on your local machine:

- Setup dev environment and launch the game

#### Task: Improve game homepage

We setup steering files to help Kiro understand the project.
With a full understanding of the project, we put Kiro to
work improving the home landing page for the game.

- Steering Kiro, and improving the game homepage

#### Bug Fix: Physics Glitch

When we tab out of game, the physics goes haywire when tabbing
back in. Can Kiro fix it?

- Investigating and fixing a subtle bug with physics

#### Bug Fix: Interactions Oversight

The original pass at game interactions was "vibe coded".
But it looks like AI missed something. Can Kiro correct its own mistake?

- Fixing a complex issue across multiple files

#### Refactor: DRY up code with Kiro

It's not just vibe coding, we do vibe refactoring here as well.

- Vibe refactoring is 50% of vibe coding

#### New Feature: Implementing something complex

The game is currently missing email verification and password reset.
We implement this relatively complex new feature across client and server.

- Using specifications for complex work

#### Automation: Managing assets with agent hooks

We identify some boilerplate asset management work that that is error prone.
Fortunately Kiro agent hooks can help us automate this.

- Managing assets with agent hooks

#### Extending Kiro with MCP

Not only can you make this game your own, you can also make Kiro your own,
by extending its context and behaviors with Model Context Protocol (MCP).

- Extending Kiro with MCP

#### Conclusion

Wrap up your learning journey and explore next steps.

- Conclusion

### Migrating from VSCode - IDE - Docs - Kiro

# Migrating from VSCode

---

Built on Visual Studio Code's open source foundation, Kiro delivers AI-enhanced development capabilities while preserving the familiar interface you know. This shared architecture ensures a smooth transition when bringing your existing VS Code configuration to Kiro.

## Profile migration

Kiro's VS Code foundation enables complete compatibility with your development environment. You can transfer your personalized setup—extensions, themes, configurations, and shortcuts—with no compatibility concerns.

### Manual profile migration

For cross-machine transfers or granular control over your configuration, leverage VS Code's native profile export/import capabilities.

#### Exporting a profile from vs code

1. Launch the Command Palette in VS Code (⌘/Ctrl + Shift + P).
2. In the Command Palette, enter and select "Preferences: Open Profiles (UI)".
3. Locate your desired profile in the sidebar.
4. Access the 3-dot menu and choose Export.
5. Save locally or publish to a GitHub Gist.

Loading image...

#### Importing a profile to Kiro

1. Access Kiro's Command Palette (⌘/Ctrl + Shift + P).
2. In the Command Palette, enter and select "Preferences: Open Profiles (UI)".
3. Open the dropdown beside New Profile and select Import Profile.
4. Provide the GitHub Gist URL or browse for your local export file.
5. Confirm by choosing Import to save your configuration.
6. Activate your profile by selecting it in the sidebar and selecting the checkmark.

Your imported profile includes:

- Color themes and UI preferences
- Editor and workspace settings
- Custom keyboard shortcuts and keybindings

## Settings and interface

### Settings menus

Kiro extends VS Code's settings architecture with dedicated controls for AI capabilities:

**Kiro Settings**

- Open Settings: Command Palette (⌘/Ctrl + Shift + P) → "Preferences: Open Settings (UI)"
- Navigate to Kiro Agent section within the settings UI
- Manage AI behaviors, agent automation, trusted commands, and Kiro-exclusive features

Loading image...

**VS Code Settings**

- Access the same way: Command Palette (⌘/Ctrl + Shift + P) → "Preferences: Open Settings (UI)"
- Your standard VS Code preferences remain fully functional alongside Kiro settings

### Version updates

Kiro stays synchronized with VS Code's development cycle through regular rebasing. While we incorporate the latest features and improvements, we strategically select stable VS Code releases to ensure reliability alongside our AI enhancements.

## Extension compatibility

Kiro uses the OpenVSX extension registry, ensuring compatibility with open-source extensions. Extensions available in OpenVSX will migrate seamlessly, with many gaining enhanced capabilities through Kiro's AI integration:

- Language extensions: Full functionality preserved for OpenVSX-available extensions
- Theme extensions: Complete visual compatibility with OpenVSX themes
- Debugging extensions: Uninterrupted debugging workflows for compatible extensions
- Git extensions: Augmented with intelligent commit generation and automated code review

Only extensions available in the OpenVSX registry can be imported. Some VS Code Marketplace exclusives may not be available in Kiro.

### Python - IDE - Docs - Kiro

# Python

---

Kiro provides powerful AI-assisted development capabilities for Python projects, helping you write, debug, and maintain code more efficiently.

## Prerequisites

Before diving into Python development with Kiro, ensure you have:

- Python: Install the latest version for your platform (Python 3.8+ recommended)
- pip: Package installer for Python (comes with Python)
- Virtual Environment: Use venv, virtualenv, or conda for dependency management
- Git: For version control and collaboration

## Extensions

Kiro supports extensions from Open VSX that can enhance your Python development experience. Here are some helpful extensions you can install:

- Python - Python language support with extension access points for IntelliSense, Debugging (Python Debugger), linting, formatting, refactoring, unit tests, and more.
- PyLint - Linting support for Python files.
- Jupyter - Jupyter notebook support, interactive programming and computing that supports Intellisense, debugging and more.
- Python Debugger - Python debugger (debugpy) extension providing debugging capabilities for Python applications.
- Rainbow CSV - Highlight CSV and TSV files, Run SQL-like queries

You can install these extensions in Kiro, use the Extensions panel and search for the extension names listed above.

## Working with your environment

With Kiro, you can leverage the chat capabilities to setup a new project or work on an existing one.

### Project configuration and structure

Kiro can help you set up and maintain configuration files for your Python projects, and organize your project following Python best practices.

- Initialize configuration files: Ask Kiro to initialize default configuration files based on the project.
- Create project structure: Ask Kiro to create the structure of your project based on needs and best practices.

Example prompts:

```
"Set up a requirements.txt with development dependencies"
"Configure a .env file for my Django application"
"Set up a Python package structure with proper __init__.py files"
"Create a Flask project structure with blueprints"
"Organize my data science project with notebooks and modules"
"Create a pyproject.toml for a FastAPI project with pytest and black"

```

### Code analysis and refactoring

Kiro can analyze your Python code to identify issues and suggest improvements:

- Code Quality Analysis: Ask Kiro to review your code for potential bugs, performance issues, or PEP 8 compliance
- Refactoring Assistance: Get help extracting functions, renaming variables, or restructuring code
- Type Hints: Kiro can suggest type annotations to improve code clarity and catch errors

Example prompts:

```
"Analyze this function for potential bugs and performance issues"
"Refactor this code to follow PEP 8 style guidelines"
"Add type hints to this Python module"
"Convert this synchronous code to use async/await"

```

### Debugging assistance

When you encounter errors in your Python code:

- Error Explanation: Kiro can explain Python tracebacks and error messages in plain language
- Solution Suggestions: Get actionable fixes for common Python errors
- Runtime Debugging: Kiro can help set up debugging configurations and breakpoints

Examples:

```
"Explain this Python error: AttributeError: 'NoneType' object has no attribute 'split'"
"Help me debug this Django view that's returning a 500 error"
"Why is my pandas DataFrame operation so slow?"

```

## Steering

[Steering](/docs/steering) allows you to provide Kiro with project specific context and guidelines. Kiro can generate steering files which you can refine:

1. Product brief (product.md) - Contains information about the product, its purpose, and key features
2. Technical Stack (tech.md) - Details the technologies, frameworks, and development guidelines
3. Project Structure (structure.md) - Provides information about how the project is organized

For Python projects, you can create additional custom steering files to provide more specific guidance:

### Creating custom steering files

Use the following instructions to add new steering documents to your project.

**To add new steering documents**

1. Navigate to the Kiro view in the sidebar.
2. In the Agent Steering section, choose the + button to create a new steering file.
3. Enter a name for your file with a descriptive title.
4. Add your custom steering content following markdown conventions.

Custom steering files are stored in the `.kiro/steering/` directory and are automatically recognized by Kiro during interactions.

### Code style and conventions

For example, you can define custom naming conventions, file structure, or practices for your project.
Create a `python-conventions.md` steering file to define your team's coding standards:

```markdown
Python Conventions

Naming Conventions
- Use snake_case for variables and functions
- Use PascalCase for classes
- Use UPPER_SNAKE_CASE for constants
- Use descriptive names that explain purpose

Code Style
- Follow PEP 8 guidelines
- Use Black for code formatting
- Maximum line length of 88 characters
- Use type hints for all public functions

File Structure
- One class per file for large classes
- Group related functions in modules
- Use __init__.py files for package organization
- Separate tests in tests/ directory

Documentation
- Use docstrings for all public functions and classes
- Follow Google or NumPy docstring style
- Include type information in docstrings

```

### Framework specific guidelines

For Django projects, create a `django-patterns.md` steering file:

```markdown
Django Development Guidelines

Model Design
- Use descriptive model names
- Add __str__ methods to all models
- Use model managers for complex queries
- Follow Django naming conventions for fields

View Structure
- Prefer class-based views for complex logic
- Use function-based views for simple operations
- Keep business logic in models or services
- Use proper HTTP status codes

Template Organization
- Use template inheritance effectively
- Keep templates DRY with includes and tags
- Use meaningful template names
- Organize templates by app

Performance Best Practices
- Use select_related and prefetch_related for queries
- Implement database indexing for frequently queried fields
- Use caching for expensive operations
- Profile database queries in development

```

For data science projects, create a `data-science-patterns.md` steering file:

```markdown
Data Science Development Guidelines

Notebook Organization
- Use clear section headers and markdown cells
- Keep notebooks focused on single analyses
- Export reusable code to Python modules
- Include data source documentation

Data Handling
- Validate data quality early in pipelines
- Use consistent column naming conventions
- Document data transformations clearly
- Handle missing values explicitly

Model Development
- Use cross-validation for model evaluation
- Track experiments with clear versioning
- Document model assumptions and limitations
- Implement proper train/validation/test splits

Code Organization
- Separate data processing, modeling, and visualization
- Use configuration files for parameters
- Implement logging for long-running processes
- Create reproducible environments with requirements files

```

These steering files help Kiro generate code that follows your team's specific conventions and best practices.

## Agent hooks

Kiro's [agent hooks](/docs/hooks) can automate common Python development tasks:

1. Navigate to the Agent Hooks section in the Kiro panel
2. Click the + button to create a new hook
3. Define the hook workflow in natural language

Here are some hook examples:

### Test generation Hook

Automatically generate tests when you save a Python file:

```
"Create a hook that generates pytest tests when I save a new Python module"

```

### Dependency update Hook

Keep your dependencies up to date:

```
"Create a hook that checks for outdated pip packages and suggests updates"

```

### Linting Hook

```
When a Python file is saved:
1. Run flake8 or pylint on the file
2. Report any style or quality issues
3. Suggest fixes for common problems
4. Update docstrings if missing

```

### Virtual environment Hook

```
When requirements.txt or pyproject.toml is modified:
1. Check if virtual environment is activated
2. Install or update dependencies automatically
3. Report any dependency conflicts
4. Update requirements-dev.txt if needed

```

## Documentation access with #docs

Kiro provides built-in access to documentation for Python and popular frameworks through the `#docs` reference system. This allows you to quickly bring relevant documentation into your conversations with Kiro.
Simply type `#docs` in the chat and select from the available documentation sources, such as:

- #Python - Python language documentation
- #Pytorch - PyTorch framework documentation
- #PySide6 - Python library for creating GUI

Example usage:

```
"#Python How do I use context managers effectively?"
"#Pytorch how can I add a custom operator?"
"#PySide6 What is the best way to add a button?"

```

You can also reference specific documentation URLs using `#URL`:

```
"#URL https://docs.python.org/3/library/asyncio.html"

```

## Debugging issues

When you encounter issues, Kiro can help diagnose and fix them:

1. Inline Chat:
  - Type Cmd/Ctrl + I to open the inline chat.
  - Ask Kiro to help debug your code with natural language.
2. Add to Chat:
  - Type Cmd/Ctrl + L to add the current file to the chat.
  - Ask Kiro to help debug your code with natural language.
3. Quick Fix:
  - Hover on an error or warning, then select Quick fix and Ask Kiro.
  - Kiro will automatically add the code to the chat and start debugging.

## Resources

- Python Documentation
- Python Package Index (PyPI)
- Python Enhancement Proposals (PEPs)

### TypeScript and JavaScript - IDE - Docs - Kiro

# TypeScript and JavaScript

---

Kiro provides powerful AI-assisted development capabilities for TypeScript and JavaScript projects, helping you write, debug, and maintain code more efficiently.

## Prerequisites

Before diving into TypeScript and JavaScript development with Kiro, ensure you have:

- Node.js: Install the latest version for your platform
- TypeScript: Install globally or locally in your project
- Package Manager: npm (comes with Node.js) or your preferred package manager
- Git: For version control and collaboration

## Suggested extensions

To enhance your TypeScript and JavaScript development experience with Kiro, consider installing these helpful extensions:

- ESLint - Real-time code quality feedback and linting for JavaScript/TypeScript
- Prettier - Code Formatter - Automatic code formatting for consistent style across your project
- Auto Rename Tag - Automatically renames paired HTML/JSX tags when editing
- JavaScript (ES6) code snippets - Provides useful code snippets for modern JavaScript and TypeScript development

## Working with your environment

### Project configuration and structure

Kiro can help you set up and maintain configuration files for your TypeScript and JavaScript projects, as well as organize your project following Kiro's best practices.

For example, you can ask Kiro:

```
"Create a tsconfig.json for a React TypeScript project using ES6 modules"
"Update my ESLint config to enforce React best practices"
"Set up a monorepo structure for my frontend and backend TypeScript code"

```

### Code analysis and refactoring

Kiro can analyze your TypeScript and JavaScript code to identify issues and suggest improvements:

- Code Quality Analysis: Ask Kiro to review your code for potential bugs, performance issues, or style issues.
- Refactoring Assistance: Get help extracting functions, renaming variables, or restructuring code.
- Type Inference: Kiro can suggest TypeScript types based on your JavaScript code.

Example prompts:

```
"Analyze this function for potential bugs"
"Refactor this code to use async/await instead of promises"
"Convert this JavaScript file to TypeScript with proper types"

```

### Debugging assistance

When you encounter errors in your TypeScript or JavaScript code:

- Error Explanation: Kiro can explain cryptic error messages in plain language
- Solution Suggestions: Kiro can suggest actionable fixes for common errors
- Runtime Debugging: Kiro can help set up debugging configurations

Examples:

```
"Explain this TypeScript error: TS2339: Property 'value' does not exist on type 'never'"
"Help me debug this React useEffect infinite loop"

```

## Steering

[Steering](/docs/steering) allows you to provide Kiro with project specific context and guidelines. Kiro can generate steering files which you can refine:

1. Product brief (product.md) - Contains information about the product, its purpose, and key features
2. Technical Stack (tech.md) - Details the technologies, frameworks, and development guidelines
3. Project Structure (structure.md) - Provides information about how the project is organized

For TypeScript and JavaScript projects, you can create additional custom steering files to provide more specific guidance.

### Creating custom steering files

Use the following instructions to add new steering documents to your project.

**To add new steering documents**

1. Navigate to the Kiro view in the sidebar.
2. In the Agent Steering section, choose the + button to create a new steering file.
3. Enter a name for your file with a descriptive title.
4. Add your custom steering content following markdown conventions.

Custom steering files are stored in the `.kiro/steering/` directory and are automatically recognized by Kiro during interactions.

### Code style and conventions

You can define custom naming conventions, file structure, or practices for your project.

You can create a `js-conventions.md` steering file to define your team's coding standards:

```markdown
# TypeScript/JavaScript Conventions

## Naming Conventions
- Use camelCase for variables and functions
- Use PascalCase for classes and React components
- Use UPPER_SNAKE_CASE for constants

## File Structure
- One component per file
- Group related components in folders
- Use index.ts files for exports

## TypeScript Practices
- Prefer interfaces over types for public APIs
- Use explicit return types for exported functions
- Avoid using 'any' type

```

### Framework specific guidelines

For React projects, you can create a `react-patterns.md` steering file:

```markdown
# React Development Guidelines

## Component Structure
- Use functional components with hooks
- Separate business logic from UI components
- Follow the container/presentational pattern

## State Management
- Use React Context for global state
- Prefer useState for local component state
- Use useReducer for complex state logic

## Performance Optimization
- Memoize expensive calculations with useMemo
- Prevent unnecessary re-renders with React.memo
- Use useCallback for event handlers passed to child components

```

These steering files help Kiro generate code that follows your team's specific conventions and best practices.

## Agent hooks

Kiro's [agent hooks](/docs/hooks) can automate common TypeScript and JavaScript development tasks:

1. Navigate to the Agent Hooks section in the Kiro panel
2. Click the + button to create a new hook
3. Define the hook workflow in natural language

Here are some hook examples:

### Test generation Hook

You can automatically generate tests when you save a TypeScript or JavaScript file:

```
"Create a hook that generates Jest tests when I save a new component"

```

### Type checking Hook

You can run TypeScript type checking in the background:

```
"Set up a hook to run TypeScript type checking when I save files"

```

### Dependency update Hook

You can keep your dependencies up to date:

```
"Create a hook that checks for outdated npm packages"

```

### ESLint Auto-fix Hook

```
When a JavaScript or TypeScript file is saved:
1. Run ESLint with auto-fix on the file
2. Report any remaining issues that couldn't be fixed automatically
3. Suggest fixes for complex issues

```

### Component documentation Hook

```
When a React component file is saved:
1. Extract the component's props interface
2. Update or create a documentation comment above the component
3. Generate usage examples based on the props
4. Update the component's README.md if it exists

```

## MCP servers

Kiro's support for Model Context Protocol (MCP) servers enhance your TypeScript and JavaScript development experience by providing specialized tools and capabilities. For a complete guide on setting up and using MCP, see the [MCP documentation](/docs/mcp).

### Frontend MCP server

The AWS Labs Frontend MCP Server provides specialized tools for modern web application development, offering comprehensive documentation and guidance for React applications:

```json
{
  "mcpServers": {
    "frontend": {
      "command": "uvx",
      "args": ["awslabs.frontend-mcp-server@latest"],
      "env": {
        "FASTMCP_LOG_LEVEL": "ERROR"
      }
    }
  }
}

```

Example usage:

```
"Get essential knowledge for React development"
"Help me troubleshoot this React component issue"
"Show me best practices for modern React applications"

```

Explore more MCP servers in the [AWS MCP Servers](https://awslabs.github.io/mcp/) and [Awesome MCP Servers](https://github.com/punkpeye/awesome-mcp-servers) collection.

## Documentation access with #docs

Kiro provides built-in access to documentation for JavaScript, TypeScript, and popular frameworks through the `#docs` reference system. This allows you to quickly bring relevant documentation into your conversations with Kiro.
Simply type `#docs` in the chat and select from the available documentation sources, such as:

- #Node.js - Node.js runtime documentation
- #TypeScript - TypeScript language documentation
- #React - React library documentation
- #Svelte - Svelte framework documentation
- #Express - Express.js framework documentation
- #Vue.js - Vue.js framework documentation
- #Alpine.js - Alpine.js framework documentation

Example usage:

```
"#TypeScript How do I create a generic function?"
"#React What's the best way to handle form state?"

```

You can also reference specific documentation URLs using `#URL`:

```
"#URL https://react.dev/reference/react/useState"

```

## Debugging issues

When you encounter issues, Kiro can help diagnose and fix them:

1. Inline Chat:
  - Type Cmd/Ctrl + I to open the inline chat.
  - Ask Kiro to help debug your code with natural language.
2. Add to Chat:
  - Type Cmd/Ctrl + L to add the current file to the chat.
  - Ask Kiro to help debug your code with natural language.
3. Quick Fix:
  - Hover on an error or warning, then select Quick fix and Ask Kiro.
  - Kiro will automatically add the code to the chat and start debugging.

## Resources

- TypeScript Documentation
- JavaScript MDN Web Docs
- Node.js Documentation

### Code references - IDE - Docs - Kiro

# Code references

---

Kiro learns, in part, from open-source projects. Sometimes, a suggestion it's giving you may be similar to publicly available code. Code references include information about the source Kiro used to generate a recommendation.

This section describes how you can view, edit, and configure code references.

## View the code reference log

With the code reference log, you can view references to code recommendations that are similar to publicly available code. You can also edit code recommendations suggested by Kiro.

To view the code reference log:

1. Go to the Output tab in the status bar.
2. From the drop-down menu, choose code-references.

The code reference log only appears when you have code references enabled and Kiro has generated code with references.

## Turn code references on and off

Code references are disabled by default. To turn code references on or back off:

1. Open Settings in Kiro.
2. Switch to the User sub-tab.
3. Choose Kiro. You can also search for code references in the Settings search bar.
4. Under Code References: Reference Tracker, check or uncheck the box next to Allow Kiro to generate code with references.

## Opt out of code with references as an enteprise administrator

Kiro enterprise administrators can opt out of getting code suggestions with references for all users. Kiro enterprise users don't have control over this setting; it's controlled by the administrator and can't be overridden.

Administrators can opt out of code references in the Kiro console. For more information, see [Kiro enterprise settings](../../enterprise/settings).

### Compliance validation for Kiro - IDE - Docs - Kiro

# Compliance validation for Kiro

---

To learn whether an AWS service is within the scope of specific compliance programs, see [AWS services in Scope by Compliance Program](https://aws.amazon.com/compliance/services-in-scope/) and choose the compliance program that you are interested in. For general information, see [AWS Compliance Programs](https://aws.amazon.com/compliance/programs/).

You can download third-party audit reports using AWS Artifact. For more information, see [Downloading Reports in AWS Artifact](https://docs.aws.amazon.com/artifact/latest/ug/downloading-documents.html). If you are signing in to Kiro with GitHub or Google, you will not be able to download third-party audit reports using AWS Artifact.

Your compliance responsibility when using AWS services is determined by the sensitivity of your data, your company's compliance objectives, and applicable laws and regulations. AWS provides the following resources to help with compliance:

- Security Compliance & Governance – These solution implementation guides discuss architectural considerations and provide steps for deploying security and compliance features.
- HIPAA Eligible Services Reference – Lists HIPAA eligible services. Not all AWS services are HIPAA eligible.
- AWS Compliance Resources – This collection of workbooks and guides might apply to your industry and location.
- AWS Customer Compliance Guides in the AWS Config Developer Guide – Understand the shared responsibility model through the lens of compliance. The guides summarize the best practices for securing AWS services and map the guidance to security controls across multiple frameworks (including National Institute of Standards and Technology (NIST), Payment Card Industry Security Standards Council (PCI), and International Organization for Standardization (ISO)).
- Evaluating Resources with Rules – The AWS Config service assesses how well your resource configurations comply with internal practices, industry guidelines, and regulations.
- AWS Security Hub – This AWS service provides a comprehensive view of your security state within AWS. Security Hub uses security controls to evaluate your AWS resources and to check your compliance against security industry standards and best practices. For a list of supported services and controls, see Security Hub controls reference.
- Amazon GuardDuty – This AWS service detects potential threats to your AWS accounts, workloads, containers, and data by monitoring your environment for suspicious and malicious activities. GuardDuty can help you address various compliance requirements, like PCI DSS, by meeting intrusion detection requirements mandated by certain compliance frameworks.
- AWS Audit Manager – This AWS service helps you continuously audit your AWS usage to simplify how you manage risk and compliance with regulations and industry standards.

### Data protection - IDE - Docs - Kiro

# Data protection

---

The AWS [shared responsibility model](https://aws.amazon.com/compliance/shared-responsibility-model/) applies to data protection in Kiro. As described in this model, AWS is responsible for protecting the global infrastructure that runs all of the AWS Cloud. You are responsible for maintaining control over your content that is hosted on this infrastructure. You are also responsible for the security configuration and management tasks for the AWS services that you use. For more information about data privacy, see the [Data Privacy FAQ](https://aws.amazon.com/compliance/data-privacy-faq/).

## Data storage

Kiro stores your questions, its responses, and additional context, such as code, to generate new responses to your requests. For information about how data is encrypted, see [Data encryption](#data-encryption). For information about how AWS may use some questions that you ask Kiro and its responses to improve our services, see [Kiro service improvement](#service-improvement).

### AWS regions where content is stored and processed

If you are a Kiro Free Tier user or a Kiro individual subscriber, your content, such as prompts and responses, will be stored in the US East (N. Virginia) Region.

If you are a [Kiro enterprise user](../../enterprise/concepts/#kiro-enterprise-user), your content will be stored in the AWS Region where your Kiro profile was created.

With cross-region inferencing, your content may be processed in a different Region within the geography where your content is stored. For more information, see [Cross-region processing](#cross-region-processing).

## Cross-region processing

The following sections describe how cross-region inference and cross-region calls are used to provide the Kiro service.

### Cross-region inference

Kiro is powered by Amazon Bedrock, and uses cross-region inference to distribute traffic across different AWS Regions to enhance large language model (LLM) inference performance and reliability. With cross-region inference, you get increased throughput and resilience during high demand periods, as well as improved performance.

Cross region inference doesn’t affect where your data is stored. For information on where data is stored when you use Kiro, see [AWS Regions where content is stored and processed](#aws-regions-where-content-is-stored-and-processed).

### Supported regions for Kiro cross-region inference

For models or capabilities under the experimental tag, see “[Global cross-region inference for experimental features](#global-cross-region-inference-for-experimental-features)”.

| Supported Kiro geography | Inference regions |
| --- | --- |
| United States | US East (N. Virginia) (us-east-1)US West (Oregon) (us-west-2)US East (Ohio) (us-east-2) |
| Europe | Europe (Frankfurt) (eu-central-1)Europe (Ireland) (eu-west-1)Europe (Paris) (eu-west-3)Europe (Stockholm) (eu-north-1)Europe (Milan) (eu-south-1)Europe (Spain) (eu-south-2) |

### Global cross-region inference for experimental features

Kiro may introduce new models and capabilities under an experimental tag, which process data differently than in the table above. When a model is launched as experimental, Kiro may use global cross-region inference to improve performance, increase throughput, and take advantage of available capacity across supported commercial AWS Regions worldwide. Global cross-region inference applies only to models and features explicitly designated as experimental.

For models and capabilities marked as experimental:

- Inference requests may be processed in multiple AWS Regions globally, including Regions outside the one associated with your Kiro profile.
- The Region where your data is stored is not affected by global cross-region inference.
- This global routing is used to optimize resource availability and allow consistent performance for experimental model launches.

## Data encryption

This topic provides information specific to Kiro about encryption in transit and encryption at rest.

### Encryption in transit

All communication between customers and Kiro and between Kiro and its downstream dependencies is protected using TLS 1.2 or higher connections.

### Encryption at rest

Kiro encrypts your data using AWS owned encryption keys from AWS Key Management Service (AWS KMS). You don’t have to take any action to protect the AWS managed keys that encrypt your data. For more information, see [AWS owned keys](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk) in the *AWS Key Management Service Developer Guide*.

When you subscribe with Kiro enterprise, administrators have the option to create customer managed keys to encrypt your data. Customer managed keys are KMS keys in your AWS account that you create, own, and manage to directly control access to your data by controlling access to the KMS key. Only symmetric keys are supported. For information on creating your own KMS key, see [Creating keys](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html) in the *AWS Key Management Service Developer Guide*.

To set up a customer managed key to encrypt data as a Kiro enterprise administrator, you need permissions to use AWS KMS. The required KMS permissions are included in the [example IAM policy](). After creating a customer managed KMS key, you must provide the key in the Kiro console to use it to encrypt data.

## Service improvement

To help Kiro provide the most relevant information, we may use certain content from Kiro, such as questions that you ask Kiro, other inputs you provide, and the responses and code that Kiro generates, for service improvement. This page explains what content we use and how to opt out.

### Kiro content used for service improvement

We may use certain content from Kiro Free Tier and Kiro individual subscribers for service improvement. Users that have a paid Kiro subscription and access it through a social login provider (like GitHub or Google) or through AWS Builder ID are considered *individual subscribers*. Content that Kiro may use for service improvement includes, for example, your questions to Kiro, other inputs you provide, and the responses and code that Kiro generates. Kiro may use this content, for example, to provide better responses to common questions, fix Kiro operational issues, for de-bugging, or for model training.

We do not use content from [Kiro enterprise users](../../enterprise/concepts/#kiro-enterprise-user) for service improvement.

If you have an Amazon Q Developer Pro subscription and access Kiro through your AWS account with the Amazon Q Developer Pro subscription, then Kiro will not use your content for service improvement.

## Opt out of data sharing

By default, Kiro collects usage data, errors, crash reports, and other metrics as well as content for service improvement from Kiro Free Tier users and Kiro individual subscribers. This section explains how to opt out of sharing your data in Kiro for Kiro Free Tier and Kiro individual subscribers. For information on how Kiro uses this data, see [Kiro service improvement](#service-improvement).

[Kiro enterprise users](../../enterprise/concepts/#kiro-enterprise-user) are automatically opted out of telemetry and content collection by AWS. Telemetry collection settings for [user activity reports](../../enterprise/monitor-and-track/user-activity/) are controlled by the administrator in the Kiro console and cannot be configured by Kiro enterprise users. For more information, see [Kiro enterprise settings](../../enterprise/settings).

### Opting out of sharing data in the IDE

To opt out of sharing your client-side telemetry and content in the Kiro IDE, use this procedure:

1. Open Settings in Kiro.
2. Switch to the User sub-tab.
3. Choose Application, and then choose Telemetry and Content.
4. To opt out of telemetry collection, uncheck the box for Data Sharing and Prompt Logging: Usage Analytics And Performance Metrics. To opt out of content collection, uncheck the box for Data Sharing and Prompt Logging: Content Collection for Service Improvement.

### Opting out of sharing data in the CLI

To opt out of sharing your client-side telemetry and content in the Kiro CLI, use this procedure:

1. Open Preferences in the Kiro CLI application.
2. To opt out of telemetry collection, toggle off the Telemetry setting. To opt out of content collection, toggle off the Share Kiro content with AWS setting.

## Types of telemetry collected

- Usage data — Information such as the Kiro version, operating system (Windows, Linux, or macOS), and the anonymous machine ID.
- Performance metrics — The request count, errors, and latency for various features:
  - Login
  - Tab completion
  - Code generation
  - Steering
  - Hooks
  - Spec generation
  - Tools
  - MCP

### Configuring a firewall, proxy server, or data perimeter for Kiro - IDE - Docs - Kiro

# Configuring a firewall, proxy server, or data perimeter for Kiro

---

If you're using a firewall, proxy server, or [data perimeter](https://aws.amazon.com/identity/data-perimeters-on-aws/), make sure to allowlist traffic to the following URLs and Amazon Resource Names (ARNs) so that Kiro works as expected.

## General urls to allowlist

In the following URLs, replace:

- idc-directory-id-or-alias with your IAM Identity Center instance's directory ID or alias. For more information about IAM Identity Center, see What is IAM Identity Center? in the AWS IAM Identity Center User Guide.
- sso-region with the AWS Region where your IAM Identity Center instance is enabled.

| URL | Purpose |
| --- | --- |
| <idc-directory-id-or-alias>.awsapps.com | Authentication |
| oidc.<sso-region>.amazonaws.com | Authentication |
| *.sso.<sso-region>.amazonaws.com | Authentication |
| *.sso-portal.<sso-region>.amazonaws.com | Authentication |
| *.aws.dev | Authentication |
| *.awsstatic.com | Authentication |
| *.console.aws.a2z.com | Authentication |
| *.sso.amazonaws.com | Authentication |
| https://aws-toolkit-language-servers.amazonaws.com/* | Kiro, language processing |
| https://aws-language-servers.us-east-1.amazonaws.com/* | Kiro, language processing |
| https://client-telemetry.us-east-1.amazonaws.com | Kiro, telemetry |
| https://cognito-identity.us-east-1.amazonaws.com | Kiro, telemetry |
| https://prod.us-east-1.telemetry.desktop.kiro.dev | Telemetry |
| https://prod.us-east-1.auth.desktop.kiro.dev | Authentication |

### Infrastructure security in Kiro - IDE - Docs - Kiro

# Infrastructure security in Kiro

As a managed service, Kiro is protected by AWS global network security. For information about AWS security services and how AWS protects infrastructure, see [AWS Cloud Security](https://aws.amazon.com/security/). To design your AWS environment using the best practices for infrastructure security, see [Infrastructure Protection](https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/infrastructure-protection.html) in *Security Pillar AWS Well‐Architected Framework*.
You use AWS published API calls to access Kiro through the network. Clients must support the following:

- Transport Layer Security (TLS). We require TLS 1.2 and recommend TLS 1.3.
- Cipher suites with perfect forward secrecy (PFS) such as DHE (Ephemeral Diffie-Hellman) or ECDHE (Elliptic Curve Ephemeral Diffie-Hellman). Most modern systems such as Java 7 and later support these modes.

Additionally, requests must be signed by using an access key ID and a secret access key that is associated with an IAM principal. Or you can use the [AWS Security Token Service](https://docs.aws.amazon.com/STS/latest/APIReference/welcome.html) (AWS STS) to generate temporary security credentials to sign requests.

---

### Privacy and security - IDE - Docs - Kiro

# Privacy and security

---

Kiro is an AWS application that works as a standalone agentic IDE. Kiro's security framework is built around AWS's security infrastructure and follows practices to protect your development environment and data. Cloud security at AWS is the highest priority. As an AWS customer, you benefit from a data center and network architecture that is built to meet the requirements of the most security-sensitive organizations.

Security is a shared responsibility between AWS and you. The [shared responsibility model](https://aws.amazon.com/compliance/shared-responsibility-model/) describes this as security of the cloud and security in the cloud:

- Security of the cloud – AWS is responsible for protecting the infrastructure that runs AWS services in the AWS Cloud. AWS also provides you with services that you can use securely. Third-party auditors regularly test and verify the effectiveness of our security as part of the AWS Compliance Programs. To learn about the compliance programs that apply to Kiro, see AWS Services in Scope by Compliance Program.
- Security in the cloud – Your responsibility is determined by the AWS service that you use. You are also responsible for other factors including the sensitivity of your data, your company’s requirements, and applicable laws and regulations

This documentation helps you understand how to apply the shared responsibility model when using Kiro. It shows you how to configure Kiro to meet your security and compliance objectives. You also learn how to use other AWS services that help you to monitor and secure your Kiro resources.

## URL fetching

In the Kiro chat module, you can paste a specific URL for your device to fetch and use it as context to help Kiro answer your query or solve your task. You are responsible for the URL content that you fetch and ensuring that your use complies with any applicable third-party terms and laws.

## Autopilot versus supervised mode

In Kiro, Autopilot is enabled by default. You can toggle between Autopilot and Supervised mode at any time. Autopilot mode enables the agent to execute code changes, such as creating, modifying, searching, and deleting files in your codebase and run commands that impact the filesystem.

### Autopilot mode

In Autopilot mode, Kiro works autonomously:

- Kiro executes multiple steps without requiring approval for each one
- Kiro makes decisions based on its understanding of your requirements
- You can toggle autopilot on/off in the chat interface
- You can interrupt autopilot at any time to regain manual control

### Supervised mode

In supervised mode, Kiro works interactively with the user, requiring their approval and guidance at each step:

- Kiro suggests actions such as file creation, modification and deletion, but waits for user confirmation before proceeding
- Kiro asks clarifying questions when needed
- You can review and approve each generated document or code change, thus maintaining full control over the development process

When operating in either of these modes, you can view individual or all file changes made by the agent by selecting **View all changes** in the **Chat** module. Additionally, you can also select **Revert all changes** or revert to a [checkpoint](/docs/chat/checkpoints) to restore your files to their previous state in the filesystem locally.

## Trusted commands

By default, Kiro requires approval before running any command. You can create your own trusted commands list by searching for **Kiro Agent: Trusted Commands** in your settings.

Kiro uses simple string prefix matching to determine if a command should be automatically trusted:

- Exact matching: Commands must match exactly (e.g., npm install)
- Wildcard matching: Use * to trust command variations (e.g., npm * trusts all npm commands)
- Universal trust: Use * alone to trust all commands (use with extreme caution)

The system treats entire commands as single strings and only checks if they start with trusted patterns. It does not analyze command structure, chains, or special characters, putting full responsibility on you to carefully configure trusted patterns.

## Best practices

Kiro provides a number of security features to consider as you develop and implement your own security policies. The following best practices are general guidelines and don’t represent a complete security solution. Because these best practices might not be appropriate or sufficient for your environment, treat them as helpful considerations rather than prescriptions.

### Protecting your resources

When using GitHub or Google authentication with Kiro, be aware that the Kiro agent operates within your local environment and may access:

- Local files and repositories
- Environment variables
- AWS credentials stored in your environment
- Other configuration files with sensitive information

### Recommendations

1. Workspace Isolation
  - Keep sensitive projects in separate workspaces
  - Use .gitignore to prevent access to sensitive files
  - Consider using workspace trust features in your IDE
2. Use a Clean Environment
  - Consider creating a dedicated user account or container environment for Kiro
  - Limit access to only the repositories and resources needed for your current project
3. Manage AWS Credentials Carefully
  - Use temporary credentials with appropriate permissions
  - Consider using AWS named profiles to isolate Kiro's access
  - For sensitive work, remove AWS credentials from your environment when not needed
4. Repository Access Control
  - When using GitHub authentication, review which repositories Kiro can access
  - Use repository-specific access tokens when possible
  - Regularly audit access permissions

## Remote extensions security

**Security Note**: Using remote extensions opens a connection between your local machine and the remote machine. Only connect to secure remote machines that you trust and that are owned by a party whom you trust. A compromised remote could use the connection to execute code on your local machine.
Third-party extensions including remote extensions are not developed, maintained, or managed by Kiro. We are not responsible for third-party extensions and cannot guarantee their stability, compatibility, or ongoing support.

Kiro supports Open VSX extensions, including remote SSH extensions (the community-maintained [Open Remote - SSH](https://open-vsx.org/extension/jeanp413/open-remote-ssh) extension on Open VSX is a popular choice), to provide a familiar development experience. For comprehensive information about extension compatibility and support in Kiro, see our [extension compatibility guide](/docs/guides/migrating-from-vscode/#extension-compatibility).

By following these practices, you can enjoy Kiro's capabilities while maintaining appropriate security boundaries for your development environment.

### Kiro and interface endpoints (AWS PrivateLink) - IDE - Docs - Kiro

# Kiro and interface endpoints (AWS PrivateLink)

---

You can establish a private connection between your VPC and Kiro by creating an interface VPC endpoint. Interface endpoints are powered by [AWS PrivateLink](https://aws.amazon.com/privatelink/), a technology that enables you to privately access Kiro APIs without an internet gateway, NAT device, VPN connection, or AWS Direct Connect connection. Instances in your VPC don't need public IP addresses to communicate with Kiro APIs. Traffic between your VPC and Kiro does not leave the Amazon network.

Each interface endpoint is represented by one or more [Elastic Network Interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html) in your subnets.

For more information, see [Interface VPC endpoints (AWS PrivateLink)](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html) in the Amazon VPC User Guide.

## Considerations for Kiro VPC endpoints

Before you set up an interface VPC endpoint for Kiro, ensure that you review [Interface endpoint properties and limitations](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html#vpce-interface-limitations) in the Amazon VPC User Guide.

Kiro supports making calls to all of its API actions from your VPC, in the context of services that are configured to work with Kiro.

## Prerequisites

Before you begin any of the procedures below, ensure that you have the following:

- An AWS account with appropriate permissions to create and configure resources.
- A VPC already created in your AWS account.
- Familiarity with AWS services, especially Amazon VPC and Kiro.

## Creating an interface VPC endpoint for Kiro

You can create a VPC endpoint for Kiro using either the Amazon VPC console or the AWS Command Line Interface (AWS CLI). For more information, see [Creating an interface endpoint](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html#create-interface-endpoint) in the Amazon VPC User Guide.

Create a VPC endpoint for Kiro using one of the following service names:

- com.amazonaws.us-east-1.q
- com.amazonaws.eu-central-1.q
- com.amazonaws.us-east-1.codewhisperer

Kiro supports Amazon Q Developer profiles in the US East (N. Virginia) and Europe (Frankfurt) regions. Also, the Amazon CodeWhisperer endpoint (com.amazonaws.us-east-1.codewhisperer) is only supported in the US East (N. Virginia) Region.

If you enable private DNS for the endpoint, you can make API requests to Kiro using its default DNS name for the Region, for example, `q.us-east-1.amazonaws.com`.

For more information, see [Accessing a service through an interface endpoint](https://docs.aws.amazon.com/vpc/latest/privatelink/create-interface-endpoint.html#access-service-though-endpoint) in the Amazon VPC User Guide.

## Using an on-premises computer to connect to a Kiro endpoint

This section describes the process of using an on-premises computer to connect to Kiro through a AWS PrivateLink endpoint in your AWS VPC.

1. Create a VPN connection between your on-premises device and your VPC.
2. Create an interface VPC endpoint for Kiro.
3. Set up an inbound Amazon Route 53 endpoint. This will enable you to use the DNS name of your Kiro endpoint from your on-premises device.

### About Kiro

# Meet Kiro.

Kiro is an agentic development environment that makes it easy for developers to ship real engineering work with the help of AI agents. Kiro is our answer to the question “what would a development environment look like if it could take full advantage of AI?”

We see agents as the most powerful tool yet developed for building software. We imagine a future where agents are deeply integrated across the software development lifecycle, but current IDEs don’t fully capture this transformative shift. Agents need more structured input and contextual information than a natural language prompt to build the right thing. While they're becoming increasingly capable of handling complex tasks independently, we lack the right interfaces and interaction methods to collaborate with agents effectively at scale. These are among the key challenges we're working to solve.

Through Kiro, we reinvented how developers work with AI agents. We pioneered spec-driven development, where Kiro turns your prompt into structured requirements, design, and tasks that are then implemented by agents. Kiro’s agent hooks help you scale your work by delegating tasks to agents that run in the background, such as updating docs, generating unit tests, or optimizing your code for performance. We see Kiro as a true collaborator that doesn’t just do work for you, but builds alongside you. Our goal is for Kiro to help you deliver robust engineering work while also helping you become an even better engineer.

Kiro is built and operated by a small, opinionated team within AWS. We chose the name ‘Kiro’ (rhymes with ‘hero’) because, among other meanings, it represents a hardworking person who never gives up. The name ‘Kiro’ embodies our north star: to move quickly and iterate relentlessly on delivering a remarkable AI-powered development experience for everyone. We’re excited to see what you build with Kiro.

### Autonomous agent

### Works autonomously

Let Kiro autonomously handle development tasks while you stay focused or step away.

### Maintains context

Return to a task and pick up where you left off, without rebuilding context.

### Executes across repos

Create a task and Kiro handles the planning and implementation across all repos.

Runs tasks in isolated sandbox environments and opens pull requests for review, so work progresses while you stay focused on your current work

Maintains context across tasks, repositories, and pull requests, and uses your review feedback to shape future changes so it better matches how you and your team build software

Plan a change once and let Kiro create coordinated edits and pull requests, landing related updates together across repositories instead of one at a time

## Kiro autonomous agent for teams

Brings context and coordination together, working alongside your engineering teams to amplify your impact

### Ship faster together

Runs development work in parallel across the team so releases move forward with fewer stalls and less coordination drag

### Works across your stack

Connects your team’s repos, pipelines, and collaboration tools to keep plans, changes, and rationale in one shared context as work progresses

### Protects focus time

Handles routine fixes, follow-ups, and status updates so engineers face fewer interruptions and maintain longer blocks for deep work

### Learns from your team

Continuously learns from your codebase, tickets, and feedback to better align with your team's development patterns

## Common questions

### What is an AI agent?

### What is an AI agent?

### What is a frontier agent?

### What is a frontier agent?

### What is Kiro autonomous agent?

### What is Kiro autonomous agent?

### When will the preview be available for my account?

### When will the preview be available for my account?

### How do I know if I have access to the Kiro autonomous agent preview?

### How do I know if I have access to the Kiro autonomous agent preview?

### Can I turn the Kiro autonomous agent preview off?

### Can I turn the Kiro autonomous agent preview off?

### Is the agent preview included in my current plan or will I be charged extra?

### Is the agent preview included in my current plan or will I be charged extra?

### Will Kiro autonomous agent change my repositories automatically?

### Will Kiro autonomous agent change my repositories automatically?

### How are autonomous agents related to Kiro powers?

### How are autonomous agents related to Kiro powers?

### How is Kiro autonomous agent different from Kiro CLI custom agents?

### How is Kiro autonomous agent different from Kiro CLI custom agents?

### How does Kiro autonomous agent work with the IDE?

### How does Kiro autonomous agent work with the IDE?

### How does Kiro automous agent work with the CLI?

### How does Kiro automous agent work with the CLI?

### Which third-party tools can my teams use Kiro autonomous agent with?

### Which third-party tools can my teams use Kiro autonomous agent with?

## Let Kiro take the next shift on your backlog

The agent is rolling out in preview to Kiro Pro, Pro+, and Power users. Team access is invite-only via waitlist.

### Billing for individuals - IDE - Docs - Kiro

# Billing for individuals

---

Kiro offers four distinct service tiers designed to meet different development needs: **Kiro Free**, **Kiro Pro**, **Kiro Pro+**, and **Kiro Power**. Each tier provides progressively more capabilities.

New Kiro users are automatically enrolled in a 30 day free trial. The free trial is a temporary enhancement to the perpetual **Kiro Free** tier that allows you to test Pro features by providing 500 credits to use over a 30 day trial period. After your trial, you'll need to choose one of Kiro's paid tiers or switch to the perpetual **Kiro Free** tier, and any unused credits will expire.

If you upgrade tiers during the 30 day trial, you'll keep the 500 credits, but any unused trial credits will expire after the 30 days are complete. For example, if you upgrade to the Pro tier within 30 days, you'll have 1,500 credits (1,000 Pro + 500 Trial). After 30 days, unused trial credit expires, leaving you with the Pro tier credits.

Credits are consumed fractionally based on each request. Simple edits and shorter prompts will use fewer credits than complex, lengthy tasks. This means that fractional credits allow you to get more value from your credit allocation.

## Tier comparison

| Tier | Credits | Overage |
| --- | --- | --- |
| Trial | 500 | Not available |
| Free | 50 | Not available |
| Pro | 1,000 | Opt-in |
| Pro+ | 2,000 | Opt-in |
| Power | 10,000 | Opt-in |

## Billing practices

Note the following billing practices when you subscribe, downgrade, unsubscribe, and incur overages:

- If you are on the Kiro Free tier, have never upgraded before, and upgrade to the Pro, Pro+, or Power tier mid-month, you are charged a prorated fee, but immediately get access to your new plan's full credit limits. For example, if you subscribe to Pro on April 15th, you'll be charged half the subscription fee and be able to use all of the credits for that tier. Additionally, if you decide to upgrade again on April 20th to Pro+, you'll get backdated prorated fees and access to the full credit limits of that tier, as if you directly upgraded to Pro+ on April 15th. After that, you'll be charged the full amount.
- If you are on any paid tier, such as the Pro, Pro+, or Power tier, and upgrade to another paid tier, you are charged a retroactive fee for the entire month based on the price difference. For example, if you upgrade from a Pro to a Pro+ tier, you'll be charged the difference in the subscription fee and at the end of the month, Kiro will recalculate the entire month's usage under the new tier's credits. In this case, if you used 1,010 credits, that would be 10 credits over the Pro cap, however since you upgrade to the Pro+ tier, you avoided paying an overage fee.
InfoIf you're on a paid tier, switch to the Kiro Free tier, and then switch back to a paid tier, the payment behavior will be the same as above. Note that downgrades take effect in the following month and upgrades are effective immediately.
- If you downgrade from Pro+ to Pro tier mid-month, you are charged the full fee for that month. For example, if you downgrade on June 2nd, you'll be charged the full Pro+ subscription fee for the month of June. From July onward, you will be charged the Pro fee.
- If you incur overages, you are charged the total overage fees for the month at the end of the current billing cycle.
- For all tiers, your usage cap renews at the beginning of the next billing cycle.

### Cancelling your subscription - IDE - Docs - Kiro

# Cancelling your subscription

You're billed for your subscription plan on the first day of the month, so if you cancel your subscription mid-month you'll remain on your current plan until the end of the month. You will be put on **Kiro Free** starting from the next billing cycle, and you won’t be charged for a monthly subscription from that point onwards. However, you will be responsible for any overages incurred during your final paid billing cycle.

Use the following instructions to cancel your paid plan in Kiro. To cancel your paid plan, you must switch to the **Kiro Free** tier.

1. In Kiro, select the profile icon.
2. Choose Manage Plan. You will be redirected to your default web browser to complete the downgrade process.
3. In the browser, choose Update subscription, select Kiro Free, and then choose Continue.
4. Confirm the details of the plan and then choose Confirm.
5. After confirming your subscription, you can select Return to Kiro to return to the Kiro IDE.

---

### CLI

Terminal — 80×24

### Quality code every time

Kiro agents deliver precise code changes across large codebases with the power of [Claude frontier models](/docs/cli/chat/model-selection/) and [advanced context management](/docs/cli/chat/context/).

### Powerful at any scale

Kiro CLI is a lightning-fast coding experience that adapts to how you work, from simple bash commands to complex enterprise workflows.

### Fast, secure development

With powerful [agent steering](/docs/cli/steering/) and [native MCP support](/docs/cli/mcp/), Kiro helps you ship with precision, from prompt to production.

### Precise context, precise code

Using your [knowledge base](/docs/cli/experimental/knowledge-management/), [steering files](/docs/cli/steering/), and [MCP tools](/docs/cli/mcp/), Kiro CLI delivers production-grade code, documentation, and tests that match your requirements.

### Custom agents for every task

[Build task-specific agents](/docs/cli/custom-agents/creating/) optimized for your best practices through pre-defined [tool permissions](/docs/cli/chat/permissions/), [context](/docs/cli/chat/context/), and [prompts](/docs/cli/chat/manage-prompts/).

### Automated actions

Format code, run tests, manage logs, and more—all through automated shell commands.

### Maintain flow across tools

Kiro understands the intent behind your prompts and helps you implement complex features on larger codebases across Kiro tools and [any ACP supported IDEs](/docs/cli/acp/#editor-setup).

## Get started with Kiro CLI

## Common questions

### What is Kiro CLI?

### What is Kiro CLI?

### How do I install Kiro CLI?

### How do I install Kiro CLI?

### What are the main use cases of Kiro CLI?

### What are the main use cases of Kiro CLI?

### What are the main features of Kiro CLI?

### What are the main features of Kiro CLI?

### What are some essential Kiro CLI commands?

### What are some essential Kiro CLI commands?

### How does Kiro CLI maintain context?

### How does Kiro CLI maintain context?

### How are the Kiro IDE and CLI licensed?

### How are the Kiro IDE and CLI licensed?

### Does Kiro CLI have separate pricing from Kiro IDE?

### Does Kiro CLI have separate pricing from Kiro IDE?

### What environments are supported for Kiro CLI?

### What environments are supported for Kiro CLI?

## Transform your terminal into an AI-powered development environment

### Contacting billing support - IDE - Docs - Kiro

# Contacting billing support

---

If you need assistance with billing questions, payment issues, subscription changes, or other account-related concerns, you can contact our billing support team directly.

## When to contact billing support

Contact billing support for help with:

- Payment issues - Failed payments, updating payment methods, or billing errors
- Subscription questions - Plan changes, upgrade/downgrade assistance, or billing cycle inquiries
- Account access - Issues accessing your account or billing dashboard
- Refund requests - Questions about refunds or billing disputes
- Usage clarification - Understanding your usage charges or tier limits
- Invoice questions - Requesting copies of invoices or clarifying charges

## How to contact support

Contact our billing support team through the [support portal](https://support.aws.amazon.com/#/contacts/kiro).

You can access this form from the link above or directly from the IDE as shown below.

## What information you'll need

When you access the support form, you'll be asked to provide:

- Full Name - Your complete name for account verification
- Email Address - The email associated with your Kiro account
- Subject - A brief description of your issue
- Description - Detailed information about your billing question or issue

## Tips for effective support requests

To help us resolve your issue quickly:

- Be specific - Clearly describe the billing problem you're experiencing
- Include relevant details - Account email, subscription tier, approximate dates of issues
- Mention previous attempts - Let us know if you've tried any troubleshooting steps

For general product questions or technical support, please refer to our [documentation](/docs) or visit our community forums [Discord](https://discord.gg/kirodotdev) and [GitHub](https://github.com/kirodotdev/kiro). Billing support specifically handles account, payment, and subscription-related inquiries.

## Alternative resources

Before contacting support, you might find answers in these resources:

- Billing overview - Complete guide to Kiro's billing system
- Managing your payments - Self-service payment management
- FAQs - Frequently asked questions about Kiro
- Troubleshooting - Common issues and solutions

### Deleting your account - IDE - Docs - Kiro

# Deleting your account

Permanently deleting your Kiro account will remove all your custom settings and cancel any active subscription. This action cannot be undone.

**To delete your account**

1. In Kiro, open the command palette:
  - Mac: Cmd + Shift + P
  - Windows/Linux: Ctrl + Shift + P
2. Search > Kiro: Delete Account and select it.
3. (Optional) You'll have 30 days to restore your account. To restore your account, log back into Kiro during the 30-day period and settle any outstanding balance before upgrading to paid tiers.
4. After 30 days without logging back in, your account and data will be permanently deleted.

---

### Get started - IDE - Docs - Kiro

# Get started

---

Kiro is an agentic IDE that helps you do your best work with features such as specs, steering, and hooks.

## Get started

Everything you need to begin your journey with Kiro in under 5 minutes.

## Core capabilities

Learn about Kiro's core feature set.

## Learning resources

Master Kiro through hands-on tutorials and comprehensive documentation.

### Downgrading your subscription - IDE - Docs - Kiro

# Downgrading your subscription

You're billed for your subscription plan on the first day of the month, so if you downgrade tiers mid-month you'll remain on your current plan until the end of the month. You will be charged for any overages incurred during this month, and then downgrade to your new plan starting from the next billing cycle.

Use the following instructions to downgrade your plan in Kiro.

1. In Kiro, select the profile icon.
2. Choose Manage Plan. You will be redirected to your default web browser to complete the downgrade process.
3. In the browser, choose Update subscription, select which plan you'd like to downgrade to, and then choose Continue.
4. Confirm the details of the plan and then choose Confirm.
5. After confirming your subscription, you can select Return to Kiro to return to the Kiro IDE.

---

### Downloads

# Download Kiro

By downloading and using Kiro, you agree to the [AWS Customer Agreement](https://aws.amazon.com/agreement/) (or other agreement with us governing your use of AWS services), [Service Terms](https://aws.amazon.com/service-terms/), and [Privacy Notice](https://aws.amazon.com/privacy/).

### Kiro for Enterprise

With [spec-driven development](/docs/specs/concepts/), [advanced context management](/docs/chat/#context-management), and [collaborative agents](/docs/cli/custom-agents/), your team can iterate faster with increased quality, while minimizing risk.

### Escape velocity without the tech debt

Align your entire team with [executable specs](/docs/specs/) as the source of truth. Then, unleash powerful [agents in the IDE](/docs/chat/model-selection/) and [CLI](/docs/cli/custom-agents/) that work alongside you to reduce friction and solve difficult problems. Increase your team development velocity while enforcing best practices with powerful agent [steering](/docs/steering/) and [hooks](/docs/hooks/).

From startups to enterprises, Kiro is the secret behind teams who experience 10x their usual output.

> We began using Kiro to enhance our modernization efforts, and the results were impressive – we completed 52 weeks of estimated work in just three weeks, resulting in a 90% increase in efficiency.

### Flexible administration

Easily [manage subscriptions](/docs/enterprise/subscription-management/), [access](/docs/enterprise/iam/), [permissions](/docs/enterprise/iam/#identity-based-policies-for-kiro), and [billing](/docs/enterprise/billing/) at the org level. Kiro is [available in](/docs/enterprise/supported-regions/) the US East (N. Virginia) and Europe (Frankfurt) AWS Regions.

### Backed by AWS security best practices

Kiro is designed, built, and operated by following the same [security](/docs/privacy-and-security/), [governance](/docs/privacy-and-security/compliance-validation/), and [encryption standards](/docs/privacy-and-security/infrastructure-security/) as the AWS cloud infrastructure.

### IP Indemnity

Kiro offers indemnity for its output, so Pro, Pro+, and Power subscribers can ship quality software with confidence. See [Service Terms](https://aws.amazon.com/service-terms/) for details.

## Ship faster across the entire development lifecycle

Kiro helps [maintain living docs](/docs/steering/) and tests across large codebases, so it's easy to get new teammates up to speed.

[Trace and fix bugs](/docs/chat/diagnostics/) in minutes to minimize blast radius and move on to interesting tasks.

Kiro helps [break down complex features](/docs/specs/) into manageable tasks so your team can ship their best work with ease.

## Integrate with the tools you need

### MCP

Connect to the web, APIs, databases, docs, cloud platforms, [and more](/docs/cli/mcp/).

### Terminal

Use [Kiro CLI](/cli) with bash, zsh, fish, and [over 500 popular CLIs](/docs/cli/autocomplete/).

### Pipelines

Integrate and trigger the Kiro CLI [within your CI/CD pipelines](/docs/cli/custom-agents/).

### Extensions

Kiro supports [Open VSX extensions, themes, and VS Code settings](/docs/guides/migrating-from-vscode/).

## Empower your team with Kiro

### Frequently Asked Questions

## General

### What is Kiro?

### What is Kiro?

### What is spec-driven development? How is it different from vibe coding?

### What is spec-driven development? How is it different from vibe coding?

### How can I get started with Kiro?

### How can I get started with Kiro?

### What programming languages does Kiro support?

### What programming languages does Kiro support?

### What languages can I ask questions in?

### What languages can I ask questions in?

### Can I import settings from my existing IDE?

### Can I import settings from my existing IDE?

## Pricing & Plans

### How does Kiro pricing work?

### How does Kiro pricing work?

### What models does Kiro use under the hood?

### What models does Kiro use under the hood?

### How does the free trial work?

### How does the free trial work?

### What is a credit?

### What is a credit?

### What can I use credits for?

### What can I use credits for?

### How can I track my credit usage?

### How can I track my credit usage?

### Can I pay for additional credits?

### Can I pay for additional credits?

### Can I share my Kiro subscription with my team?

### Can I share my Kiro subscription with my team?

### What happens if I don’t use all my monthly credits?

### What happens if I don’t use all my monthly credits?

### What payment methods do you accept?

### What payment methods do you accept?

### What countries or regions are supported for individual plans?

### What countries or regions are supported for individual plans?

### Is the agent preview included in my current plan or will I be charged extra?

### Is the agent preview included in my current plan or will I be charged extra?

### Will I be charged for Kiro powers?

### Will I be charged for Kiro powers?

## Enterprise

### How can my teams get started with Kiro?

### How can my teams get started with Kiro?

### Do you provide an output indemnity for Kiro subscribers?

### Do you provide an output indemnity for Kiro subscribers?

### Can I control telemetry sharing (usage data, performance metrics) for Kiro at the organization level?

### Can I control telemetry sharing (usage data, performance metrics) for Kiro at the organization level?

### Which regions does Kiro support?

### Which regions does Kiro support?

### Does Kiro use my content to train any models?

### Does Kiro use my content to train any models?

### I’m an Amazon Q Developer Pro customer using Kiro. Will Kiro use my content for service improvement?

### I’m an Amazon Q Developer Pro customer using Kiro. Will Kiro use my content for service improvement?

## Availability

### Which regions does Kiro support?

### Which regions does Kiro support?

### What countries or regions are supported for individual plans?

### What countries or regions are supported for individual plans?

### Which countries or regions support Kiro startup credits?

### Which countries or regions support Kiro startup credits?

## Privacy

### Can I control telemetry sharing (usage data, performance metrics) for Kiro at the organization level?

### Can I control telemetry sharing (usage data, performance metrics) for Kiro at the organization level?

### Does Kiro use my content to train any models?

### Does Kiro use my content to train any models?

### Kiro: Agentic AI development from prototype to production

Kiro helps you do your best work by bringing structure to AI coding with spec-driven development.

Kiro gives developers and teams the structure and speed to 10x their output. Build precise context and make your intent explicit with [executable specs](/docs/specs/). Unleash [advanced agents](/docs/chat/autopilot/) to fix bugs in minutes, iterate on features faster, and solve tough technical problems across the most complex codebases.

### Natural prompt to structured requirements

Kiro takes your [natural language prompt](/docs/chat/) and turns it into clear requirements and acceptance criteria in [EARS notation](/docs/specs/concepts/#requirements), making your intent and constraints explicit.

### Architectural designs backed by best practices

Once you’ve iterated on requirements, Kiro analyzes your codebase and comes up with the architecture, system design, and tech stack that meets your needs.

### Discrete tasks that map to requirements

Kiro then creates an [implementation plan](/docs/specs/concepts/#tasks) with discreet tasks, sequenced based on dependencies, with optional comprehensive tests. Ask Kiro to implement each task using [advanced agents](/docs/chat/autopilot/), and watch the magic happen.

Access Kiro agents in your favorite terminal. Build features, automate workflows in seconds, analyze errors, trace bugs, and suggest fixes locally or over SSH—all in a terminal of your choice, in a highly interactive loop that keeps you in flow.

Terminal — 80×24

Delegate tasks to AI agents that [trigger on events](/docs/hooks/types/) such as file save. Agents autonomously execute in the background based on your [pre-defined prompts](/docs/hooks/management/), helping you scale your work by generating documentation, unit tests, or optimizing code performance.

## Go from vibe coding to viable code

[Multimodal chat](/docs/chat/), [spec-driven development](/docs/specs/concepts/), [agent hooks](/docs/hooks/) - Kiro gives you the best tool for the job in a fresh development experience that still feels familiar.

With [specs](/docs/specs/), [steering](/docs/steering/), and [smart context management](/docs/chat/#context-management), Kiro understands the intent behind your prompts and helps you implement complex features on larger codebases, in fewer shots.

Connect to docs, databases, APIs, and more with [native MCP integration](/docs/mcp/), including remote, so you can bring your world where you work.

Configure how you want Kiro agents to interact with each project, or globally, via [steering files](/docs/steering/). Add context, coding standards, preferred workflows or tools with a simple command.

Choose between [Claude Sonnet 4.5](/docs/chat/model-selection/#claude-sonnet-45) for reliable advanced coding and reasoning, or [Auto](/docs/chat/model-selection/#auto-recommended), which uses a mix of frontier models (like Sonnet 4.5 and other specialized models) for intent detection and caching to balance quality, latency, and cost.

Kiro supports [Open VSX plugins, themes, and VS Code settings](/docs/guides/migrating-from-vscode/) in a streamlined AI-ready environment.

Let Kiro [autonomously run large tasks](/docs/chat/autopilot/) on its own without needing step-by-step instructions. You stay in control, especially when running scripts or commands.

See how many credits each prompt consumes, in real-time, so you're always in control of your spend.

Drop an image of your UI design or a photo of your architecture whiteboarding session, and Kiro can use it to guide its implementation.

Draft [commit messages](/docs/editor/source-control/#commit-message-generation) using the agent directly from the source control pane with a single click.

Kiro can [read and interpret](/docs/chat/diagnostics/) syntax, type, and semantic errors, making it easier to iterate and fix bugs.

See code changes as they happen. Approve everything, step through each change, or [make edits](/docs/editor/interface/) with one click.

## Trusted by engineers worldwide

As a startup co-founder and CTO, time is the most important resource. Kiro justifies the use of my time for developing our business critical assets in-house.

Rolf Koski

CTO & Co-Founder

In my role designing AWS Cloud and AI solutions with Terraform and Python, spec-driven development with Kiro has brought code relevancy and quality to a whole new level. We’ve accelerated feature development dramatically, reducing time to customer value from weeks to days. We are excited to welcome Kiro as our newest team member.

Håkon Eriksen Drange

Principal Cloud Architect

Kiro is a strong ally for startups. It naturally turns overlooked docs and specs into robust assets, making growth smoother and future scaling more effective.

Kento Ikeda

Founder & Engineer

I use Kiro for everything - drafting new Terraform modules, tweaking container setups, even writing down random AI ideas at 2 am. But more than anything, it supports how I learn. I’m endlessly curious, and Kiro helps me stay in that learning loop—tinkering, breaking things, fixing them, and then allowing me to share what I learn back with the community.

Adit Modi

Solution Architect

I’ve been blown away by Kiro’s capabilities. The agentic experience is really transformative. From the multimodal inputs that understand context to the complete lifecycle control within the IDE, it feels like I’m working with a senior developer.

Most tools are great at generating code, but Kiro gives structure to the chaos before you write a single line.

In roughly two days, I built a secure file sharing application from scratch. By simply sharing my requirements with Kiro, I was able to create a fully secure application that incorporates encryption and various security coding practices—no additional prompts needed.

I often forget to add unit tests, or update documentation when pushing changes, but with Kiro I can create a hook and it will automatically run those tasks in the background for me, never having to think twice.

As an open source developer, I typically don’t build games, but last night I was able to create one using Kiro. I didn’t have to think too hard about implementation since Kiro handled the logic and enabled me to write code quickly and accurately.

Kiro lowers the barrier to entry, whether that be, you don’t even know how to code, you’re new to coding, or you’re like me and you’re just learning a new tech stack. If something doesn’t make sense to you, or you feel like you are asking a silly question, ask Kiro anyway!

Kiro comes equipped with all the best practices that I would put in my specs, and builds me the application I want, faster.

Thanks to Kiro’s spec-driven development, I was able to go from concept to working prototype in a single weekend.

In just four lines into a spec, Kiro was able to write user stories like a product manager and capture so many details that I didn’t even need to mention, saving me several days of work.

Kiro isn’t just speeding up my work – it’s making me write better code, think more systematically about architecture, and deliver higher quality results while automated workflows happen seamlessly in the background.

Kiro is just more than code. Aside from just listening to prompts and doing things, it can actually work on tasks based on predefined triggers, making the development experience more efficient.

As a startup co-founder and CTO, time is the most important resource. Kiro justifies the use of my time for developing our business critical assets in-house.

Rolf Koski

CTO & Co-Founder

In my role designing AWS Cloud and AI solutions with Terraform and Python, spec-driven development with Kiro has brought code relevancy and quality to a whole new level. We’ve accelerated feature development dramatically, reducing time to customer value from weeks to days. We are excited to welcome Kiro as our newest team member.

Håkon Eriksen Drange

Principal Cloud Architect

Kiro is a strong ally for startups. It naturally turns overlooked docs and specs into robust assets, making growth smoother and future scaling more effective.

Kento Ikeda

Founder & Engineer

I use Kiro for everything - drafting new Terraform modules, tweaking container setups, even writing down random AI ideas at 2 am. But more than anything, it supports how I learn. I’m endlessly curious, and Kiro helps me stay in that learning loop—tinkering, breaking things, fixing them, and then allowing me to share what I learn back with the community.

Adit Modi

Solution Architect

I’ve been blown away by Kiro’s capabilities. The agentic experience is really transformative. From the multimodal inputs that understand context to the complete lifecycle control within the IDE, it feels like I’m working with a senior developer.

Most tools are great at generating code, but Kiro gives structure to the chaos before you write a single line.

In roughly two days, I built a secure file sharing application from scratch. By simply sharing my requirements with Kiro, I was able to create a fully secure application that incorporates encryption and various security coding practices—no additional prompts needed.

I often forget to add unit tests, or update documentation when pushing changes, but with Kiro I can create a hook and it will automatically run those tasks in the background for me, never having to think twice.

As an open source developer, I typically don’t build games, but last night I was able to create one using Kiro. I didn’t have to think too hard about implementation since Kiro handled the logic and enabled me to write code quickly and accurately.

Kiro lowers the barrier to entry, whether that be, you don’t even know how to code, you’re new to coding, or you’re like me and you’re just learning a new tech stack. If something doesn’t make sense to you, or you feel like you are asking a silly question, ask Kiro anyway!

Kiro comes equipped with all the best practices that I would put in my specs, and builds me the application I want, faster.

Thanks to Kiro’s spec-driven development, I was able to go from concept to working prototype in a single weekend.

In just four lines into a spec, Kiro was able to write user stories like a product manager and capture so many details that I didn’t even need to mention, saving me several days of work.

Kiro isn’t just speeding up my work – it’s making me write better code, think more systematically about architecture, and deliver higher quality results while automated workflows happen seamlessly in the background.

Kiro is just more than code. Aside from just listening to prompts and doing things, it can actually work on tasks based on predefined triggers, making the development experience more efficient.

As a startup co-founder and CTO, time is the most important resource. Kiro justifies the use of my time for developing our business critical assets in-house.

Rolf Koski

CTO & Co-Founder

In my role designing AWS Cloud and AI solutions with Terraform and Python, spec-driven development with Kiro has brought code relevancy and quality to a whole new level. We’ve accelerated feature development dramatically, reducing time to customer value from weeks to days. We are excited to welcome Kiro as our newest team member.

Håkon Eriksen Drange

Principal Cloud Architect

Kiro is a strong ally for startups. It naturally turns overlooked docs and specs into robust assets, making growth smoother and future scaling more effective.

Kento Ikeda

Founder & Engineer

I use Kiro for everything - drafting new Terraform modules, tweaking container setups, even writing down random AI ideas at 2 am. But more than anything, it supports how I learn. I’m endlessly curious, and Kiro helps me stay in that learning loop—tinkering, breaking things, fixing them, and then allowing me to share what I learn back with the community.

Adit Modi

Solution Architect

I’ve been blown away by Kiro’s capabilities. The agentic experience is really transformative. From the multimodal inputs that understand context to the complete lifecycle control within the IDE, it feels like I’m working with a senior developer.

Most tools are great at generating code, but Kiro gives structure to the chaos before you write a single line.

In roughly two days, I built a secure file sharing application from scratch. By simply sharing my requirements with Kiro, I was able to create a fully secure application that incorporates encryption and various security coding practices—no additional prompts needed.

I often forget to add unit tests, or update documentation when pushing changes, but with Kiro I can create a hook and it will automatically run those tasks in the background for me, never having to think twice.

As an open source developer, I typically don’t build games, but last night I was able to create one using Kiro. I didn’t have to think too hard about implementation since Kiro handled the logic and enabled me to write code quickly and accurately.

Kiro lowers the barrier to entry, whether that be, you don’t even know how to code, you’re new to coding, or you’re like me and you’re just learning a new tech stack. If something doesn’t make sense to you, or you feel like you are asking a silly question, ask Kiro anyway!

Kiro comes equipped with all the best practices that I would put in my specs, and builds me the application I want, faster.

Thanks to Kiro’s spec-driven development, I was able to go from concept to working prototype in a single weekend.

In just four lines into a spec, Kiro was able to write user stories like a product manager and capture so many details that I didn’t even need to mention, saving me several days of work.

Kiro isn’t just speeding up my work – it’s making me write better code, think more systematically about architecture, and deliver higher quality results while automated workflows happen seamlessly in the background.

Kiro is just more than code. Aside from just listening to prompts and doing things, it can actually work on tasks based on predefined triggers, making the development experience more efficient.

## Get started fast with quick guides

## Common questions

### What is Kiro?

### What is Kiro?

### What is spec-driven development? How is it different from vibe coding?

### What is spec-driven development? How is it different from vibe coding?

### How can I get started with Kiro?

### How can I get started with Kiro?

### What programming languages does Kiro support?

### What programming languages does Kiro support?

### What languages can I ask questions in?

### What languages can I ask questions in?

### Can I import settings from my existing IDE?

### Can I import settings from my existing IDE?

## Build something real in minutes

Get started for free

### License

©2026 Amazon.com, Inc. or its affiliates (collectively, “Amazon”). All Rights Reserved.

The Kiro IDE and Kiro CLI are each licensed to you as “AWS Content” under the [AWS Customer Agreement](https://aws.amazon.com/agreement/) or other written agreement with us governing your use of AWS services, and the [AWS Intellectual Property License](https://aws.amazon.com/legal/aws-ip-license-terms/).

## Open Source Attribution

For a full list of open source references:

- In the Kiro IDE, refer to the “View License” page in the Kiro “Help” Toolbar. Kiro uses Chromium as its underlying engine. Download the Chromium v124.0.6367.243 source code for GPL compliance. Chromium is licensed under the BSD License and other open source licenses.
- In the Kiro CLI, run kiro-cli dashboard. Go to preferences, then click the “Show License” button at the bottom of the page.

### Managing your payments - IDE - Docs - Kiro

# Managing your payments

---

Your Kiro subscription gives you access to powerful AI-assisted development features. Here's how to manage your account and get the most out of your subscription.

## Accessing your billing information

To manage your billing and payment information:

1. In Kiro, select the profile icon.
2. Choose Manage Plan. You will be redirected to your default web browser.
3. In the billing dashboard, you'll find several sections:

- Current Subscription
  - View your active plan details
  - See your next billing date and amount
  - Check your subscription status
- Payment Method
  - View saved payment methods
  - Update or add new credit or debit cards
- Billing Information
  - Update your billing address
  - If applicable, add or update tax ID information
  - Billing information changes will be applicable for future invoices only
- Invoice History
  - View all past invoices and payments
  - Download PDF copies of your invoices
  - See payment dates, amounts, and status

## Updating your payment method

1. In Kiro, select the profile icon.
2. Choose Manage Plan. You will be redirected to your default web browser.
3. Choose Add Payment Method or Edit your existing payment method. You'll be redirected to our secure customer portal where you can update your card information.
4. Enter the details of your new payment method and your billing address.
5. If applicable, complete 3D-Secure authentication.
6. Choose Add to securely store your payment method.

We accept all major credit and debit cards. Your card will be charged in USD currency.

## Viewing billing history and downloading invoices

1. In Kiro, select the profile icon.
2. Choose Manage Plan. You will be redirected to your default web browser.
3. In the Invoice History section, browse through your past invoices, and select an invoice to view its details and download it as a PDF.

## Troubleshooting payment issues

When a payment fails, you'll receive an email notification, your subscription status will change to *"past due"*, and you will lose access to paid features. Our system automatically retries failed payments over several days. Once payment succeeds, paid plan access will immediately be restored and you'll receive a confirmation. You can also reactivate your subscription by updating your payment method and paying any outstanding balance.

If you're experiencing payment issues:

- Check that your card hasn't expired and has sufficient funds
- Update payment information if needed
- Contact your bank to check if they blocked the charge

### Managing your taxes - IDE - Docs - Kiro

# Managing your taxes

---

This section provides answers to tax collection, VAT, and billing address questions for Kiro.

## Why do I see information for Amazon web services, inc. For my Kiro purchase?

Amazon Web Services, Inc. is the service provider for Kiro. Amazon Web Services, Inc. ("AWSI") is established and operates in the United States. AWSI is registered for Sales Tax in the states shown [here](https://aws.amazon.com/tax-help/united-states/). AWSI is also registered for VAT in countries where indirect tax laws require foreign providers of Electronically Supplied Services ("ESS") to register and collect local VAT. AWSI treats Kiro as Downloaded Software in the USA and as ESS outside of the USA. If required by your country's Indirect Tax laws, AWS will collect Indirect Taxes from you, issue a tax invoice, and remit it to the tax authority in AWS's name. In some countries, AWS is not required to collect Indirect Taxes from you and remit it to the tax authority in AWS's name if you have a valid tax registration number ("TRN") in that country. You need to add your TRN to your Stripe Account Customer Profile, and you may be required to self-assess VAT depending on local regulations.

Please see below jurisdictions where tax will be charged on Kiro purchases:

| Country Name | Tax Collected From | Tax Rate |
| --- | --- | --- |
| AUSTRALIA | B2C | 10% |
| AUSTRIA | B2B/B2C | 20% |
| BANGLADESH | B2B | 15% |
| BELGIUM | B2B/B2C | 21% |
| BULGARIA | B2C | 20% |
| CANADA | B2B/B2C | Varies by Province |
| CHILE | B2C | 19% |
| CZECH REPUBLIC | B2B/B2C | 21% |
| FRANCE | B2C | 20% |
| GERMANY | B2C | 19% |
| INDIA | B2C | 18% |
| INDONESIA | B2B/B2C | 11% |
| ISRAEL | N/A | 18% |
| ITALY | B2C | 22% |
| JAPAN | B2B/B2C | 10% |
| KOREA (REPUBLIC OF KOREA) | B2C | 10% |
| MALAYSIA | B2B/B2C | 8% |
| NEPAL | B2B | 13% |
| NETHERLANDS | B2C | 21% |
| NEW ZEALAND | B2C | 15% |
| NORWAY | B2B/B2C | 25% |
| POLAND | B2C | 23% |
| PORTUGAL | B2B/B2C | 23% |
| ROMANIA | B2C | 19% |
| SINGAPORE | B2C | 9% |
| SOUTH AFRICA | B2B/B2C | 15% |
| SPAIN | B2C | 21% |
| SWEDEN | B2B/B2C | 25% |
| SWITZERLAND | B2B/B2C | 8.1% |
| TAIWAN | B2C | 5% |
| THAILAND | B2C | 7% |
| UK | B2C | 20% |
| UNITED ARAB EMIRATES | B2B/B2C | 5% |
| UNITED STATES (US) | B2B/B2C | Varies by state |

## How does AWS determine my location to determine the applicable taxes for my account(s)?

AWS will use your customer billing address you provide when purchasing Kiro. If the billing address entered is invalid, you will get a customer_tax_location_invalid error.

## I am a B2B (business) customer, my company's tax registration number (TRN) is on our stripe/AWS accounts, so why are we being charged VAT rather than using reverse charge and self-assessing VAT?

Kiro is billed using a different platform (not the AWS Console). If you are a B2B customer who has provided its TRN in your AWS Account, you will need to also include for your Kiro account through your customer portal. In addition, certain jurisdictions require AWS to charge and collect tax on both B2B and B2C purchases, in these jurisdictions AWS is responsible, and you will not be able to Self-Assess.

## If I update my tax, account, or billing address mid-month, how is VAT calculated?

AWS will use your billing address at the time of your purchase, or changes to your subscription such as upgrades or renewals.

## I receive special status/relief from paying VAT. How do I check that I am not charged VAT?

Special status/relief status from paying VAT is coming soon.

## What payment currencies and payment methods are supported by AWS inc. For Kiro purchases?

We accept all major credit cards. Kiro usage is invoiced in USD.

## My VAT invoice, and/or AWS seller appears incorrectly.

Please contact [Kiro billing support](https://support.aws.amazon.com/#/contacts/kiro).

## What tax registration numbers (trns) and formats are accepted?

Kiro will accept TRNs based on the requirements set forth by the country in which the customer is located. When a customer adds a TRN, Kiro will check that the formatting is correct.

### Enabling overages - IDE - Docs - Kiro

# Enabling overages

---

If you subscribed to the Pro, Pro+, or Power tier, you might consider enabling overages. Overages are additional fees that AWS charges when you exceed the predetermined credit limits or allowances specified in your plan.

Overages are disabled by default.

You can't incur overages at the **Kiro Free** tier. When you hit a credit limit, you must wait until the next month for your quotas to reset.

### Why allow overages?

Allowing overages rather than disabling them completely has the following advantages:

- Uninterrupted productivity – When you exceed your plan's quota, you can continue working without disruption. The productivity benefits of continued access might outweigh the additional costs.
- Better credit pattern insights – You get more accurate data about your actual usage, which helps in right-sizing future subscription needs.

### Enabling overage charges in Kiro

Use the following instructions to enable overage charges for a social account or an AWS Builder ID account.

1. In Kiro, select the profile icon.
2. In Overages, toggle on the associated switch.

### Powers

Available in Kiro IDE 0.7+.

### Find or create a power

Browse curated powers from partners or the community, or build your own. Powers package MCP, steering, and hooks into reusable capabilities.

### Install with one click

Add powers instantly from the website or IDE. Kiro handles configuration and setup automatically, making specialized capabilities available in seconds.

### Activate on-demand

Powers load dynamically based on your conversation context. Kiro evaluates installed powers and activates only the relevant ones, keeping your agent focused.

Kiro powers encapsulate best practices from dev tool providers and domain experts to steer agents for use cases spanning design, development, deployment, and observability.

### API Testing with Postman

Automate API testing and collection management with Postman - create workspaces, collections, environments, and run tests programmatically

### Design to Code with Figma

Connect Figma designs to code components - automatically generate design system rules, map UI components to Figma designs, and maintain design-code consistency

### Deploy web apps with Netlify

Deploy React, Next.js, Vue, and other modern web apps to Netlify's global CDN with automatic builds.

### Build applications with Aurora PostgreSQL

Build applications backed by Aurora PostgreSQL by leveraging Aurora PostgreSQL specific best practices.

### Build a database with Aurora DSQL

Build and deploy a PostgreSQL-compatible serverless distributed SQL database with Aurora DSQL - manage schemas, execute queries, and handle migrations with DSQL-specific requirements.

### Build a backend with Supabase

Build applications with Supabase's Postgres database, authentication, storage, and real-time subscriptions

### Build a backend (local) with Supabase

Local development with Supabase allows you to work on your projects in a self-contained environment on your local machine.

### Deploy infrastructure with Terraform

Build and manage Infrastructure as Code with Terraform - access registry providers, modules, policies, and HCP Terraform workflow management

### InsideOut Cloud Infrastructure

Design, price, and deploy production-ready AWS and GCP infrastructure through conversational AI — generates Terraform and deploys with one command

### Build an agent with Strands

Build AI agents with Strands Agent SDK using Bedrock, Anthropic, OpenAI, Gemini, or Llama models

### Build an agent with Amazon Bedrock AgentCore

Amazon Bedrock AgentCore is an agentic platform for building, deploying, and operating effective agents.

### Build a database with Neon

Serverless Postgres with database branching, autoscaling, and scale-to-zero - perfect for modern development workflows

### Amazon CloudWatch Application Signals

Monitor service health, analyze SLO compliance, and perform root cause analysis with distributed tracing and audit capabilities

### Datadog Observability

Query logs, metrics, traces, RUM events, incidents, and monitors from Datadog for production debugging and performance analysis

### Dynatrace Observability

Query logs, metrics, traces, problems, and Kubernetes events from Dynatrace using DQL for production debugging and performance analysis

### Hud - Runtime Code Sensor

Hud's Runtime Code Sensor detects errors, performance degradations and CPU spikes in production, with the deep forensic context needed to fix them quickly with AI.

### Stripe Payments

Build payment integrations with Stripe - accept payments, manage subscriptions, handle billing, and process refunds

### Build AWS infrastructure with CDK and CloudFormation

Build well-architected AWS infrastructure with CDK using latest documentation, best practices, and code samples. Validate CloudFormation templates, check resource configuration security compliance, and troubleshoot deployments.

### AWS HealthOmics

Create, migrate, run, debug and optimize genomics workflows in AWS HealthOmics

### Build a Power

Complete guide for building and testing new Kiro Powers with templates, best practices, and validation

### SaaS Builder

Build production ready multi-tenant SaaS applications with serverless architecture, integrated billing, and enterprise grade security

### Build infrastructure on AWS

Build AWS infrastructure with CDK in Python following AWS Well-Architected framework best practices

### Deploy Web Apps and APIs to AWS using ECS Express Mode

Assists with deploying a web app or API to AWS using Amazon ECS Express Mode. ECS Express Mode takes your container image and gives you back an HTTPS endpoint

Don't see your company or project's power? [Submit a power](/powers/submit/)

## Common questions

### What are Kiro powers?

### What are Kiro powers?

### What use cases are Kiro powers available for?

### What use cases are Kiro powers available for?

### Will I be charged for Kiro powers?

### Will I be charged for Kiro powers?

### How do I install powers?

### How do I install powers?

### How do Kiro powers by third-parties relate to the Kiro service?

### How do Kiro powers by third-parties relate to the Kiro service?

### How do I create Kiro powers?

### How do I create Kiro powers?

### Can I stack Kiro powers?

### Can I stack Kiro powers?

### How do I share Kiro powers I’ve created?

### How do I share Kiro powers I’ve created?

### Are Kiro powers available in both IDE and CLI?

### Are Kiro powers available in both IDE and CLI?

## Create your own power and share it

### Pricing

### KIRO FREE

- 50 credits

### KIRO PRO

- 1,000 credits
- Pay-per-use overage ($0.04/credit)

### KIRO PRO+

- 2,000 credits
- Pay-per-use overage ($0.04/credit)

### KIRO POWER

- 10,000 credits
- Pay-per-use overage ($0.04/credit)

### Empower your team with Kiro for enterprise

Assign the right paid plan to individual users

Usage analytics and reporting

Pay-per-use overage

Enterprise security and privacy controls

Centralized team billing

SAML/SCIM SSO via AWS IAM Identity Center

Organizational management dashboard

### Empower your team with Kiro for enterprise

Assign the right paid plan to individual users

Centralized team billing

Usage analytics and reporting

SAML/SCIM SSO via AWS IAM Identity Center

Pay-per-use overage

Organizational management dashboard

Enterprise security and privacy controls

## Common Questions

### How does Kiro pricing work?

### How does Kiro pricing work?

### What models does Kiro use under the hood?

### What models does Kiro use under the hood?

### How does the free trial work?

### How does the free trial work?

### What is a credit?

### What is a credit?

### What can I use credits for?

### What can I use credits for?

### How can I track my credit usage?

### How can I track my credit usage?

### Can I pay for additional credits?

### Can I pay for additional credits?

### Can I share my Kiro subscription with my team?

### Can I share my Kiro subscription with my team?

### What happens if I don’t use all my monthly credits?

### What happens if I don’t use all my monthly credits?

### What payment methods do you accept?

### What payment methods do you accept?

### What countries or regions are supported for individual plans?

### What countries or regions are supported for individual plans?

### Is the agent preview included in my current plan or will I be charged extra?

### Is the agent preview included in my current plan or will I be charged extra?

### Will I be charged for Kiro powers?

### Will I be charged for Kiro powers?

### Managing proactive usage notifications - IDE - Docs - Kiro

# Managing proactive usage notifications

---

Kiro provides proactive usage notifications to help you monitor your credit consumption and avoid unexpected charges. These notifications keep you informed about your usage patterns and help you make informed decisions about your subscription tier.

## Notification types

Kiro sends several types of usage notifications to help you stay on top of your credit consumption:

### Low resource notifications

When you reach 80% of your monthly credit usage, Kiro sends a low resource notification with options based on your current plan:

- Free tier users receive suggestions to upgrade to a paid tier for continued access, with a reminder that credits reset monthly and overages aren't available.
- Paid tier users receive different options depending on their situation:
  - If you can upgrade, you'll be prompted to upgrade for more credits or enable overages as an alternative.
  - If you have the highest tier, you'll be prompted to enable overages for uninterrupted access or reminded that overages are already enabled with current rates.

### Overage notifications

When you exceed your monthly credit limit with overages enabled, Kiro immediately sends notifications:

- If you can upgrade, you'll be prompted to upgrade for more credits or enable overages as an alternative.
- If you have the highest tier, you'll be alerted that overages are now in effect and receive details on when your usage limit will reset.

### Usage reset notifications

At the start of each billing cycle, usage reset notifications are sent when your credits refresh:

- If you have overages disabled, you'll receive an alert on the total number of credits available.
- If you have overages enabled, you'll receive an alert on the total number of credits available and confirmation that you have overages enabled.

## Managing notification preferences

By default, billing notifications are enabled. You can disable these notifications in your settings:

1. Open Settings: Command Palette (⌘/Ctrl + Shift + P)
2. Search for Notifications: Billing
3. Unselect Notifications: Billing to disable billing-related notifications.

## Understanding your usage patterns

Proactive notifications help you:

- Identify usage spikes – Understand when and why your credit consumption increases
- Right-size your plan – Determine if you need to upgrade or downgrade your subscription
- Optimize workflows – Adjust your development patterns to use credits more efficiently
- Avoid surprises – Stay informed about potential overage charges before they occur

If you consistently receive 90% usage alerts early in your billing cycle, consider upgrading to a higher tier to ensure uninterrupted productivity.

### Related questions - IDE - Docs - Kiro

# Related questions

---

This section provides answers to billing, subscriptions, and payment questions for Kiro.

## Which countries or regions are supported for paid plans?

Currently, you can purchase a Kiro paid plan with a billing address in Afghanistan, Algeria, Angola, Antigua and Barbuda, Argentina, Armenia, Aruba, Australia, Austria, Azerbaijan, Bangladesh, Belgium, Belize, Bermuda, Bhutan, Bolivia, Bosnia and Herzegovina, Botswana, Brazil, Brunei, Bulgaria, Burkina Faso, Burundi, Cambodia, Canada, Cape Verde, Cayman Islands, Central African Republic, Chad, Chile, China, Colombia, Comoros, Congo, Cook Islands, Costa Rica, Croatia, Curacao, Cyprus, Czech Republic, Democratic Republic of the Congo, Denmark, Djibouti, Dominica, Dominican Republic, East Timor, Ecuador, El Salvador, Equatorial Guinea, Eritrea, Estonia, Ethiopia, Falkland Islands, Fiji, Finland, France, French Guiana, Gabon, Gambia, Germany, Gibraltar, Greece, Greenland, Grenada, Guatemala, Guinea, Guinea-Bissau, Guyana, Haiti, Honduras, Hong Kong SAR, Hungary, India, Indonesia, Iraq, Ireland, Israel, Italy, Jamaica, Japan, Jordan, Kiribati, Kosovo, Latvia, Lebanon, Lesotho, Liberia, Libya, Lithuania, Luxembourg, Macao, Macedonia, Madagascar, Malawi, Malaysia, Maldives, Mali, Malta, Mauritania, Mexico, Mongolia, Montenegro, Morocco, Mozambique, Myanmar, Namibia, Nauru, Nepal, Netherlands, New Zealand, Nicaragua, Niger, Norway, Palestinian Territories, Panama, Papua New Guinea, Paraguay, Philippines, Poland, Portugal, Qatar, Romania, Rwanda, Saint Kitts and Nevis, Saint Lucia, Saint Vincent and the Grenadines, Samoa, San Marino, Seychelles, Sierra Leone, Singapore, Slovakia, Slovenia, Solomon Islands, Somalia, South Africa, South Korea, South Sudan, Spain, Sri Lanka, Swaziland, Sweden, Switzerland, Tajikistan, Tanzania, Thailand, Togo, Tonga, Trinidad and Tobago, Tunisia, Turkmenistan, Tuvalu, United Arab Emirates, United Kingdom, United States of America, Uruguay, Uzbekistan, Vanuatu, Vatican City State, Venezuela, and Yemen. More countries or regions will be added soon.

## What is a credit?

A credit is a unit of work in response to user prompts. Simple prompts can consume less than 1 credit. More complex prompts, such as executing a spec task, typically cost more than 1 credit. Additionally, different models consume credits at different rates, with a prompt executed via Sonnet 4 costing more credits than executing it with Auto. For example, a given task that consumes X credits to execute in Auto, will cost you 1.3X credits to execute via Sonnet 4. Credits are metered to the second decimal point, so the least number of credits a task can consume is 0.01 credits.

## What paid plan should I choose if I'm not sure about my future usage?

Many customers are still exploring agentic development, and we expect that learning curve to continue beyond the first month. We don’t want you to have to predict your future usage or “time” upgrades to get a fair deal—we want you focused on building. A good path is to start on Pro and, if needed, enable overage so you can continue working without friction. If you later decide you need more, upgrade when you’re ready. In your first paid month we’ll discount for what you already paid and charge a single prorated amount for the higher plan back to the day you first became paid, so you won’t pay more than if you had upgraded earlier. For example, in a 30-day month if you start Pro on day 15 ($10 for the rest of the month) and later switch to Pro+ the same month, we discount for the $10 and charge $20—net $10—so you finish the month on Pro+ with one prorated allowance. From Month 2 onward, upgrades charge the full price difference and we re-rate the whole month under the higher plan’s limits, which also prevents overpaying.

## What paid plan should I choose once my Kiro usage is stable?

Our intent with Kiro’s pricing is to let most developers work comfortably without micromanaging usage or worrying about surprises. Once your usage settles into a pattern, choose the smallest subscription plan that reliably covers a typical month, with a little headroom. That reflects our goal of making your default experience predictable: if you prefer a fixed bill, leave overage off and your usage will pause at the cap; if you prefer continuity during occasional spikes, keep overage on. If those spikes become frequent, or your month-end overage spend starts to approach the price difference to the next tier, moving up will usually lower your total cost while keeping things simple.

## What happens when I reach the monthly limit of my plan?

If you hit the limit, requests pause until your limits reset at the start of the next
month.

The **Kiro Free** tier has fixed monthly limits and does not allow overage. If you hit a Free limit, you can upgrade to a paid plan
for immediate additional capacity.

On paid plans, you can enable overage to continue working uninterrupted beyond your included limits. You can also upgrade
to a higher plan at any time, and the higher usage limits immediately apply.

## I'm near month-end. Should I upgrade now or rely on overage?

If you're on a paid plan and only have a few days left, turning on overage is often the simplest way to finish the month
unless your month-to-date overage cost is approaching the price difference to the next tier. When that "breakeven" point
is reached, upgrading will usually lower your total bill and raise your limits immediately. In your first paid month, if
you do upgrade late, we apply a discount for what you've already paid and charge a single prorated amount for the higher
plan back to the day you first became paid, so you don't overpay for waiting a bit. From Month 2 onward, mid-month
upgrades charge the full price difference and we re-rate the whole month under the higher plan.

## What happens to my bonus credits if I upgrade early?

If you are within the 30 day trial period for the bonus credits, those credits will carry over for the remainder of the 30 day trial period, independent of the plan you upgrade to.

## How does proration work during the initial month that I upgrade from the free trial or Kiro free tier to paying?

During the month that you first upgrade to a paid plan, the plan charges are pro-rated by days remaining in the month. For example, in a 30-day month, if you upgrade to Pro ($20) with 10 days left (i.e., on day 21), you pay $6.67 (10/30 of $20) and receive access to Pro credit limits immediately. Informally, because you’re on Pro for one-third of the month, you pay one-third of the price, but get the full monthly quota of your new plan immediately.

If you later upgrade to Pro+ ($40) in that same first paid month, we discount the $6.67 you already paid for Pro and charge $13.33 (10⁄30 of $40), so your net extra payment is $6.66 at the time of upgrade. On your invoice, this appears as a discount line for the earlier Pro charge and a prorated charge line for Pro+.

## How does proration work after the first upgrade?

Prorated pay only applies to the first upgrade. After the first upgrade, any future upgrade, at any day of the month, will be charged in full and users will receive full plan limits.

## What happens to my existing overage if I upgrade during the middle of the month?

Our intent is that you shouldn’t have to “time” an upgrade or pay twice for the same usage. When you upgrade to a higher subscription plan mid-month, we re-evaluate your month-to-date usage under the higher plan, so you get the benefit of its larger limits.

## When does Kiro bill me?

Kiro bills on a calendar month. Your billing month starts at 12:00 a.m. (UTC) on the first day of the month and ends at 11:59 p.m. (UTC) on the last day. The exact timing of your monthly charge will depend on your local timezone. If you upgrade mid-month, we will bill you immediately for the cost of the new plan discounted by the cost of the prior plan. Overage is included as separate line items on your month’s bill.

## Why might a single action span more than one credit?

Some actions require much more context or generate more output than average, such as working across a large codebase or executing a highly complex build. When that happens, the total token usage can exceed the limit for a single request, and Kiro will count it as more than one credit. You’ll see the count right after the interaction finishes.

## How does Kiro help optimize my costs?

Kiro is engineered to minimize redundant LLM work. We reuse context where possible and apply provider‑level efficiencies, such as token‑efficient tool use and prompt caching when available, to cut underlying token spend without adding friction to your workflow. You pay by request, not by token, and we pass efficiency gains through Kiro's pricing plan design rather than asking you to micromanage prompts.

## How can I retrieve my User ID?

You can find your User ID in the usage dashboard. In the dashboard, your User ID is displayed next to your email address and sign-in method. Look for the "User ID" label with a copy icon that allows you to easily copy your unique identifier for support or billing purposes.

### Kiro for Startups

### Build faster with specs

Easily transition from vibe to spec mode and quickly bring your ideas from prototype to production.

### Scale smarter

Bring structure to your AI coding workflows across tools, environments, and teams.

### Ship securely from day 1

Built on AWS with security and privacy, ship your work with confidence.

> Kiro is the AI IDE we trust in a regulated environment. It provides the security foundation and reliability we need to operate confidently under strict regulatory oversight. It has shifted our engineering time from grunt work to impact.

> Kiro gave me momentum. Ideas turned into plans we could trust, and shipping felt calm instead of chaotic. I spend less time herding tasks and more time building, with a level of clarity that sticks from kickoff to release.

> Once I’m confident in a new idea, spec mode lets me be precise on requirements. This precision automatically converts into production-quality code quickly without the undesired AI slop.

## Common questions

### What are Kiro startup credits?

### What are Kiro startup credits?

### Who is eligible to apply for Kiro startup credits?

### Who is eligible to apply for Kiro startup credits?

### Which countries or regions support Kiro startup credits?

### Which countries or regions support Kiro startup credits?

### Do I need an AWS Account to apply for Kiro Credits?

### Do I need an AWS Account to apply for Kiro Credits?

### How do I use my Kiro startup credits?

### How do I use my Kiro startup credits?

### How will I be notified about my credit application status?

### How will I be notified about my credit application status?

### Can I apply for Kiro credits more than once?

### Can I apply for Kiro credits more than once?

### Can I apply multiple times with the same AWS Account?

### Can I apply multiple times with the same AWS Account?

### Can I submit more than one application at the same time?

### Can I submit more than one application at the same time?

### Can I wait to activate my credits?

### Can I wait to activate my credits?

### How do I track my credit usage?

### How do I track my credit usage?

### What happens after my credits are used?

### What happens after my credits are used?

### Can I redeem free Kiro credits and also use Activate credits towards Kiro?

### Can I redeem free Kiro credits and also use Activate credits towards Kiro?

### Do the credits expire?

### Do the credits expire?

### Can my Kiro credits be refunded or re-issued?

### Can my Kiro credits be refunded or re-issued?

### Can I transfer or sell my Kiro credits?

### Can I transfer or sell my Kiro credits?

### Can I share my Kiro credits with associated accounts?

### Can I share my Kiro credits with associated accounts?

### I have a question about how Kiro startup credits work. Who should I contact?

### I have a question about how Kiro startup credits work. Who should I contact?

## Start building with Kiro

### Submit a power

### Startup Program Terms & Conditions 2025

*Updated: December 2, 2025*

By submitting your application for Kiro Pro+, you agree to the promotional offer's terms and conditions.

- From November 17, 2025, 12:01am PT, to December 31, 2025, 11:59pm PT, apply and be approved for access to Kiro Pro+ to receive one years’ worth of Kiro credits based on selection of the Starter, Growth, or Scale tier of the Kiro Pro+ offering. For the avoidance of doubt, applicable overage charges may apply to continue access to the Kiro offering once credits have been exhausted or have expired.
- Offer is only valid for individuals 18 years and older. Excludes individuals living in Argentina, Brazil, France, Germany, Italy, Mexico, Quebec, Russia, Spain, Cuba, Iran, North Korea, Syria, and the region of Crimea.
- Offer is limited to companies ranging from early stage to Series B startups who have created an Amazon Web Services ("AWS") Account.
- The email address used to create your AWS Account must be the same email address used for your AWS primary development account, and must include a domain name matching the domain name for your startup's corporate website. If you are a first-time AWS user, create an AWS account to obtain an AWS Account ID.
- By providing your website URL, you authorize us to use automated means to collect publicly available information from your website to evaluate your credit application.
- You will receive notice of your application status at the email address associated with your AWS Account.
- Kiro credits will be issued to your startup, and will not be made available on an individual basis. Failure to provide AWS complete or accurate information may delay or prevent offer fulfillment. Kiro credits will be directly deposited to the provided AWS Account ID immediately upon approval of your application and will activate upon provision. Kiro credits expire 1 year after the date of issuance to your AWS Account. You can view your credit usage in your AWS Account.
- The number of credits you are awarded will be determined by the tier you select. Once you have used all Kiro credits provided under this promotion, your AWS Account will automatically switch to standard Kiro Pro+ billing at the then-current billing rates. If you have any questions, you may contact the AWS Activate Support Team.
- Offer cannot be refunded or re-issued.
- Offer limited to 1 subscription per startup. You may only receive Kiro credits once under this promotion. If you previously applied for this promotion and were rejected, and your eligibility status has changed, you can re-apply if you meet all of the current requirements.
- AWS reserves the right to modify or cancel the offer at any time.
- Offer is non-transferable and may not be resold.
- If you violate any of these terms and conditions, the offer will be invalid.
- Void where prohibited.
- Your information is handled in accordance with the AWS Privacy Notice.

### Troubleshooting - IDE - Docs - Kiro

# Troubleshooting

---

This guide helps you resolve common issues with Kiro, including shell integration and MCP server connection problems.

## Kiro Installation Issues

### macOS: Kiro is damaged and can’t be opened

On macOS, you may encounter this error when trying to open Kiro:

```
Kiro is damaged and can't be opened. You should move it to the Trash.

```

This pop-up is due to a false positive in macOS security features.

To resolve this error:

- Go to System Settings → Privacy & Security and click Allow or Open anyway for Kiro.
- Drag Kiro.app to your desktop, and then drag it from your desktop to the Applications folder.
- Restart your computer.
- Open your terminal and run:
sudo xattr -d com.apple.quarantine /Applications/Kiro.app

## Authentication issues

### Browser redirect failures during authentication

If while authenticating with Kiro you are not redirected to the browser, try these platform-specific solutions:

#### Windows

Run Kiro with logging enabled to identify potential issues:

1. Open Command Prompt as administrator
2. Run the following command (replace with your actual Kiro installation path):
C:\path\to\app.exe --enable-logging
3. Check the logs for any errors
4. If you see access denied errors, ensure your user has administrator permissions to run the app

#### macOS

Use the developer tools to diagnose the issue:

1. Open Kiro
2. Go to Help → Toggle Developer Tools
3. Navigate to the Console tab
4. Observe any errors reported during the sign-in process
5. If the error indicates a missing dependency, ensure it's available in your PATH
  - One common issue is the missing ioreg command
  - Verify ioreg is included in your PATH variable:
bashecho $PATH
which ioreg
  - If ioreg is missing, it's typically located at /usr/sbin/ioreg

### AWS IAM Identity Center issues

#### Q Developer Pro subscription required

If you see an error `There was an error signing you in` when attempting to authenticate with Identity Center, ensure you have a valid Q Developer Pro subscription. You need an active Pro subscription to use Identity Center authentication with Kiro. Here is a [guide on how to view your subscription status and upgrade to Pro](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/q-admin-setup-subscribe-general.html).

#### Regional limitations for Q Developer profiles

If you're unable to sign in with Identity Center despite having valid credentials, this may be due to regional limitations. Kiro defaults to the US East (N. Virginia) region for Identity Center authentication. If you have a Q Developer profile in a different region, you won't be able to sign in with Identity Center.

As an alternative, use a different login method such as Builder ID or social providers such as Google or GitHub. We're working on addressing this regional limitation in future releases.

#### Session duration and timeouts

Identity Center sessions have a default timeout of 8 hours, which means you'll need to re-authenticate periodically. To extend session duration, administrators can configure longer session timeouts. For detailed configuration instructions, see the [AWS documentation on configuring user session duration](https://docs.aws.amazon.com/singlesignon/latest/userguide/user-session-duration-how-to-configure.html).

## Shell integration issues

Shell integration connects Kiro to your terminal, enabling automatic command execution and result processing. Without it, you'll need to manually copy-paste terminal outputs.

### Quick fix: "shell integration unavailable"

1. Update Kiro: Command Palette (Cmd + Shift + P / Ctrl + Shift + P) → Kiro: Check for Updates
2. Enable Integration: Command Palette (Cmd + Shift + P / Ctrl + Shift + P) → Kiro: Enable Shell Integration
3. Restart: Quit and reopen Kiro

### Manual installation

If automatic setup fails, add to your shell config:

**Zsh** (`~/.zshrc`):

```bash
[[ "$TERM_PROGRAM" == "kiro" ]] && . "$(kiro --locate-shell-integration-path zsh)"

```

**Bash** (`~/.bashrc`):

```bash
[[ "$TERM_PROGRAM" == "kiro" ]] && . "$(kiro --locate-shell-integration-path bash)"

```

**Fish** (`~/.config/fish/config.fish`):

```bash
string match -q "$TERM_PROGRAM" "kiro"
and . (kiro --locate-shell-integration-path fish)

```

**PowerShell** (`$Profile`):

```powershell
if ($env:TERM_PROGRAM -eq "kiro") { . "$(kiro --locate-shell-integration-path pwsh)" }

```

### Kiro Stuck in 'Working...' Status on Terminal Commands or Kiro Does Not See Terminal Output

If Kiro is unable to read terminal output, gets stuck in `Working...` status, or you see strange characters and formatting issues, this is typically caused by shell customizations that interfere with terminal integration. Common culprits include customizations like bash-it on bash or Oh My Posh on zsh, and themes such as Powerlevel10k/9k.

#### Powerlevel10k theme users

If you're using Powerlevel10k theme, add this line to your `.p10k.zsh` file:

```bash
typeset -g POWERLEVEL9K_TERM_SHELL_INTEGRATION=true

```

Alternatively, you can also disable these customizations when running in Kiro.

**zsh** (`~/.zshrc`):

```bash
if [[ "$TERM_PROGRAM" == "kiro" ]]; then
  # Leave empty
else
  # Your themes or customizations
  ZSH_THEME="powerlevel10k/powerlevel10k"
fi

```

#### Fish shell users

If you're using Fish shell and experiencing terminal output issues, you may need to manually add Kiro to the existing shell integration script. The Fish shell integration file is located at:

```
/Applications/Kiro.app/Contents/Resources/app/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration.fish

```

By default, the integration script only checks for "vscode":

```bash
status is-interactive
and string match --quiet "$TERM_PROGRAM" "vscode"
and ! set --query VSCODE_SHELL_INTEGRATION
or exit

```

You need to update it to include "kiro" as well:

```bash
status is-interactive
and string match --quiet "$TERM_PROGRAM" "vscode" "kiro"
and ! set --query VSCODE_SHELL_INTEGRATION
or exit

```

## Windows issues

### Updates disabled due to administrator installation

On Windows if you experience this error:

```
Updates are disabled because you are running the user-scope installation of Kiro as Administrator. This occurs as Kiro does not support system-level installation, which requires administrator privileges.

```

To remove run as administrator, you can:

1. Right-click on the Kiro icon
2. Select Show more options
3. Select Properties
4. Navigate to the Compatibility tab
5. Uncheck the Run this program as an administrator checkbox
6. Select Apply and then OK to save the changes

After completing these steps, Kiro should be able to update normally.

### Unable to run scripts

In PowerShell 7+ set execution policy:

**Check current policy**:

```powershell
Get-ExecutionPolicy

```

**Set execution policy**:

```powershell
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

```

### Onedrive path issue

If you use OneDrive on Windows, your desktop path might cause issues:

1. Launch Command Prompt as administrator
2. Create a symbolic link:
mklink /J "C:\Users\<username>\Desktop" "C:\Users\<username>\OneDrive\Desktop"
3. Restart your IDE

## MCP server connection issues

### Common MCP connection problems

If you're having trouble connecting to MCP servers:

1. Check server status:
  - Open the Kiro panel and navigate to the MCP servers tab
  - Check the connection status indicator for your server
2. Verify configuration:
  - Ensure your MCP configuration file has the correct syntax
  - Check that the server command and arguments are correct
3. Check prerequisites:
  - Make sure all required dependencies are installed
  - For AWS Documentation server, verify Python 3.10+ and uv are installed
4. Review logs:
  - Open the Output panel in Kiro
  - Select "Kiro - MCP Logs" from the dropdown
  - Look for specific error messages

### Fixing specific MCP issues

#### AWS documentation server

1. Connection failures:
bash# Verify uv installation
uv --version

# Verify Python version
python --version

# Test server directly
uvx awslabs.aws-documentation-mcp-server@latest --help
2. Search or read failures:
  - Check your internet connection
  - Verify the URL format for documentation pages
  - Try with a simpler search query

#### GitHub MCP server

1. Authentication errors:
  - Verify your personal access token is valid
  - Ensure the token has the required scopes (repo, user)
  - Generate a new token if necessary
2. Rate limiting issues:
  - GitHub API has usage limits
  - Check the rate limit status in the MCP logs
  - Consider using a token with higher rate limits

## Getting help

If you've tried the troubleshooting steps above and still need assistance:

1. Check our FAQ for common questions
2. Join our community Discord for help
3. Submit an issue on GitHub with:
  - Your operating system details
  - Kiro version
  - Steps you've already tried
  - Error messages (if any)

### Upgrading your subscription - IDE - Docs - Kiro

# Upgrading your subscription

---

Upgrading your Kiro plan gives you access to more features and higher credit limits. Once you upgrade your subscription, it'll take effect immediately. You'll be charged a prorated fee, but immediately get access to your new plan's full credit limits.

## Upgrading a social or AWS Builder ID account for the first time

Use the following instructions to upgrade a social account or an AWS Builder ID account for the first time in Kiro.

Currently, you can only upgrade an AWS Builder ID account if it is *not* linked to an AWS account. If you access Kiro through a social login provider or a Builder ID account, your payments are currently processed by Stripe and Amazon Web Services, Inc. is your AWS Contracting Party under your agreement with us.

1. In Kiro, select the profile icon.
2. Choose Upgrade Plan.
3. Select which plan you'd like to upgrade to.
4. Choose Open. You will be redirected to your default web browser to complete upgrade process.
5. In the browser, confirm the details of the plan and then enter your email.
6. Select your payment method, enter your payment details, and then choose Subscribe.
7. After confirming your subscription, you can select Get started to return back to the Kiro IDE.

## Upgrading a social or AWS Builder ID account

After you've upgraded plans for the first time, you will no longer see the plan options in the Kiro IDE. Instead, use the following instructions to upgrade a social account or an AWS Builder ID account.

1. In Kiro, select the profile icon.
2. Choose Manage Plan. You will be redirected to your default web browser to complete the upgrade process.
3. In the browser, choose Update subscription, select which plan you'd like to upgrade to, and then choose Continue.
4. Confirm the details of the plan and then choose Confirm.
5. After confirming your subscription, you can select Return to Kiro to return to the Kiro IDE.

## Decision Matrix

| Tool Type | What | When to Use | When Not to Use | Alternatives | Platform |
| --- | --- | --- | --- | --- | --- |
| spec | Structured requirements, design, and task documents | Complex features needing formal planning and tracking | Quick fixes or simple changes | steering-doc, skill | ide |
| hook | Automated actions triggered by IDE/CLI events | Automating repetitive tasks on file save, create, or delete | One-time operations or complex multi-step workflows | steering-doc, custom-agent | both |
| steering-doc | Markdown instructions loaded into agent context | Providing persistent coding guidelines or project rules | Dynamic behavior that needs runtime logic | skill, hook | both |
| skill | Portable agent skills following the Agent Skills spec | Reusable domain knowledge shareable across agents | IDE-specific UI integrations or one-off scripts | steering-doc, power | both |
| power | IDE extension with docs, MCP servers, and steering | Rich IDE integrations with tool access and guided workflows | CLI-only workflows or simple text guidance | skill, custom-agent | ide |
| mcp-server | Model Context Protocol server exposing tools via JSON-RPC | Exposing external APIs or services to AI agents | Simple file-based knowledge or static documentation | power, custom-agent | both |
| custom-agent | CLI agent with custom prompt, tools, and MCP servers | CLI-specific workflows with custom tool configurations | IDE-only features or simple steering | power, hook | cli |
| autonomous-agent | Cloud-hosted agent running tasks autonomously | Long-running tasks, CI/CD integration, background work | Interactive development or quick local operations | custom-agent, hook | both |
| subagent | Delegated agent invoked by the main IDE agent | Breaking complex tasks into focused sub-tasks | Simple single-step operations | hook, steering-doc | ide |
| context-provider | #-prefixed references injecting context into chat | Providing files, folders, or specs as chat context | Automated workflows or programmatic tool access | steering-doc, skill | ide |

## Quick Reference

| Scenario | Recommended Tools | Rationale |
| --- | --- | --- |
| I want to automate on file save | hook | Hooks trigger on file events like save, create, delete |
| I want to enforce coding standards | steering-doc, hook | Steering docs provide persistent rules; hooks automate checks |
| I want to plan a complex feature | spec | Specs provide structured requirements, design, and task tracking |
| I want to share knowledge across agents | skill, mcp-server | Skills are portable; MCP servers expose tools to any agent |
| I want a rich IDE integration | power | Powers combine docs, MCP servers, and steering for IDE |
| I want to expose an API to AI agents | mcp-server | MCP servers expose tools via JSON-RPC to any MCP client |
| I want a CLI-specific workflow | custom-agent | Custom agents configure CLI-specific tools and prompts |
| I want to run tasks in the background | autonomous-agent | Autonomous agents run cloud-hosted tasks independently |
| I want to break a task into sub-tasks | subagent | Subagents handle focused sub-tasks delegated by the main agent |
| I want to inject context into chat | context-provider | Context providers use # references to inject files and specs |
| I want to validate configs on commit | hook, custom-agent | Hooks trigger on events; CLI agents run validation scripts |
| I want cross-platform tool access | mcp-server, skill, steering-doc | MCP, skills, and steering work on both IDE and CLI |
